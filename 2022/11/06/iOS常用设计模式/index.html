<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="基本原则 开闭原则（Open Close Principle）   对扩展打开，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。   里氏替换原则（Liskov Substitution Principle）   父子可以相互调用，父类必须提供足够多的抽象方法供子类重载使用。 任何基类可以出现的地方，子类一定可以出">
<meta name="keywords" content="iOS开发 前端 JS">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS常用设计模式">
<meta property="og:url" content="https://bigporo.github.io/2022/11/06/iOS常用设计模式/index.html">
<meta property="og:site_name" content="iDog的精神时光屋">
<meta property="og:description" content="基本原则 开闭原则（Open Close Principle）   对扩展打开，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。   里氏替换原则（Liskov Substitution Principle）   父子可以相互调用，父类必须提供足够多的抽象方法供子类重载使用。 任何基类可以出现的地方，子类一定可以出">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d51f50b9513d4860956a4d9ad4b9828e~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daf0d6095c124d92a97a97a4a34717c3~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddf793b7ac934ed29991e6ee9bbc3411~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a30fbedc884b5cad3d926d85e4dd0b~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c54a66c2f2a24c4b95f97e9684f97b2b~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9338ea495fce47c9ba91c61d986679bb~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff078ae770e5490689dba05ac3fc20b6~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/898eff871ad1463eae3fbda3caebf46d~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.itxxb.com%2Fresource%2F20171203%2F2%2F20171203184818093_1.jpg&refer=http%3A%2F%2Fwww.itxxb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1670242675&t=6abd84d44562df8c2c11777d85041dad">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20210201104702932.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dyZWVkeVNuYWtlcg%3D%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1670245742&t=0844b272a91e998eab634f1314d702bc">
<meta property="og:updated_time" content="2022-11-06T01:35:56.316Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS常用设计模式">
<meta name="twitter:description" content="基本原则 开闭原则（Open Close Principle）   对扩展打开，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。   里氏替换原则（Liskov Substitution Principle）   父子可以相互调用，父类必须提供足够多的抽象方法供子类重载使用。 任何基类可以出现的地方，子类一定可以出">
<meta name="twitter:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d51f50b9513d4860956a4d9ad4b9828e~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bigporo.github.io/2022/11/06/iOS常用设计模式/">





  <title>iOS常用设计模式 | iDog的精神时光屋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/BigPoro" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">iDog的精神时光屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigporo.github.io/2022/11/06/iOS常用设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iDog">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://raw.githubusercontent.com/BigPoro/PictureBed/master/head_portrait.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iDog的精神时光屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS常用设计模式</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-11-06T09:26:25+08:00">
                2022-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书/" itemprop="url" rel="index">
                    <span itemprop="name">读书</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  35
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d51f50b9513d4860956a4d9ad4b9828e~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp" alt="image"></p>
<h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><ul>
<li>开闭原则（Open Close Principle）</li>
</ul>
<blockquote>
<p>对扩展打开，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p>
</blockquote>
<ul>
<li>里氏替换原则（Liskov Substitution Principle）</li>
</ul>
<blockquote>
<p>父子可以相互调用，父类必须提供足够多的抽象方法供子类重载使用。 任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。<br><a id="more"></a></p>
</blockquote>
<ul>
<li>依赖倒转原则（Dependence Inversion Principle）</li>
</ul>
<blockquote>
<p>抽象不依赖细节，细节依赖抽象。这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
</blockquote>
<ul>
<li>接口隔离原则（Interface Segregation Principle）</li>
</ul>
<blockquote>
<p>尽量做必要的事。使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
</blockquote>
<ul>
<li>最少知道原则（Demeter Principle），迪米特法则</li>
</ul>
<blockquote>
<p>个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
</blockquote>
<ul>
<li>合成/聚合复用</li>
</ul>
<blockquote>
<p>尽量使用合成/聚合的方式，而不是使用继承。</p>
</blockquote>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ul>
<li><p>是什么？</p>
<p>  适配器模式作为两个不兼容的接口之间的桥梁，它将一个类的接口转换成客户端希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p>  适配器模式有时也称作为包装器 （<em>Wapper</em>)。适配器实现客户端所要的某种接口的行为。同时，它又连接到另一个具有（完全）不同接口与行为的对象。一边是客户端懂得如何使用的目标接口，另一边是客户端一无所知的被适配者，适配器处于两者之间。适配器的主要作用是把被适配者的行为传递给管道另一端的客户端。</p>
</li>
<li><p>怎么用？</p>
<ul>
<li>当你想使用一个已经存在的类，而它的接口不符合你的需求；</li>
<li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作；</li>
<li>你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口，对象适配器可以适配它的父亲接口。</li>
</ul>
</li>
<li><p>优缺点？</p>
<ul>
<li>优点：降低数据层和视图层（对象）的耦合度，使之使用更加广泛，适应复杂多变的变化。</li>
<li>缺点：降低了可读性，代码量增加，对于不理解这种模式的人来说比较难看懂。</li>
</ul>
</li>
</ul>
<h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p>通过继承来适配两个接口，这称为类适配器。在 <code>Objective-C</code> 可以通过实现接口或协议，同时继承父类来实现类适配。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daf0d6095c124d92a97a97a4a34717c3~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
<blockquote>
<p><code>Target</code> 指目标接口。 <code>Adaptee</code> 指被适配者。 <code>request</code>意为请求行为。</p>
</blockquote>
<p><code>Adapter</code> 是一个 遵守了 <code>&lt;Target&gt;</code> 协议，同时也是一个 <code>Adaptee</code> 类型。<code>Adapter</code> 实现了 <code>Target</code> 的 <code>request</code> 方法。但是 <code>Adapter</code>没有重载 <code>Adaptee</code> 的 <code>specficRequest</code>方法，而是在 <code>Adapter</code> 的 <code>request</code> 方法中的实现中，调用父类 <code>specficRequest</code>方法。<code>request</code> 方法在运行时向父类发送 <code>[super specficRequest]</code> 消息。<code>super</code> 就是 <code>Adaptee</code> ，它的 <code>Adapter</code> 的 <code>request</code> 方法的作用域内，按自己的方式执行 <code>specficRequest</code> 方法。</p>
<blockquote>
<p>只有当 <code>Target</code>是协议而不是类时，类适配器才能够用 <em>Objective-C</em> 来实现。协议的设计与适配器模式的描述并不完全匹配。但它实现了该模式的目标：允许具有其他不兼容接口的类一起工作。</p>
</blockquote>
<p><strong>代码实现：</strong></p>
<ul>
<li><p>假设现在有一个TypeC接口的设备</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface TypeCDevice: NSObject</span><br><span class="line">- (void)connectWithTypeC;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation TypeCDevice</span><br><span class="line">- (void)connectWithTypeC &#123;</span><br><span class="line">  NSLog(@&quot;TypeC connect&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在需要将MicroUSB数据线通过<code>MicroUSBToTypeCAdapter</code>连接TypeC接口的设备</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@protocol MicroUSBProtocol&lt;NSObject&gt;;</span><br><span class="line">@required</span><br><span class="line">- (void)connectWithMicroUSB;//声明适配方法</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface MicroUSBToTypeCAdapter : TypeCDevice&lt;MicroUSBProtocol&gt;;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MicroUSBToTypeCAdapter</span><br><span class="line">- (void)connectWithMicroUSB &#123;</span><br><span class="line">    NSLog(@&quot;MicroUSB convert To TypeC&quot;);</span><br><span class="line">    [super connectWithTypeC];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p><strong>对象适配器不继承被适配者，而是组合了一个对它的引用</strong>。实现为对象适配器时，它们之间的关系为：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddf793b7ac934ed29991e6ee9bbc3411~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
<p><code>Target</code>和<code>Adapter</code>之间的关系与类适配器相同，而<code>Adapter</code>与<code>Adaptee</code>之间的关系从“<em>属于</em>”变成了“<em>包含</em>”。这种关系下，<code>Adapter</code>需要保持一个对<code>Adaptee</code>的引用。在<code>request</code>方法中，<code>Adapter</code>发送<code>[adaptee specficRequest]</code>消息给引用<code>adaptee</code>，以间接访问它的行为，然后实现客户端请求的其余部分。由于<code>Adapter</code>与<code>Adaptee</code>之间是一种“包含”关系，用<code>Adapter</code>去适配<code>Adaptee</code>的子类也没什么问题。</p>
<p><strong>代码实现：</strong></p>
<ul>
<li>假设当前有一个<code>&lt;MediaPlayer&gt;</code>协议和一个遵守<code>&lt;MediaPlayer&gt;</code>的类<code>AudioPlayer</code>。默认情况下，<code>AudioPlayer</code>可以播放<em>mp3</em>格式的音频文件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@protocol MediaPlayer &lt;NSObject&gt;;</span><br><span class="line">- (void)play:(NSString *)audioType FileName:(NSString *)fileName;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface AudioPlayer:  NSObject&lt;MediaPlayer&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AudioPlayer</span><br><span class="line">- (void)play:(NSString *)audioType FileName:(NSString *)fileName &#123;</span><br><span class="line">    NSLog(@&quot;Playing audio file. Name:%@&quot;,fileName);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li><p>还有一个<code>&lt;AdvancedMediaPlayer&gt;</code>协议，和实现了<code>&lt;AdvancedMediaPlayer&gt;</code>接口的实体类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@protocol AdvancedMediaPlayer &lt;NSObject&gt;</span><br><span class="line">@optional</span><br><span class="line">- (void)playVlc:(NSString *)fileName;</span><br><span class="line">- (void)playMp4:(NSString *)fileName;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface VlcPlayer : NSObject&lt;AdvancedMediaPlayer&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation VlcPlayer</span><br><span class="line">- (void)playVlc:(NSString *)fileName&#123;</span><br><span class="line">    NSLog(@&quot;Playing vlc file. Name:%@&quot;,fileName);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Mp4Player : NSObject&lt;AdvancedMediaPlayer&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Mp4Player</span><br><span class="line">- (void)playMp4:(NSString *)fileName &#123;</span><br><span class="line">    NSLog(@&quot;Playing mpf4 file. Name:%@&quot;,fileName);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了让 <code>AudioPlayer</code> 支持播放其他格式的音频文件。需要创建一个实现了 <code>MediaPlayer</code> 接口的适配器类 <code>MediaAdapter</code>，并使用 遵守了<code>AdvancedMediaPlayer</code> 协议的实例来播放所需的格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@interface MediaAdapter : NSObject &lt;MediaPlayer&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, week) id &lt;AdvancedMediaPlayer&gt; advancedMusicPlayer;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithAudioType:(NSString *)audioType;</span><br><span class="line">- (instancetype)init NS_UNAVAILABLE;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MediaAdapter</span><br><span class="line">- (instancetype)initWithAudioType:(NSString *)audioType &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        if ([audioType isEqualToString:@&quot;vlc&quot;]) &#123;</span><br><span class="line">            self.advancedMusicPlayer = [VlcPlayer new];</span><br><span class="line">        &#125; else if ([audioType isEqualToString:@&quot;mp4&quot;])&#123;</span><br><span class="line">            self.advancedMusicPlayer = [Mp4Player new];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)play:(NSString *)audioType FileName:(NSString *)fileName &#123;</span><br><span class="line">    if ([audioType isEqualToString:@&quot;vlc&quot;]) &#123;</span><br><span class="line">        if ([self.advancedMusicPlayer respondsToSelector:@selector(playVlc:)]) &#123;</span><br><span class="line">            [self.advancedMusicPlayer playVlc:fileName];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else if ([audioType isEqualToString:@&quot;mp4&quot;]) &#123;</span><br><span class="line">        if ([self.advancedMusicPlayer respondsToSelector:@selector(playMp4:)]) &#123;</span><br><span class="line">            [self.advancedMusicPlayer playMp4:fileName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><ul>
<li><p>是什么？</p>
<p>  策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的对象而独立变化。</p>
</li>
<li><p>怎么用？</p>
<p>  在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p>
<p>  比如：小孩和大人，小孩吃蔬菜，大人吃肉，小孩每天跑步一小时，大人每天跑步2小时。使用继承会导致代码复用性交叉。</p>
<ul>
<li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li>
<li>一个系统需要动态地在几种算法中选择一种。</li>
<li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li>
<li><strong>注意事项</strong>：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</li>
</ul>
</li>
<li><p>优缺点？</p>
<ul>
<li>优点：简化操作，提高代码维护性。算法可以自由切换，避免使用多重条件判断，扩展性良好。</li>
<li>缺点：在使用之前就要确定使用某种策略，而不是动态的选择策略。策略类会增多，所有策略类都需要对外暴露。</li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<ul>
<li><p>定义一个通用算法协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@protocol PlayerProtocol &lt;NSObject&gt;</span><br><span class="line">@optional</span><br><span class="line">- (NSString *)play;</span><br><span class="line">- (NSString *)pause;</span><br><span class="line">- (NSString *)stop;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>APlayer的算法封装</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface APlayer : NSObject&lt;PlayerProtocol&gt;</span><br><span class="line">@property (nonatomic, week) id &lt;PlayerProtocol&gt; player;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation APlayer</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        player = [[APlayer alloc] init];// 初始化AVPlayer播放器对象</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 播放</span><br><span class="line">- (NSString *)play&#123;</span><br><span class="line">    return [player a_play];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 暂停</span><br><span class="line">- (NSString *)pause&#123;</span><br><span class="line">    return [player a_pause];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 停止</span><br><span class="line">- (NSString *)stop&#123;</span><br><span class="line">    return [player a_stop];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li><p>BPlayer的算法封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@interface BPlayer : NSObject&lt;PlayerProtocol&gt;</span><br><span class="line">@property (nonatomic, week) id &lt;PlayerProtocol&gt; player;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation BPlayer</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        player = [[BPlayer alloc] init];// 初始化AVPlayer播放器对象</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 播放</span><br><span class="line">- (NSString *)play&#123;</span><br><span class="line">    return [player b_play];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 暂停</span><br><span class="line">- (NSString *)pause&#123;</span><br><span class="line">    return [player b_pause];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 停止</span><br><span class="line">- (NSString *)stop&#123;</span><br><span class="line">    return [player b_stop];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>通用播放器类CPlayer的定义。根据不同的策略选择不同的算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 播放器的类型</span><br><span class="line">typedef enum : NSUInteger &#123;</span><br><span class="line">    PlayerType_APlayer,</span><br><span class="line">    PlayerType_BPlayer</span><br><span class="line">&#125; PlayerType;</span><br><span class="line"></span><br><span class="line">@interface CPlayer : NSObject</span><br><span class="line">- (instancetype)initWithType:(layerType)type;</span><br><span class="line">@property (nonatomic, week) id &lt;PlayerProtocol&gt; player;</span><br><span class="line"></span><br><span class="line">- (NSString *)play;</span><br><span class="line">- (NSString *)pause; </span><br><span class="line">- (NSString *)stop; </span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Clayer</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithType:(PlayerType)type &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        [self initPlayerWithType:type];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化播放器</span><br><span class="line">- (void)initPlayerWithType:(PlayerType)type &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case PlayerType_APlayer: &#123;</span><br><span class="line">            player = [[AVPlayer alloc] init];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case PlayerType_BPlayer: &#123;</span><br><span class="line">            player = [[BPlayer alloc] init];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//开启视频</span><br><span class="line">- (NSString *)play &#123;</span><br><span class="line">    return [player play];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//暂停视频</span><br><span class="line">- (NSString *)pause &#123;</span><br><span class="line">    return [player pause];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//停止播放</span><br><span class="line">- (NSString *)stop &#123;</span><br><span class="line">    return [player stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><ul>
<li><p>是什么？</p>
<p>  本质上是一种发布-订阅模型，当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。如<code>NSNotificationCenter</code>、<code>KVO</code>。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a30fbedc884b5cad3d926d85e4dd0b~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
</li>
<li><p>怎么用？</p>
<p>  一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p>
</li>
<li>优缺点？<ul>
<li>优点：观察者和被观察者是抽象耦合的。</li>
<li>缺点：<ol>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><ul>
<li><p>是什么？</p>
<p>  用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。</p>
</li>
<li><p>怎么用？</p>
<ul>
<li>需要创建的对象不依赖于具体的类型以及创建方式</li>
<li>具体实例化的对象类型是在运行期决定的</li>
<li>不同类型之间的差异仅仅是状态的组合</li>
<li>类型创建复杂,例如类型有复杂的嵌套</li>
<li>很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。</li>
</ul>
</li>
<li>优缺点<ul>
<li>优点：性能提高 </li>
<li>缺点：配备克隆方法需要对类的功能进行通盘考虑。逃避构造函数的约束。</li>
</ul>
</li>
</ul>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Person 需要遵循并实现NSCopying</span><br><span class="line">Person *p1 = [[Person alloc] init];</span><br><span class="line">p1.name = @&quot;jack&quot;;</span><br><span class="line">p1.age = 10;</span><br><span class="line">    </span><br><span class="line">Person * p2 = [p1 copy];</span><br><span class="line">p2.name = @&quot;rose&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><ul>
<li><p>是什么？</p>
<p>  外观模式为子系统中一组不同的接口提供统一的接口。<br>外观定义了上层接口，通过降低复杂度和隐藏子系统间的通信及依存关系，让子系统更易于使用。<br>外观模式是面向对象编程里使用得很频繁的一个模式。最经常见到的例子就是各种库里的Manager类。比如<code>SDWebImage</code>。</p>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c54a66c2f2a24c4b95f97e9684f97b2b~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
<ul>
<li><p>怎么用？</p>
<ul>
<li>外部不需要知道系统内部的复杂联系，整个系统只需提供一个接口即可。<ul>
<li>每个子系统层级有一个外观作为入口，让它们通过其外观进行通信，可以简化它们之间的依赖关系。</li>
</ul>
</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li>优点：减少系统相互依赖、提高灵活性、提高了安全性</li>
<li>缺点：不符合开闭原则，由于没有很多的接口暴露，如果要改东西很麻烦，继承重写都不合适。</li>
</ul>
</li>
</ul>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><ul>
<li><p>是什么？</p>
<p>  是指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。是继承的替代方案，属于结构型模式，它是作为现有的类的一个包装，比继承子类方式更灵活。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9338ea495fce47c9ba91c61d986679bb~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
</li>
<li><p>怎么用？</p>
<ul>
<li>抽象构件（<code>Component</code>）：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（<code>ConcreteComponent</code>）：继承抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（<code>Decorator</code>）：持有抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（<code>ConcreteDecorator</code>）：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</li>
<li>缺点：多层继承装饰比较复杂。</li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<ul>
<li><p>先定义抽象构件类Hero，通过方法blessBuff展示英雄此时所加持的buff</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface Hero : NSObject</span><br><span class="line">- (void)blessBuff;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Hero</span><br><span class="line">- (void)blessBuff &#123;</span><br><span class="line">    NSAssert(false, @&quot;must implement in subClass&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义具体构件英雄盖伦Galen和Timo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Galen.h</span><br><span class="line">@interface Galen : Hero</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Galen</span><br><span class="line">- (void)blessBuff &#123;</span><br><span class="line">    NSLog(@&quot;盖伦被动技能：脱离战斗后回血加快&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Timo : Hero</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Timo</span><br><span class="line">- (void)blessBuff &#123;</span><br><span class="line">    NSLog(@&quot;提莫被动技能：脱离战斗后，静止不动一段时间进入隐身&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义抽象装饰器BuffDecorator</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 集成抽象构件</span><br><span class="line">@interface BuffDecorator : NSObject</span><br><span class="line">- (instancetype)initWithHero:(Hero *)hero;</span><br><span class="line">@property (nonatomic, strong) Hero *hero;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation BuffDecorator</span><br><span class="line">- (instancetype)initWithHero:(Hero *)hero &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _hero = hero;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)blessBuff &#123;</span><br><span class="line">    [_hero blessBuff];</span><br><span class="line">    NSLog(@&quot;额外buff:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li><p>定义具体装饰器红buff</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 集成抽象装饰器</span><br><span class="line">@interface RedBuffDecorator : BuffDecorator</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation RedBuffDecorator</span><br><span class="line">- (void)blessBuff &#123;</span><br><span class="line">    [super blessBuff];</span><br><span class="line">    NSLog(@&quot;红buff: 攻击附加真实伤害，并造成灼烧效果&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义具体装饰器蓝buff</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 集成抽象装饰器</span><br><span class="line">@interface BlueBuffDecorator : BuffDecorator</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation BlueBuffDecorator</span><br><span class="line">- (void)blessBuff &#123;</span><br><span class="line">    [super blessBuff];</span><br><span class="line">    NSLog(@&quot;蓝buff: 蓝量回复速度加快，并且缩减技能CD&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Hero *galen = [Galen new];</span><br><span class="line">galen = [[RedBuffDecorator alloc] initWithHero:galen];</span><br><span class="line">[galen blessBuff];</span><br><span class="line">galen = [[BlueBuffDecorator alloc] initWithHero:galen];</span><br><span class="line">[galen blessBuff];</span><br><span class="line">NSLog(@&quot;----------------Timo----------------------&quot;);</span><br><span class="line">Hero *timo = [Timo new];</span><br><span class="line">timo = [[RedBuffDecorator alloc] initWithHero:timo];</span><br><span class="line">[timo blessBuff];</span><br><span class="line">timo = [[BlueBuffDecorator alloc] initWithHero:timo];</span><br><span class="line">[timo blessBuff];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ul>
<li><p>是什么？</p>
<p>  这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
</li>
<li><p>怎么用？</p>
<ul>
<li>明确地计划不同条件下创建不同实例时。</li>
<li>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li>优点：扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。屏蔽对象的具体实现，调用者只关心产品的接口。</li>
<li>缺点：在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</li>
</ul>
</li>
</ul>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><ul>
<li>当系统中只有唯一的产品时，可以省略抽象产品，工厂角色与具体产品可以合并。</li>
<li>工厂类只有一个，它集中了所有产品创建的逻辑，它将是整个系统的瓶颈，同时造成系统难以拓展。</li>
<li>简单工厂模式通常使用静态工厂方法，这使得工厂类无法由子类继承，这使得工厂角色无法形成基于继承的等级结构。</li>
</ul>
<p><strong>代码实现：</strong></p>
<ul>
<li><p>定义抽象产品类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface Food : NSObject</span><br><span class="line">@property (nonatomic, copy)NSString *product;</span><br><span class="line">- (void)productBreakfast; </span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Food</span><br><span class="line">- (void)productBreakfast&#123;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义具体产品类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface Milk : Food</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Milk</span><br><span class="line">- (void)productBreakfast&#123;    </span><br><span class="line">    _product = @&quot;牛奶&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interface Bread : Food</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Bread</span><br><span class="line">- (void)productBreakfast&#123;    </span><br><span class="line">    _product = @&quot;面包&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义工厂类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, FactoryProductType)&#123;</span><br><span class="line">    FactoryProductTypeMilk,</span><br><span class="line">    FactoryProductTypeBread,</span><br><span class="line">&#125;;</span><br><span class="line">@interface Factory : NSObject</span><br><span class="line">//工厂（Factory）角色：接受客户端的请求，通过请求负责创建相应的产品对象。</span><br><span class="line">+ (Food *)operationBreakfast:(FactoryProductType )breakfastType;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SFFactory</span><br><span class="line">+ (Food *)operationBreakfast:(FactoryProductType)breakfastType &#123;</span><br><span class="line">    //通过枚举返回不同的产品</span><br><span class="line">    Food *food;</span><br><span class="line">    switch (breakfastType) &#123;</span><br><span class="line">        case FactoryProductTypeMilk:</span><br><span class="line">            food = [[Milk alloc] init];</span><br><span class="line">            break;</span><br><span class="line">        case FactoryProductTypeBread:</span><br><span class="line">            food = [[Bread alloc] init];</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            return nil;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return food;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="标准工厂模式"><a href="#标准工厂模式" class="headerlink" title="标准工厂模式"></a>标准工厂模式</h3><p>在简单工厂模式的基础上，增加抽象工厂。<br>共有如下四个角色：</p>
<ul>
<li>抽象工厂角色：与应用程序无关，任何在模式中创建对象的工厂必须实现这个接口。</li>
<li>具体工厂角色：实现了抽象工厂接口的具体类，含有与引用密切相关的逻辑，并且受到应用程序的调用以创建产品对象。</li>
<li>抽象产品角色：工厂方法所创建产品对象的超类型，也就是产品对象的共同父类或共同拥有的接口。</li>
<li>具体产品角色：这个角色实现了抽象产品角色所声名的接口。工厂方法所创建的每个具体产品对象都是某个具体产品角色的实例。</li>
</ul>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><ul>
<li>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<ul>
<li>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</li>
</ul>
</li>
</ul>
<p>参与角色与标准工厂模式一样，不过抽象工厂不仅仅作为接口存在，而可以产生其他工厂。</p>
<p><strong>代码实现：</strong></p>
<ul>
<li><p>定义抽象产品、具体产品和简单工厂一致</p>
</li>
<li><p>定义抽象工厂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface Factory : NSObject</span><br><span class="line">typedef NS_ENUM(NSInteger, FactoryProductType) &#123;</span><br><span class="line">    FactoryProductTypeMilk,</span><br><span class="line">    FactoryProductTypeBread,</span><br><span class="line">&#125;;</span><br><span class="line">+ (instancetype)factoryWithType:(FactoryProductType)type;</span><br><span class="line">- (Food *)createProduct;</span><br><span class="line"></span><br><span class="line">@implementation AFFactory</span><br><span class="line"></span><br><span class="line">+ (instancetype)factoryWithType:(FactoryProductType)type &#123;</span><br><span class="line">    Factory *factory;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case FactoryProductTypeMilk:</span><br><span class="line">            factory = [[FactoryMilk alloc] init];</span><br><span class="line">            break;</span><br><span class="line">        case FactoryProductTypeBread:</span><br><span class="line">            factory = [[FactoryBread alloc] init];</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return factory;</span><br><span class="line">&#125;</span><br><span class="line">- (Food *)createProduct &#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义具体工厂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface FactoryMilk : Factory</span><br><span class="line">@end</span><br><span class="line">@implementation FactoryMilk</span><br><span class="line">- (Food *)createProduct &#123;</span><br><span class="line">    return [[Milk alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface FactoryBread : Factory</span><br><span class="line">@end</span><br><span class="line">@implementation FactoryBread</span><br><span class="line">- (Food *)createProduct &#123;</span><br><span class="line">    return [[Bread alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Factory *factory = [Factory factoryWithType:FactoryProductTypeMilk];</span><br><span class="line">Food *milk = [factory createProduct];</span><br><span class="line">[milk productBreakfast];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从简单工厂模式到工厂模式，再到抽象工厂模式。可以看到整个模式的一步步演进。</p>
<p>简单工厂模式在产品多样之后，整个工厂将会变得臃肿而难以维护。于是将简单工厂模式中的工程做了抽象处理，这样每种产品对应一个工厂。这样无疑会增加代码量。但是好处是显而易见的，单独让一个工厂处理一种产品会让逻辑变得好维护。</p>
<p>但是这样还不够，因为增加新的品类，就会产生新的类，对于调用者来说，处理太多具有相同接口的类显然是不合算的。于是，我们使用抽象工厂模式来解决这个问题。我们让抽象工厂内部做一个封装，用以隐藏真正的具体工厂。这样，对于调用者来说，即时内部增加了新的产品，外部也是不知道的。</p>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><ul>
<li><p>是什么？</p>
<p>  从针对不同的实现中，分离出其可被复用的抽象称为桥接模式。这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。比如遥控器和电视机。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff078ae770e5490689dba05ac3fc20b6~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
<p>  <code>Abstraction</code> 是定义了供客户端使用的上层抽象接口的父接口。它有一个对 <code>Implementor</code> 实例的引用，<code>Implementor</code> 定义了实现类的接口。这个接口不必跟 <code>Abstraction</code> 的接口一致。<code>Implementor</code> 的接口提供基本操作，而 <code>Abstraction</code> 的上层操作基于这些基本操作。当客户端向 <code>Abstraction</code> 的实例发送 <code>operation</code> 消息时，这个方法向 <code>imp</code> 发送 <code>operationImp</code> 消息。实际的 <code>ConcreteImplementator</code> 将作出响应并接收任务。</p>
</li>
<li><p>怎么用？</p>
<ul>
<li>不想在抽象与其实现之间形成固定的绑定关系</li>
<li>抽象及其实现都应可以通过子类独立化进行扩展</li>
<li>对抽象的实现进行修改不应影响客户端代码</li>
<li>如果每个实现需要额外的子类以细化抽象，则说明有必要把它们分成两个部分</li>
<li>想在带有不同抽象接口的多个对象之前共享一个实现。</li>
</ul>
</li>
<li><p>优缺点？</p>
<ul>
<li>优点：抽象和实现的分离、优秀的扩展能力、实现细节对客户透明。</li>
<li>缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<ul>
<li>定义实现类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, EcommandType) &#123;</span><br><span class="line">    kUp,</span><br><span class="line">    kDown,</span><br><span class="line">    kLeft,</span><br><span class="line">    kRight,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@interface AbstractImplementor : NSObject</span><br><span class="line">- (void)loadCommand:(EcommandType)command;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AbstractImplementor</span><br><span class="line">- (void)loadCommand:(EcommandType)command &#123;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li><p>定义抽象类，并建立桥接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@interface AbstractSystem : NSObject</span><br><span class="line">// 建立桥接</span><br><span class="line">@property (nonatomic, strong) AbstractImplementor  *implementor;</span><br><span class="line"></span><br><span class="line">//上下左右 把调用实现类方法的桥接行为包装起来</span><br><span class="line">- (void)command_up;</span><br><span class="line">- (void)command_down;</span><br><span class="line">- (void)command_left;</span><br><span class="line">- (void)command_right;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AbstractSystem</span><br><span class="line">- (void)command_up &#123;</span><br><span class="line">    [self.implementor loadCommand:kUp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)command_down &#123;</span><br><span class="line">    [self.implementor loadCommand:kDown];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)command_left &#123;</span><br><span class="line">    [self.implementor loadCommand:kLeft];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)command_right &#123;</span><br><span class="line">    [self.implementor loadCommand:kRight];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)loadSystem &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建实现类的子类PSPImplementor</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@interface PSPImplementor : AbstractImplementor</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation PSPImplementor</span><br><span class="line">- (void)loadCommand:(EcommandType)command &#123;</span><br><span class="line">    switch (command) &#123;</span><br><span class="line">        case kUp:</span><br><span class="line">            NSLog(@&quot;PSP up&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case kDown:</span><br><span class="line">            NSLog(@&quot;PSP down&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case kLeft:</span><br><span class="line">            NSLog(@&quot;PSP left&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case kRight:</span><br><span class="line">            NSLog(@&quot;PSP right&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            NSLog(@&quot;PSP None&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li><p>创建抽象类的子类PSPSystem</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface PSPSystem : AbstractSystem</span><br><span class="line"></span><br><span class="line">- (void)command_up;</span><br><span class="line">- (void)command_down;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation PSPSystem</span><br><span class="line">- (void)command_up &#123;</span><br><span class="line">    [self.implementor loadCommand:kUp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)command_down &#123;</span><br><span class="line">    [self.implementor loadCommand:kDown];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PSPSystem *pspSystem  = [[PSPSystem alloc] init];</span><br><span class="line">pspSystem.implementor = [[PSPImplementor alloc] init];</span><br><span class="line">[pspSystem command_up];</span><br></pre></td></tr></table></figure>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ul>
<li><p>是什么？</p>
<p>  为其他对象提供一种代理可以控制对这个对象的访问。</p>
</li>
<li><p>怎么用？</p>
<p>  通俗讲一个例子，同学A给同学B送东西，但是同学A临时有事去不了，这时同学A需要找了另外同学C帮他去送东西，我们就说C是A的代理，送东西这件事就是他们之间的协议。</p>
<ul>
<li>协议：用来指定代理双方要做什么事情（送东西）</li>
<li>代理：根据指定的协议，完成协议规定的事情（同学C）</li>
<li>委托：根据指定的协议，指定代理去完成的事情（同学A）</li>
</ul>
</li>
<li><p>优缺点？</p>
<ul>
<li>优点：职责清晰、高扩展性。</li>
<li>缺点：实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li>
</ul>
</li>
</ul>
<p>在iOS中对象是不支持多继承的，而协议可以多继承。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 当前协议继承了三个协议，这样其他三个协议中的方法列表都会被继承过来</span><br><span class="line">@protocol LoginProtocol &lt;UITableViewDataSource, UITableViewDelegate, UITextFieldDelegate&gt;</span><br><span class="line">- (void)userLoginWithUsername:(NSString *)username password:(NSString *)password;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul>
<li><p>是什么？</p>
<p>  这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。如<code>UIApplication</code>、<code>NSNotificationCenter</code>、<code>NSFileManager</code>。</p>
</li>
<li><p>怎么用？</p>
<p>  需要控制实例对象数目，节省系统资源。</p>
</li>
<li><p>优缺点？</p>
<ul>
<li>优点：在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。避免了对资源的多重占用比如写文件操作。</li>
<li>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">static Myclass _instance;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">+ (id)shareInstance &#123;</span><br><span class="line">   dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">   if(_instance == nil)</span><br><span class="line">       _instance = [MyClass alloc] init]; </span><br><span class="line">  &#125;);</span><br><span class="line">   return _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 销毁</span><br><span class="line">+ (void)dealloc &#123;</span><br><span class="line">    onceToken = 0;</span><br><span class="line">    _instance = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><ul>
<li><p>是什么？</p>
<p>  在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。<br>备忘录模式总共需要三种对象</p>
<ul>
<li>保存对象（即备忘录）</li>
<li>使用对象</li>
<li>管理备忘录对象</li>
</ul>
</li>
<li><p>怎么用？</p>
<ul>
<li>功能比较复杂的，但是需要维护或记录属性历史的类。</li>
<li>需要保存的属性只是众多属性的一小部分时。<br>一般而言，运用备忘录的思想很多，完整的运用备忘录模式的很少。</li>
</ul>
</li>
<li><p>优缺点？</p>
<ul>
<li>优点：提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。实现了信息的封装，使得用户不需要关心状态的保存细节。</li>
<li>缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<ul>
<li><p>定义备忘录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface Memo : NSObject</span><br><span class="line">@property (nonatomic, assign) NSInteger age;</span><br><span class="line">@property (nonatomic, assign) NSInteger height;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义需要备份的抽象类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@class Memo;</span><br><span class="line">@interface User : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, assign) NSInteger age;</span><br><span class="line">@property (nonatomic, assign) NSInteger height;</span><br><span class="line"></span><br><span class="line">- (Memo *)saveState;</span><br><span class="line">- (void)recoverStateFromMemo:(Memo *)memo;</span><br><span class="line"></span><br><span class="line">@implementation User</span><br><span class="line">- (Memo *)saveState &#123;</span><br><span class="line">    Memo *m = [Memo new];</span><br><span class="line">    m.age = _age;</span><br><span class="line">    m.height = _height;</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br><span class="line">- (void)recoverStateFromMemo:(Memo *)memo &#123;</span><br><span class="line">    _age = memo.age;</span><br><span class="line">    _height = memo.height;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">User *user = [User new];</span><br><span class="line">user.name = @&quot;Bob&quot;;</span><br><span class="line">user.age = 18;</span><br><span class="line">user.height = 168;</span><br><span class="line">NSMutableArray *memoArray = [NSMutableArray array];</span><br><span class="line">for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line">    [memoArray addObject:[user saveState]];</span><br><span class="line">    user.age += 1;</span><br><span class="line">    user.height += 0.8;</span><br><span class="line">&#125;</span><br><span class="line">/// 恢复到23岁时候的状态</span><br><span class="line">[user recoverStateFromMemo:memoArray[5]];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="生成器模式-建造者模式"><a href="#生成器模式-建造者模式" class="headerlink" title="生成器模式/建造者模式"></a>生成器模式/建造者模式</h2><ul>
<li><p>是什么？</p>
<p>  将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表现。<br>其整体思想是分离“什么”与“如何”。将复杂对象的构建过程分解为<code>客户-指导者-生成器（client-director-builder）</code>的关系。这样将更容易管理和复用整个过程。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/898eff871ad1463eae3fbda3caebf46d~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
<ul>
<li><code>Builder</code> 抽象建造者类<ul>
<li>为创建一个<code>Product</code>对象的各个部件指定抽象接口。</li>
</ul>
</li>
<li><code>ConcreteBuilder</code> 建造者类<ul>
<li>实现<code>Builder</code>的接口以构造和装配该产品的各个部件。</li>
<li>定义并明确它所创建的表示。</li>
<li>提供一个检索产品的接口</li>
</ul>
</li>
<li><code>Director</code> 导向器类<ul>
<li>构造一个使用<code>Builder</code>接口的对象。</li>
</ul>
</li>
<li><code>Product</code> 产品类<ul>
<li>表示被构造的复杂对象。<code>ConcreateBuilder</code>创建该产品的内部表示并定义它的装配过程。</li>
<li>包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</li>
</ul>
</li>
</ul>
</li>
<li><p>怎么用？</p>
<ul>
<li>需要创建设计各种部件的复杂对象。创建对象的算法应该独立于部件的装配方式。常见于构建组合对象。</li>
<li>构建过程需要以不同的方式（例如，部件或表现的不同组合）构建对象。</li>
</ul>
</li>
<li><p>优缺点？</p>
<ul>
<li>优点：扩展性、封装性强</li>
<li>缺点：产品必须有共同点，范围有限制。如内部变化复杂，会有很多的建造类。</li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<ul>
<li><p>定义<code>Product</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface Car : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, copy) NSString *price;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Car</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义<code>Builder</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface CarBuilder : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, copy) NSString *price;</span><br><span class="line">-(Car *)makeCar;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation CarBuilder</span><br><span class="line"></span><br><span class="line">- (Car *)makeCar &#123;</span><br><span class="line">    Car *car = [[Car alloc] init];</span><br><span class="line">    car.name = self.name;</span><br><span class="line">    car.price = self.price;</span><br><span class="line">    return  car;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义两个<code>ConcreteBuilder</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface BMWCar : BuilderCar</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation BMWCar</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.name = @&quot;BMW M5&quot;;</span><br><span class="line">        self.price = @&quot;80万&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface AudiCar : BuilderCar</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AudiCar</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.name = @&quot;Audi RS7&quot;;</span><br><span class="line">        self.price = @&quot;120万&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li>定义<code>Director</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface Director : NSObject</span><br><span class="line">+ (Car *)creatBuickCar:(BuilderCar *)builder;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Director</span><br><span class="line">+ (Car *)creatBuickCar:(BuilderCar *)builder &#123;</span><br><span class="line">    Car *car = [builder makeCar];</span><br><span class="line">    return car;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BuilderCar *car = [[BMWCar alloc] init];</span><br><span class="line">Director *dir = [Director creatBuickCar:car];</span><br></pre></td></tr></table></figure>
</li>
<li><p>与工厂模式的区别</p>
<ul>
<li>建造者模式与工厂模式是极为相似的，总体上，建造者模式仅仅只比工厂模式多了一个”导演类”的角色。</li>
<li>在建造者模式的类图中，假如把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看作是一个简单的工厂模式了。</li>
<li>与工厂模式相比，建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类——导演类。</li>
<li>工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；</li>
<li>建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。</li>
</ul>
</li>
</ul>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><ul>
<li><p>是什么？</p>
<p>  命令模式主要把请求对象封装成一个命令进行传递，由命令者和接受者组成。<br><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.itxxb.com%2Fresource%2F20171203%2F2%2F20171203184818093_1.jpg&amp;refer=http%3A%2F%2Fwww.itxxb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1670242675&amp;t=6abd84d44562df8c2c11777d85041dad" alt="image"></p>
</li>
<li><p>怎么用？</p>
<p>  在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p>
</li>
<li><p>优缺点？</p>
<ul>
<li>优点：降低了系统耦合度，新的命令可以很容易添加到系统中去。</li>
<li>缺点：可能会导致某些系统有过多的具体命令类。</li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong> 放大缩小红色视图</p>
<ul>
<li><p>定义<code>Receiver</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface Receiver : NSObject</span><br><span class="line">@property (assign, nonatomic) CGFloat width;</span><br><span class="line">@property (strong, nonatomic) UIView * redView;</span><br><span class="line"></span><br><span class="line">- (void)amplifyView:(CGFloat)pamameter;</span><br><span class="line">- (void)reduceView:(CGFloat)pamameter;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Receiver</span><br><span class="line">- (void)amplifyView:(CGFloat)pamameter &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)reduceView:(CGFloat)pamameter&#123;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义抽象命令类<code>Command</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@protocol CommandProtocol &lt;NSObject&gt;</span><br><span class="line">/// 执行命令</span><br><span class="line">- (void)excute;</span><br><span class="line">/// 撤销命令</span><br><span class="line">- (void)backExcute;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义命令类<code>ConcreteCommand</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@interface AmplifyCommand : NSObject&lt;CommandProtocol&gt;</span><br><span class="line">// 绑定接收器</span><br><span class="line">- (instancetype)initWithReceiver:(Receiver *)receiver paramter:(CGFloat)paramter;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface AmplifyCommand()</span><br><span class="line">@property (nonatomic, strong) Receiver *receiver;</span><br><span class="line">@property (nonatomic, assign) CGFloat paramter;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AmplifyCommand</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithReceiver:(Receiver *)receiver paramter:(CGFloat)paramter&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">       if (self) &#123;</span><br><span class="line">           self.receiver = receiver;</span><br><span class="line">           self.paramter = paramter;</span><br><span class="line">       &#125;</span><br><span class="line">       return self;</span><br><span class="line">&#125;</span><br><span class="line">// 执行命令</span><br><span class="line">- (void)excute &#123;</span><br><span class="line">    [self.receiver amplifyView:self.paramter];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 撤销命令</span><br><span class="line">- (void)backExcute &#123;</span><br><span class="line">    [self.receiver reduceView:self.paramter];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li><p>定义调用者<code>Invoker</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@interface Invoker : NSObject</span><br><span class="line">+ (instancetype)sharedInstance;</span><br><span class="line">// 回退指令</span><br><span class="line">- (void)rollBack;</span><br><span class="line"></span><br><span class="line">// 添加操作指令</span><br><span class="line">- (void)addAndExcute:(id &lt;CommandProtocol&gt;)command;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Invoker()</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *mArr; //存储操作指令的数组</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Invoker</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    static Invoker *cls = nil;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        cls = [[[self class] alloc] init];</span><br><span class="line">        cls.mArr = [[NSMutableArray alloc]init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)rollBack &#123;</span><br><span class="line">    // 1.获取数组中的最后一个操作</span><br><span class="line">    id &lt;CommandProtocol&gt; command = self.mArr.lastObject;</span><br><span class="line">    // 2.操作调用,撤销的步骤</span><br><span class="line">    [command backExcute];</span><br><span class="line">    // 3.删除最后操作</span><br><span class="line">    [self.mArr removeLastObject];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加操作指令</span><br><span class="line">- (void)addAndExcute:(id &lt;CommandProtocol&gt;)command &#123;</span><br><span class="line">    // 1.把操作添加到数组</span><br><span class="line">    [self.mArr addObject:command];</span><br><span class="line">    // 2.让操作调用实现的协议方法</span><br><span class="line">    [command excute];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/// 初始化接收者</span><br><span class="line">Receiver *receiver = [[Receiver alloc]init];</span><br><span class="line">receiver.redView = [UIView new];</span><br><span class="line">receiver.width = 50;</span><br><span class="line">/// 初始化命令并绑定接收者</span><br><span class="line">AmplifyCommand *command = [[AmplifyCommand alloc]initWithReceiver:receiver paramter:10];</span><br><span class="line">/// 执行命令</span><br><span class="line">[[Invoker sharedInstance] addAndExcute:command];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="组合模式-部分整体模式"><a href="#组合模式-部分整体模式" class="headerlink" title="组合模式/部分整体模式"></a>组合模式/部分整体模式</h2><ul>
<li><p>是什么？</p>
<p>  组合模式描述了一组对象，它们的处理方式与相同类型对象的单个实例相同。组合的目的是将对象“组合”成树结构以表示部分-整体层次结构,实现让客户统一对待单个对象和组合。<br><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20210201104702932.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dyZWVkeVNuYWtlcg%3D%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70&amp;refer=http%3A%2F%2Fimg-blog.csdnimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1670245742&amp;t=0844b272a91e998eab634f1314d702bc" alt="image"></p>
<p>  为部分<code>Leaf</code>对象和整体<code>Composite</code>对象定义统一的 <code>Component</code> 接口。<br>  单个 <code>Leaf</code> 对象直接实现 <code>Component</code> 接口，<code>Composite</code> 对象将请求转发给它们的子组件<br>  这使客户端能够通过 <code>Component</code> 接口统一处理 <code>Leaf</code> 和 <code>Composite</code> 对象,<code>Leaf</code> 对象直接执行请求,<code>Composite</code>对象将请求向下递归转发到它们的子组件。这使得客户端类更易于实现、更改、测试和重用。</p>
</li>
<li>怎么用？<ul>
<li>应该表示部分-整体层次结构，以便客户端可以统一处理部分和整体对象</li>
<li>部分-整体层次结构应表示为树结构。</li>
<li>用在部分、整体场景，如树形菜单，文件、文件夹的管理。</li>
</ul>
</li>
<li>优缺点：<ul>
<li>优点：高层模块调用简单、节点自由增加。</li>
<li>缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<ul>
<li><p>定义<code>Component</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 也可以用代理实现</span><br><span class="line">@interface Component : NSObject &#123;</span><br><span class="line">    NSString *name;  </span><br><span class="line">&#125;</span><br><span class="line">- (Component *)MyInit:(NSString *)myName;</span><br><span class="line">- (void)add:(Component *)c;</span><br><span class="line">- (void)remove:(Component *)c;</span><br><span class="line">-(void)display:(int)depth;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Component</span><br><span class="line">- (Component *)MyInit:(NSString *)myName &#123;</span><br><span class="line">    name = myName;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)add:(Component *)c &#123;</span><br><span class="line">&#125;</span><br><span class="line">- (void)remove:(Component *)c &#123;</span><br><span class="line">&#125;</span><br><span class="line">- (void)display:(int)depth &#123;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义<code>Leaf</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@interface Leaf : Components</span><br><span class="line">- (Leaf *)MyInit:(NSString *)myName;</span><br><span class="line">@end   </span><br><span class="line"></span><br><span class="line">@implementation Leaf</span><br><span class="line">- (Leaf *)MyInit:(NSString *)myName &#123;</span><br><span class="line">    name = myName;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)add:(Components *)c &#123;</span><br><span class="line">    NSLog(@&quot;Can not add a leaf&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)remove:(Components *)c &#123;</span><br><span class="line">    NSLog(@&quot;Can not remove from a leaf&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)display:(int)depth &#123;</span><br><span class="line">    NSLog(@&quot;[%dLevel]%@&quot;,depth,name);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义<code>Composite</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface Composite : Components &#123;</span><br><span class="line">    NSMutableArray *childrenArr;</span><br><span class="line">&#125;</span><br><span class="line">- (Composite *)MyInit:(NSString *)myName;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Composite</span><br><span class="line"></span><br><span class="line">- (Composite *)MyInit:(NSString *)myName &#123;</span><br><span class="line">    name = myName;</span><br><span class="line">    childrenArr = [NSMutableArray new];</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)add:(Components *)c &#123;</span><br><span class="line">    [childrenArr addObject:c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)remove:(Components *)c &#123;</span><br><span class="line">    [childrenArr removeObject:c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)display:(int)depth &#123;</span><br><span class="line">    NSLog(@&quot;[%dLevel]%@&quot;,depth,name);</span><br><span class="line">    for(ComComponents *component in childrenArr) &#123;</span><br><span class="line">        [component Display:depth+1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Composite *root = [[Composite alloc] MyInit:@&quot;root&quot;];</span><br><span class="line">[root Add:[[Leaf alloc] MyInit:@&quot;Leaf A&quot;]];</span><br><span class="line">[root Add:[[Leaf alloc] MyInit:@&quot;Leaf B&quot;]];</span><br><span class="line"></span><br><span class="line">Composite *comp = [[Composite alloc] MyInit:@&quot;Composite X&quot;];</span><br><span class="line">[comp Add:[[Leaf alloc]MyInit:@&quot;Leaf XA&quot;]];</span><br><span class="line">[comp Add:[[Leaf alloc]MyInit:@&quot;Leaf XB&quot;]];</span><br><span class="line">[root Add:comp]; // 添加到根节点</span><br><span class="line"></span><br><span class="line">Composite *comp2 = [[Composite alloc] MyInit:@&quot;Composite XY&quot;];</span><br><span class="line">[comp2 Add:[[Leaf alloc] MyInit:@&quot;Leaf XYA&quot;]];</span><br><span class="line">[comp2 Add:[[Leaf alloc] MyInit:@&quot;Leaf XYB&quot;]];</span><br><span class="line">[comp Add:comp2];</span><br><span class="line"></span><br><span class="line">[root Add:[[Leaf alloc] MyInit:@&quot;Leaf C&quot;]];</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    iDog
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://bigporo.github.io/2022/11/06/iOS常用设计模式/" title="iOS常用设计模式">https://bigporo.github.io/2022/11/06/iOS常用设计模式/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    
   
    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/09/15/iOS核心动画高级技巧-读书笔记/" rel="next" title="iOS核心动画高级技巧-读书笔记">
                <i class="fa fa-chevron-left"></i> iOS核心动画高级技巧-读书笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://raw.githubusercontent.com/BigPoro/PictureBed/master/head_portrait.jpg" alt="iDog">
            
              <p class="site-author-name" itemprop="name">iDog</p>
              <p class="site-description motion-element" itemprop="description">一个记录工作和生活的小地方。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/BigPoro" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/liu-huan-34-85/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本原则"><span class="nav-number">1.</span> <span class="nav-text">基本原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#适配器模式"><span class="nav-number">2.</span> <span class="nav-text">适配器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类适配器"><span class="nav-number">2.1.</span> <span class="nav-text">类适配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象适配器"><span class="nav-number">2.2.</span> <span class="nav-text">对象适配器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#策略模式"><span class="nav-number">3.</span> <span class="nav-text">策略模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#观察者模式"><span class="nav-number">4.</span> <span class="nav-text">观察者模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型模式"><span class="nav-number">5.</span> <span class="nav-text">原型模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#外观模式"><span class="nav-number">6.</span> <span class="nav-text">外观模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#装饰模式"><span class="nav-number">7.</span> <span class="nav-text">装饰模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工厂模式"><span class="nav-number">8.</span> <span class="nav-text">工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单工厂模式"><span class="nav-number">8.1.</span> <span class="nav-text">简单工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标准工厂模式"><span class="nav-number">8.2.</span> <span class="nav-text">标准工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象工厂模式"><span class="nav-number">8.3.</span> <span class="nav-text">抽象工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">8.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#桥接模式"><span class="nav-number">9.</span> <span class="nav-text">桥接模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代理模式"><span class="nav-number">10.</span> <span class="nav-text">代理模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单例模式"><span class="nav-number">11.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#备忘录模式"><span class="nav-number">12.</span> <span class="nav-text">备忘录模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生成器模式-建造者模式"><span class="nav-number">13.</span> <span class="nav-text">生成器模式/建造者模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令模式"><span class="nav-number">14.</span> <span class="nav-text">命令模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合模式-部分整体模式"><span class="nav-number">15.</span> <span class="nav-text">组合模式/部分整体模式</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">iDog</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>
  <!-- <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div> -->



  <span class="post-meta-divider"> 欢迎来到精神时光屋~~</span>



  <!-- <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div> -->




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
