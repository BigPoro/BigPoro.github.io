{"meta":{"title":"iDog的精神时光屋","subtitle":null,"description":"一个记录工作和生活的小地方。","author":"iDog","url":"https://bigporo.github.io","root":"/"},"pages":[{"title":"","date":"2019-04-19T08:35:22.380Z","updated":"2019-04-19T08:35:22.380Z","comments":true,"path":"404.html","permalink":"https://bigporo.github.io/404.html","excerpt":"","text":"var QZONE = window.QZONE || {}; function imagezoom(imgobj, box_w, box_h) { var src_w = imgobj.width; var src_h = imgobj.height; var r1 = src_w / src_h, r2 = box_w / box_h; var dst_w, dst_h; if (r1 > r2) { dst_w = box_w; dst_h = Math.round(dst_w / src_w * src_h); } else { if (r1 < r2) { dst_h = box_h; dst_w = Math.round(dst_h / src_h * src_w); } else { dst_w = box_w; dst_h = box_h; } } imgobj.style.marginLeft = (box_w - dst_w) / 2 + \"px\"; imgobj.style.marginTop = (box_h - dst_h) / 2 + \"px\"; imgobj.style.width = dst_w + \"px\"; imgobj.style.height = dst_h + \"px\"; imgobj.style.opacity = 1; } (function(_w, _d) { var ha = _d.head || _d.getElementsByTagName(\"head\")[0]; var $scope = {}; var current; var tmnow; var chId; var homePageUrl, homePageName; var scs = document.getElementsByTagName(\"script\"); if (location.href.indexOf(\"fm.qq.com\") > -1 || location.href.indexOf(\"fm.qzone.qq.com\") > -1) { homePageName = \"\\u8fd4\\u56de\\u4f01\\u9e45FM\"; homePageUrl = \"http://fm.qq.com\"; } else { if (location.href.indexOf(\"qzone.qq.com\") > -1) { homePageName = \"\\u8fd4\\u56de\\u6211\\u7684\\u7a7a\\u95f4\"; homePageUrl = \"http://qzone.qq.com\"; } else { homePageName = \"\\u8fd4\\u56de\\u817e\\u8baf\\u7f51\"; homePageUrl = \"http://www.qq.com\"; } } for (var i = 0;i < scs.length;i++) { if (scs[i].src.indexOf(\"404/search_children.js\") > -1) { if (scs[i].getAttribute(\"homePageUrl\")) { homePageUrl = scs[i].getAttribute(\"homePageUrl\"); } if (scs[i].getAttribute(\"homePageName\")) { homePageName = scs[i].getAttribute(\"homePageName\"); } break; } } $scope.rettext = homePageName; $scope.retlink = homePageUrl; function getData(srcUrl, callback) { var sc = _d.createElement(\"script\"); function orc() { if (sc.readyState === \"loaded\") { setTimeout(function() { callback && callback(); }, 0); } } if (sc.addEventListener) { if (callback) { sc.addEventListener(\"load\", callback, false); } } else { sc.attachEvent(\"onreadystatechange\", orc); } ha && ha.appendChild(sc); sc.src = srcUrl; } function resolveData(d) { var tid, len, ddata = [], tdata; if (\"object\" == typeof d && (d.data && (len = d.data.length))) { for (var i = 0;i < len;i++) { var expire = d.data[i].expire; d.data[i]._id = new Date * Math.random() * Math.random() * 1E7; if (expire && tmnow * 1E3 < Date.parse(expire.replace(/\\s[\\s\\S]*$/, \"\").replace(/\\-/g, \"/\"))) { var _c = d.data[i].city, _p = d.data[i].province; if (_c && city) { if ((\"_\" + _c + \"_\").indexOf(\"_\" + city + \"_\") > -1) { ddata.push(d.data[i]); continue; } } if (_p && province) { if ((\"_\" + _p + \"_\").indexOf(\"_\" + province + \"_\") > -1) { ddata.push(d.data[i]); } } } } tid = Math.floor(Math.random() * (ddata.length || len)); tdata = (ddata.length ? ddata : d.data)[chId = tid]; if (_w.foundjsondata) { tdata.ta = tdata.sex.indexOf(\"\\u5973\") > -1 ? \"\\u5979\" : \"\\u4ed6\"; tdata.name = \"\\u201c7\\u00b718\\u7279\\u5927\\u62d0\\u5356\\u5a74\\u513f\\u6848\\u201d\\u544a\\u7834\\uff0c\\u88ab\\u89e3\\u6551\\u768415\\u540d\\u5b69\\u5b50\\u4e2d\\uff0c2\\u4eba\\u7531\\u4eb2\\u751f\\u7236\\u6bcd\\u9886\\u56de\\uff0c\\u4ecd\\u670913\\u540d\\u5b69\\u5b50\\u672a\\u627e\\u5230\\u4eb2\\u751f\\u7236\\u6bcd\\uff0c\\u88ab\\u5b89\\u7f6e\\u5728\\u60e0\\u5dde\\u5e02\\u793e\\u4f1a\\u798f\\u5229\\u9662\\uff0c\" + tdata.ta + \"\\u662f\\u5176\\u4e2d\\u4e4b\\u4e00\\u3002\"; tdata.url = tdata.url.replace(/#p=(\\d{1,2})/, function(a, n) { return \"#p=\" + (+n + 1); }); return format(tmpl2, tdata); } if (!tdata.ext1) { tdata.ext1 = \"\\u4f46\\u6211\\u4eec\\u53ef\\u4ee5\\u4e00\\u8d77\\u5bfb\\u627e\\u5931\\u8e2a\\u5b9d\\u8d1d\"; } return tdata; } } function setTopData(tdata) { current = tdata; $scope.topname = tdata.name; $scope.topgender = tdata.sex; $scope.topbirth = tdata.birth_time; $scope.toplostdate = tdata.lost_time; $scope.toplostplace = tdata.lost_place; $scope.toplostdesc = tdata.child_feature; $scope.toplink = tdata.url; $scope.topimg = tdata.child_pic; $scope.topid = tdata._id; document.body.innerHTML = template(\"body\", $scope); } function init(data) { tmnow = data.tm_now * 1E3; var tdata = resolveData(jsondata); $scope.whichin = 0; jsondata.data.splice(chId, 1); $scope.otherdata = [tdata].concat(jsondata.data.slice(0, 5)); setTopData(tdata); } var timeout; window._Callback = function(d) { clearTimeout(timeout); init(d); }; timeout = setTimeout(function() { _Callback({tm_now:(new Date).getTime() / 1E3}); }, 2E3); _w.share = function(target) { var summary = [\"\\u80cc\\u666f\\uff1a\", current.name, \"\\uff0c\\u6027\\u522b\\uff1a\", current.sex, \"\\uff0c\\u51fa\\u751f\\u65f6\\u95f4\\uff1a\", current.birth_time, \"\\uff0c\\u5931\\u8e2a\\u65f6\\u95f4\\uff1a\", current.lost_time, \"\\uff0c\\u7279\\u5f81\\u63cf\\u8ff0\\uff1a\", current.child_feature].join(\"\"); if (summary) { summary = \"#\\u5bfb\\u627e\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d#\" + summary; } var stitle = \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8be6\\u60c5\"; var desc = \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\"; var encode = encodeURIComponent; var opts = {\"surl\":\"http://qzone.qq.com/gy/404/\" + current.id + \"/lostchild.html\", \"site\":\"QQ\\u7a7a\\u95f4\", \"summary\":summary || \"#\\u5b9d\\u8d1d\\u56de\\u5bb6#\\u817e\\u8baf\\u5fd7\\u613f\\u8005\\u7528\\u6280\\u672f\\u70b9\\u4eae\\u516c\\u76ca\\uff0c\\u8ba9\\u6211\\u4eec\\u4e00\\u8d77\\u5bfb\\u627e\\u8d70\\u5931\\u7684\\u513f\\u7ae5\\u5427\\uff01\", \"stitle\":stitle, \"pics\":current.child_pic, \"desc\":desc, \"origin_url\":current.url}; var surl = opts.surl || \"http://www.qq.com/404/\", summary = opts.summary || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u7684\\u5185\\u5bb9\", stitle = opts.stitle || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u7684\\u6807\\u9898\", pics = opts.pics || \"http://qzonestyle.gtimg.cn/qzone_v6/act/img/20120422_qzone_7_years/pop_up/icon-pop-seven-years.png\", site = opts.site || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u94fe\\u63a5\\u7684\\u6587\\u5b57\", desc = opts.desc || \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\", origin_url = opts.origin_url || \"http://www.qq.com/404/\"; var shareList = {weibo:{method:function(evt) { var w = \"http://v.t.qq.com/share/share.php\", q = [\"?site=\", encode(surl + \"#via=share_t_weib\"), \"&title=\", encode(summary), \"&pic=\", encode(pics), \"&url=\", encode(surl)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"weibo\", \"width=700, height=680, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, location=yes, resizable=no, status=no\"); }}, qzone:{method:function(evt) { var buff = [], ps = {url:surl + \"#via=404-qzoneshare\", desc:desc || \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\", summary:summary, title:stitle, pics:pics, site:site}; for (var k in ps) { buff.push(k + \"=\" + encode(ps[k] || \"\")); } var w = \"http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?\" + buff.join(\"&\"), q = [\"#via=share_t_qzone\", \"&title=\", encode(summary), \"&pic=\", encode(pics), \"&url=\", encode(surl)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"qzone\", \"width=700, height=680, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, location=yes, resizable=no, status=no\"); }}, sina:{method:function() { var w = \"http://v.t.sina.com.cn/share/share.php\", q = [\"?url=\", encode(surl + \"#via=share_x_weib\"), \"&title=\", encode(summary), \"&source=\", \"&sourceUrl=\", surl, \"&content=utf-8\", \"&pic=\", encode(pics)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"sina\", \"toolbar=0,status=0,resizable=1,width=440,height=430\"); }}, kaixin:{method:function() { var n = \"http://www.kaixin001.com/repaste/bshare.php?rurl=\" + encode(surl + \"#via=share_kaixin\") + \"&rcontent=&rtitle=\" + encode(summary); openit(n, \"kaixin\", \"toolbar=0,status=0,resizable=1,width=600,height=360\"); }}, renren:{method:function() { var n = \"http://www.connect.renren.com/share/sharer?title=\" + encode(summary) + \"&url=\" + encode(surl + \"#via=share_renren\"), p = window.open(n, \"rr\", \"toolbar=0,status=0,resizable=1,width=510,height=300\"); if (p) { p.focus(); } }}, weixin:{method:function() { var n = \"http://qzone.qq.com/gy/404/page/qrcode.html?url=\" + encode(origin_url + \"#via=share_weixin\"), p = window.open(n, \"rr\", \"toolbar=0,status=0,resizable=1,width=620,height=430\"); if (p) { p.focus(); } }}}; var openit = function(u, n, p) { function o() { var z; if (!(z = window.open(u, n, p))) { location.href = u; } else { z.focus(); } } o(); }; shareList[target] && shareList[target].method(); }; _w.toThis = function(id) { for (var i = 0;i < $scope.otherdata.length;i++) { if ($scope.otherdata[i]._id == id) { setTopData($scope.otherdata[i]); break; } } return false; }; var meta = document.createElement(\"meta\"); meta.name = \"viewport\"; meta.content = \"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"; ha.appendChild(meta); (function registerStyle() { var link = document.createElement(\"link\"); link.rel = \"stylesheet\"; link.type = \"text/css\"; link.href = \"https://qzone.qq.com/gy/404/style/404style.css\"; ha.appendChild(link); })(); (function initStat() { var qqDomainNameRE = /\\.qq\\.com$/i, qzoneDomainNameRE = /\\bqzone\\.qq\\.com$/i, qzsDomainNameRE = /\\bqzonestyle\\.gtimg\\.cn$/i; function cb() { var url = location.host; var src = \"\"; if (qzoneDomainNameRE.test(url)) { src = \"new404.qzone\"; } else { if (qqDomainNameRE.test(url)) { src = \"new404.qq\"; } else { if (qzsDomainNameRE.test(url)) { src = \"new404.qzonestyle\"; } else { src = url.replace(\".\", \"_\"); } } } _w.TCISD && (_w.TCISD.pv && _w.TCISD.pv(\"hat.qzone.qq.com\", \"/gy/lostchild/\" + src)); } getData(\"https://qzonestyle.gtimg.cn/ac/qzfl/stat.js\", cb); })(); })(window, document); !function() { function a(a, b) { return(/string|function/.test(typeof b) ? h : g)(a, b); } function b(a, c) { return \"string\" != typeof a && (c = typeof a, \"number\" === c ? a += \"\" : a = \"function\" === c ? b(a.call(a)) : \"\"), a; } function c(a) { return l[a]; } function d(a) { return b(a).replace(/&(?![\\w#]+;)|[\"']/g, c); } function e(a, b) { if (m(a)) { for (var c = 0, d = a.length;d > c;c++) { b.call(a, a[c], c, a); } } else { for (c in a) { b.call(a, a[c], c); } } } function f(a, b) { var c = /(\\/)[^/]+\\1\\.\\.\\1/, d = (\"./\" + a).replace(/[^/]+$/, \"\"), e = d + b; for (e = e.replace(/\\/\\.\\//g, \"/\");e.match(c);) { e = e.replace(c, \"/\"); } return e; } function g(b, c) { var d = a.get(b) || i({filename:b, name:\"Render Error\", message:\"Template not found\"}); return c ? d(c) : d; } function h(a, b) { if (\"string\" == typeof b) { var c = b; b = function() { return new k(c); }; } var d = j[a] = function(c) { try { return new b(c, a) + \"\"; } catch (d) { return i(d)(); } }; return d.prototype = b.prototype = n, d.toString = function() { return b + \"\"; }, d; } function i(a) { var b = \"{Template Error}\", c = a.stack || \"\"; if (c) { c = c.split(\"\\n\").slice(0, 2).join(\"\\n\"); } else { for (var d in a) { c += \"\\n\" + a[d] + \"\\n\\n\"; } } return function() { return \"object\" == typeof console && console.error(b + \"\\n\\n\" + c), b; }; } var j = a.cache = {}, k = this.String, l = {\"\":\"&#62;\", '\"':\"&#34;\", \"'\":\"&#39;\", \"&\":\"&#38;\"}, m = Array.isArray || function(a) { return \"[object Array]\" === {}.toString.call(a); }, n = a.utils = {$helpers:{}, $include:function(a, b, c) { return a = f(c, a), g(a, b); }, $string:b, $escape:d, $each:e}, o = a.helpers = n.$helpers; a.get = function(a) { return j[a.replace(/^\\.\\//, \"\")]; }, a.helper = function(a, b) { o[a] = b; }, \"function\" == typeof define ? define(function() { return a; }) : \"undefined\" != typeof exports ? module.exports = a : this.template = a, a(\"body\", function(a) { var b = this, c = (b.$helpers, b.$escape), d = a.retlink, e = a.rettext, f = a.topid, g = a.topimg, h = a.topname, i = a.topgender, j = a.topbirth, l = a.toplostdate, m = a.toplostplace, n = a.toplostdesc, o = a.toplink, p = b.$each, q = a.otherdata, r = (a.otheritem, a.index, \"\"); return r += ' 404\\uff0c\\u60a8\\u8bbf\\u95ee\\u7684\\u9875\\u9762\\u627e\\u4e0d\\u56de\\u6765\\u4e86\\uff0c\\u4f46\\u6211\\u4eec\\u53ef\\u4ee5\\u4e00\\u8d77\\u5e2e\\u4ed6\\u4eec\\u56de\\u5bb6\\uff01 ', r += c(e), r += ' ', r += c(h), r += '(', r += c(i), r += ') \\u51fa\\u751f\\u65e5\\u671f\\uff1a', r += c(j), r += ' \\u5931\\u8e2a\\u65f6\\u95f4\\uff1a', r += c(l), r += ' \\u5931\\u8e2a\\u5730\\u70b9\\uff1a', r += c(m), r += ' \\u5931\\u8e2a\\u4eba\\u7279\\u5f81\\u63cf\\u8ff0\\uff1a', r += c(n), r += ' \\u67e5\\u770b\\u8be6\\u60c5 \\u5206\\u4eab \\u817e\\u8baf\\u5fae\\u535a QQ\\u7a7a\\u95f4 \\u65b0\\u6d6a\\u5fae\\u535a \\u5fae\\u4fe1 ', p(q, function(a) { r += ' '; }), r += \" \", new k(r); }); }(); L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"debug\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/hijiki.model.json\"},\"display\":{\"position\":\"right\",\"width\":150,\"height\":300},\"mobile\":{\"show\":true},\"react\":{\"opacity\":0.7},\"log\":false});"},{"title":"关于我","date":"2019-04-19T08:40:39.000Z","updated":"2019-04-23T16:24:49.036Z","comments":true,"path":"about/index.html","permalink":"https://bigporo.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-22T01:59:17.000Z","updated":"2019-04-23T16:27:49.760Z","comments":true,"path":"categories/index.html","permalink":"https://bigporo.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-22T01:58:24.000Z","updated":"2019-04-23T16:18:38.800Z","comments":true,"path":"tags/index.html","permalink":"https://bigporo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Runtime应用篇","slug":"Runtime应用篇","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T08:47:58.657Z","comments":true,"path":"2019/04/23/Runtime应用篇/","link":"","permalink":"https://bigporo.github.io/2019/04/23/Runtime应用篇/","excerpt":"","text":"前言Runtime简直就是做大型框架的利器。它的应用场景非常多，下面就介绍一些常见的应用场景。 关联对象(Objective-C Associated Objects)给分类增加属性 方法魔法(Method Swizzling)方法添加和替换和KVO实现 消息转发(热更新)解决Bug(JSPatch) 实现NSCoding的自动归档和自动解档 实现字典和模型的自动转换(MJExtension) 关联对象(Objective-C Associated Objects)我们都是知道分类是不能自定义属性和变量的。如果在分类的声明中写@property 只能为其生成get 和 set 方法的声明，但无法生成成员变量，就是虽然点语法能调用出来，但程序执行后会crash。 下面通过关联对象实现给分类添加属性。 关联对象Runtime提供了下面几个接口： 123456//关联对象void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)//获取关联的对象id objc_getAssociatedObject(id object, const void *key)//移除关联的对象void objc_removeAssociatedObjects(id object) 参数解释 1234id object：被关联的对象const void *key：关联的key，要求唯一id value：关联的对象objc_AssociationPolicy policy：内存管理的策略 通过关联对象实现的属性的内存管理也是有ARC管理的，所以我们只需要给定适当的内存策略就行了，不需要操心对象的释放。 内存管理策略 内存策略 属性修饰 描述 OBJC_ASSOCIATION_ASSIGN @property (assign) 或 @property (unsafe_unretained) 指定一个关联对象的弱引用。 OBJC_ASSOCIATION_RETAIN_NONATOMIC @property (nonatomic, strong) 指定一个关联对象的强引用，不能被原子化使用。 OBJC_ASSOCIATION_COPY_NONATOMIC @property (nonatomic, copy) 指定一个关联对象的copy引用，不能被原子化使用 OBJC_ASSOCIATION_RETAIN @property (atomic, strong) 指定一个关联对象的强引用，能被原子化使用。 OBJC_ASSOCIATION_COPY @property (atomic, copy) 指定一个关联对象的copy引用，能被原子化使用。 下面实现一个UIView的Category添加自定义属性defaultColor。 1234567891011121314151617181920212223242526272829303132333435363738394041#import &quot;ViewController.h&quot;#import &quot;objc/runtime.h&quot;@interface UIView (DefaultColor)@property (nonatomic, strong) UIColor *defaultColor;@end@implementation UIView (DefaultColor)@dynamic defaultColor;static char kDefaultColorKey;- (void)setDefaultColor:(UIColor *)defaultColor &#123;objc_setAssociatedObject(self, &amp;kDefaultColorKey, defaultColor, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (id)defaultColor &#123;return objc_getAssociatedObject(self, &amp;kDefaultColorKey);&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.UIView *test = [UIView new];test.defaultColor = [UIColor blackColor];NSLog(@&quot;%@&quot;, test.defaultColor);&#125;@end 方法魔法(Method Swizzling)方法添加12//class_addMethod(Class _Nullable __unsafe_unretained cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)class_addMethod([self class], sel, (IMP)fooMethod, &quot;v@:&quot;); 参数解释 cls 被添加方法的类 name 添加的方法的名称的SEL imp 方法的实现。该函数必须至少要有两个参数，self,_cmd 类型编码 方法替换12345678// 获得某个类的类方法Method class_getClassMethod(Class cls , SEL name)// 获得某个类的实例对象方法Method class_getInstanceMethod(Class cls , SEL name)// 交换两个方法的实现void method_exchangeImplementations(Method m1 , Method m2) 示例如下:1234567891011121314151617181920212223242526272829303132333435@implementation ViewController+ (void)load &#123;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;Class class = [self class];SEL originalSelector = @selector(viewDidLoad);SEL swizzledSelector = @selector(jkviewDidLoad);Method originalMethod = class_getInstanceMethod(class,originalSelector);Method swizzledMethod = class_getInstanceMethod(class,swizzledSelector);//judge the method named swizzledMethod is already existed.BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));// if swizzledMethod is already existed.if (didAddMethod) &#123;class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));&#125;else &#123;method_exchangeImplementations(originalMethod, swizzledMethod);&#125;&#125;);&#125;- (void)jkviewDidLoad &#123;NSLog(@&quot;替换的方法&quot;);[self jkviewDidLoad];&#125;- (void)viewDidLoad &#123;NSLog(@&quot;自带的方法&quot;);[super viewDidLoad];&#125; 在 Objective-C 的运行时中，每个类有两个方法都会自动调用。+load 是在一个类被初始装载时调用，+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。 实现图解如下图。 从图中可以看出，我们通过swizzling特性，将selectorC的方法实现IMPc与selectorN的方法实现IMPn交换了，当我们调用selectorC，也就是给对象发送selectorC消息时，所查找到的对应的方法实现就是IMPn而不是IMPc了。 KVO实现质量博客解读 全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。在MVC大行其道的Cocoa中，KVO机制很适合实现model和controller类之间的通讯。 KVO的实现依赖于 Objective-C 强大的 Runtime，当观察某对象 A 时，KVO 机制动态创建一个对象A当前类的子类，并为这个新的子类重写了被观察属性 keyPath 的 setter 方法。setter 方法随后负责通知观察对象属性的改变状况。 Apple 使用了 isa-swizzling 来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为：NSKVONotifying_A的新类，该类继承自对象A的本类，且 KVO 为 NSKVONotifying_A 重写观察属性的 setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。 所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对 KVO 的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类，就会发现系统运行到注册 KVO 的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为 NSKVONotifying_A 的中间类，并指向这个中间类了。 子类setter方法剖析 KVO 的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangeValueForKey: ，在存取数值的前后分别调用 2 个方法：被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该keyPath 的属性值已经变更；之后， observeValueForKey:ofObject:change:context:也会被调用。且重写观察属性的setter 方法这种继承方式的注入是在运行时而不是编译时实现的。KVO 为子类的观察者属性重写调用存取方法的工作原理在代码中相当于： 12345- (void)setName:(NSString *)newName &#123; [self willChangeValueForKey:@&quot;name&quot;]; //KVO 在调用存取方法之前总调用 [super setValue:newName forKey:@&quot;name&quot;]; //调用父类的存取方法 [self didChangeValueForKey:@&quot;name&quot;]; //KVO 在调用存取方法之后总调用&#125; 示例如下： 123456789101112131415161718- (void)dealloc&#123;[self.person removeObserver:self forKeyPath:@&quot;name&quot;];&#125;- (void)viewDidLoad &#123;[super viewDidLoad];self.person = [Person new];[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:@&quot;传个值？&quot;];&#125;#pragma mark KVO- (void)KVO&#123;self.person.name = @&quot;new name&quot;;&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;NSLog(@&quot;%@对象的%@属性改变了：%@,传值:%@&quot;, object, keyPath, change,context);&#125; 输出如下 1234&lt;Person: 0x600000907280&gt;对象的name属性改变了：&#123;kind = 1;new = &quot;new name&quot;;&#125;,传值:传个值？ 消息转发(热更新)解决Bug(JSPatch) JSPatch 是一个 iOS 动态更新框架，只需在项目中引入极小的引擎，就可以使用 JavaScript 调用任何 Objective-C 原生接口，获得脚本语言的优势：为项目动态添加模块，或替换项目原生代码动态修复 bug。 消息转发分为三级，我们可以在每级实现替换功能，实现消息转发，从而不会造成崩溃。JSPatch不仅能够实现消息转发，还可以实现方法添加、替换能一系列功能。 获得一个类的所有成员变量用runtime提供的函数遍历Model自身所有属性。 12345678910111213unsigned int outCount = 0;Ivar *ivars = class_copyIvarList([Person class], &amp;outCount);// 遍历所有成员变量for (int i = 0; i &lt; outCount; i++) &#123;// 取出i位置对应的成员变量Ivar ivar = ivars[i];const char *name = ivar_getName(ivar);const char *type = ivar_getTypeEncoding(ivar);NSLog(@&quot;成员变量名：%s 成员变量类型：%s&quot;,name,type);&#125;// 注意释放内存！free(ivars); 实现NSCoding的自动归档和自动解档原理描述：用runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。 核心方法：在Model的基类中重写方法： 12345678910111213141516171819202122- (id)initWithCoder:(NSCoder *)aDecoder &#123;if (self = [super init]) &#123;unsigned int outCount;Ivar * ivars = class_copyIvarList([self class], &amp;outCount);for (int i = 0; i &lt; outCount; i ++) &#123;Ivar ivar = ivars[i];NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];[self setValue:[aDecoder decodeObjectForKey:key] forKey:key];&#125;&#125;return self;&#125;- (void)encodeWithCoder:(NSCoder *)aCoder &#123;unsigned int outCount;Ivar * ivars = class_copyIvarList([self class], &amp;outCount);for (int i = 0; i &lt; outCount; i ++) &#123;Ivar ivar = ivars[i];NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];[aCoder encodeObject:[self valueForKey:key] forKey:key];&#125;&#125; 实现字典和模型的自动转换(MJExtension)原理描述：用runtime提供的函数遍历Model自身所有属性，如果属性在json中有对应的值，则将其赋值。核心方法：在NSObject的分类中添加方法12345678910111213141516171819202122232425262728293031323334- (instancetype)initWithDict:(NSDictionary *)dict &#123;if (self = [self init]) &#123;//(1)获取类的属性及属性对应的类型NSMutableArray * keys = [NSMutableArray array];NSMutableArray * attributes = [NSMutableArray array];/** 例子* name = value3 attribute = T@&quot;NSString&quot;,C,N,V_value3* name = value4 attribute = T^i,N,V_value4*/unsigned int outCount;objc_property_t * properties = class_copyPropertyList([self class], &amp;outCount);for (int i = 0; i &lt; outCount; i ++) &#123;objc_property_t property = properties[i];//通过property_getName函数获得属性的名字NSString * propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding];[keys addObject:propertyName];//通过property_getAttributes函数可以获得属性的名字和@encode编码NSString * propertyAttribute = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding];[attributes addObject:propertyAttribute];&#125;//立即释放properties指向的内存free(properties);//(2)根据类型给属性赋值for (NSString * key in keys) &#123;if ([dict valueForKey:key] == nil) continue;[self setValue:[dict valueForKey:key] forKey:key];&#125;&#125;return self;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"}]},{"title":"iOS各种设备信息获取总结","slug":"iOS各种设备信息获取总结","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T08:54:18.440Z","comments":true,"path":"2019/04/23/iOS各种设备信息获取总结/","link":"","permalink":"https://bigporo.github.io/2019/04/23/iOS各种设备信息获取总结/","excerpt":"","text":"为了统计用户信息、下发广告，服务器端往往需要手机用户设备及app的各种信息，下面讲述一下各种信息的获取方式： 直接上代码:1234567891011121314151617181920212223242526272829303132333435363738// 这个方法后面会列出来NSString *deviceName = [self getDeviceName];NSLog(@&quot;设备型号--&gt;%@&quot;, deviceName);NSString *iPhoneName = [UIDevice currentDevice].name;NSLog(@&quot;iPhone名称--&gt;%@&quot;, iPhoneName); NSString *appVerion = [[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleShortVersionString&quot;];NSLog(@&quot;app版本号--&gt;%@&quot;, appVerion);CGFloat batteryLevel = [[UIDevice currentDevice] batteryLevel];NSLog(@&quot;电池电量--&gt;%f&quot;, batteryLevel);NSString *localizedModel = [UIDevice currentDevice].localizedModel;NSLog(@&quot;localizedModel--&gt;%@&quot;, localizedModel);NSString *systemName = [UIDevice currentDevice].systemName;NSLog(@&quot;当前系统名称--&gt;%@&quot;, systemName);NSString *systemVersion = [UIDevice currentDevice].systemVersion;NSLog(@&quot;当前系统版本号--&gt;%@&quot;, systemVersion);struct utsname systemInfo;uname(&amp;systemInfo);NSString *device_model = [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];NSLog(@&quot;device_model--&gt;%@&quot;, device_model);// 这个方法后面会单独列出NSString *macAddress = [self getMacAddress];NSLog(@&quot;macAddress--&gt;%@&quot;, macAddress);// 这个方法后面会单独列出NSString *deviceIP = [self getDeviceIPAddresses];NSLog(@&quot;deviceIP--&gt;%@&quot;, deviceIP);// 设备上次重启的时间NSTimeInterval time = [[NSProcessInfo processInfo] systemUptime];NSDate *lastRestartDate = [[NSDate alloc] initWithTimeIntervalSinceNow:(0 - time)]; 广告位标识符在同一个设备上的所有App都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设的，用户可以在 设置|隐私|广告追踪里重置此id的值，或限制此id的使用，故此id有可能会取不到值，但好在Apple默认是允许追踪的，而且一般用户都不知道有这么个设置，所以基本上用来监测推广效果，是戳戳有余了。12NSString *idfa = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];NSLog(@&quot;广告位标识符idfa--&gt;%@&quot;, idfa); UUID是Universally Unique Identifier的缩写，中文意思是通用唯一识别码。它是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指 定。这样，每个人都可以建立不与其它人冲突的 UUID。在此情况下，就不需考虑数据库建立时的名称重复问题。苹果公司建议使用UUID为应用生成唯一标识字符串。 12NSString *uuid = [[[UIDevice currentDevice] identifierForVendor] UUIDString];NSLog(@&quot;唯一识别码uuid--&gt;%@&quot;, uuid); 获取设备型号123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 需要#import &quot;sys/utsname.h&quot;#warning 题主呕心沥血总结！！最全面！亲测！全网独此一份！！struct utsname systemInfo;uname(&amp;systemInfo);NSString *deviceString = [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];if ([deviceString isEqualToString:@&quot;iPhone3,1&quot;]) return @&quot;iPhone 4&quot;;if ([deviceString isEqualToString:@&quot;iPhone3,2&quot;]) return @&quot;iPhone 4&quot;;if ([deviceString isEqualToString:@&quot;iPhone3,3&quot;]) return @&quot;iPhone 4&quot;;if ([deviceString isEqualToString:@&quot;iPhone4,1&quot;]) return @&quot;iPhone 4S&quot;;if ([deviceString isEqualToString:@&quot;iPhone5,1&quot;]) return @&quot;iPhone 5&quot;;if ([deviceString isEqualToString:@&quot;iPhone5,2&quot;]) return @&quot;iPhone 5 (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPhone5,3&quot;]) return @&quot;iPhone 5c (GSM)&quot;;if ([deviceString isEqualToString:@&quot;iPhone5,4&quot;]) return @&quot;iPhone 5c (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPhone6,1&quot;]) return @&quot;iPhone 5s (GSM)&quot;;if ([deviceString isEqualToString:@&quot;iPhone6,2&quot;]) return @&quot;iPhone 5s (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPhone7,1&quot;]) return @&quot;iPhone 6 Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone7,2&quot;]) return @&quot;iPhone 6&quot;;if ([deviceString isEqualToString:@&quot;iPhone8,1&quot;]) return @&quot;iPhone 6s&quot;;if ([deviceString isEqualToString:@&quot;iPhone8,2&quot;]) return @&quot;iPhone 6s Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone8,4&quot;]) return @&quot;iPhone SE&quot;;// 日行两款手机型号均为日本独占，可能使用索尼FeliCa支付方案而不是苹果支付if ([deviceString isEqualToString:@&quot;iPhone9,1&quot;]) return @&quot;国行、日版、港行iPhone 7&quot;;if ([deviceString isEqualToString:@&quot;iPhone9,2&quot;]) return @&quot;港行、国行iPhone 7 Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone9,3&quot;]) return @&quot;美版、台版iPhone 7&quot;;if ([deviceString isEqualToString:@&quot;iPhone9,4&quot;]) return @&quot;美版、台版iPhone 7 Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,1&quot;]) return @&quot;国行(A1863)、日行(A1906)iPhone 8&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,4&quot;]) return @&quot;美版(Global/A1905)iPhone 8&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,2&quot;]) return @&quot;国行(A1864)、日行(A1898)iPhone 8 Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,5&quot;]) return @&quot;美版(Global/A1897)iPhone 8 Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,3&quot;]) return @&quot;国行(A1865)、日行(A1902)iPhone X&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,6&quot;]) return @&quot;美版(Global/A1901)iPhone X&quot;;if ([deviceString isEqualToString:@&quot;iPhone11,2&quot;]) return @&quot;iPhone XS&quot;;if ([deviceString isEqualToString:@&quot;iPhone11,4&quot;]) return @&quot;iPhone XS Max&quot;;if ([deviceString isEqualToString:@&quot;iPhone11,6&quot;]) return @&quot;iPhone XS Max&quot;;if ([deviceString isEqualToString:@&quot;iPhone11,8&quot;]) return @&quot;iPhone XR&quot;;if ([deviceString isEqualToString:@&quot;iPod1,1&quot;]) return @&quot;iPod Touch 1G&quot;;if ([deviceString isEqualToString:@&quot;iPod2,1&quot;]) return @&quot;iPod Touch 2G&quot;;if ([deviceString isEqualToString:@&quot;iPod3,1&quot;]) return @&quot;iPod Touch 3G&quot;;if ([deviceString isEqualToString:@&quot;iPod4,1&quot;]) return @&quot;iPod Touch 4G&quot;;if ([deviceString isEqualToString:@&quot;iPod5,1&quot;]) return @&quot;iPod Touch (5 Gen)&quot;;if ([deviceString isEqualToString:@&quot;iPad1,1&quot;]) return @&quot;iPad&quot;;if ([deviceString isEqualToString:@&quot;iPad1,2&quot;]) return @&quot;iPad 3G&quot;;if ([deviceString isEqualToString:@&quot;iPad2,1&quot;]) return @&quot;iPad 2 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad2,2&quot;]) return @&quot;iPad 2&quot;;if ([deviceString isEqualToString:@&quot;iPad2,3&quot;]) return @&quot;iPad 2 (CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPad2,4&quot;]) return @&quot;iPad 2&quot;;if ([deviceString isEqualToString:@&quot;iPad2,5&quot;]) return @&quot;iPad Mini (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad2,6&quot;]) return @&quot;iPad Mini&quot;;if ([deviceString isEqualToString:@&quot;iPad2,7&quot;]) return @&quot;iPad Mini (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPad3,1&quot;]) return @&quot;iPad 3 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad3,2&quot;]) return @&quot;iPad 3 (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPad3,3&quot;]) return @&quot;iPad 3&quot;;if ([deviceString isEqualToString:@&quot;iPad3,4&quot;]) return @&quot;iPad 4 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad3,5&quot;]) return @&quot;iPad 4&quot;;if ([deviceString isEqualToString:@&quot;iPad3,6&quot;]) return @&quot;iPad 4 (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,1&quot;]) return @&quot;iPad Air (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,2&quot;]) return @&quot;iPad Air (Cellular)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,4&quot;]) return @&quot;iPad Mini 2 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,5&quot;]) return @&quot;iPad Mini 2 (Cellular)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,6&quot;]) return @&quot;iPad Mini 2&quot;;if ([deviceString isEqualToString:@&quot;iPad4,7&quot;]) return @&quot;iPad Mini 3&quot;;if ([deviceString isEqualToString:@&quot;iPad4,8&quot;]) return @&quot;iPad Mini 3&quot;;if ([deviceString isEqualToString:@&quot;iPad4,9&quot;]) return @&quot;iPad Mini 3&quot;;if ([deviceString isEqualToString:@&quot;iPad5,1&quot;]) return @&quot;iPad Mini 4 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad5,2&quot;]) return @&quot;iPad Mini 4 (LTE)&quot;;if ([deviceString isEqualToString:@&quot;iPad5,3&quot;]) return @&quot;iPad Air 2&quot;;if ([deviceString isEqualToString:@&quot;iPad5,4&quot;]) return @&quot;iPad Air 2&quot;;if ([deviceString isEqualToString:@&quot;iPad6,3&quot;]) return @&quot;iPad Pro 9.7&quot;;if ([deviceString isEqualToString:@&quot;iPad6,4&quot;]) return @&quot;iPad Pro 9.7&quot;;if ([deviceString isEqualToString:@&quot;iPad6,7&quot;]) return @&quot;iPad Pro 12.9&quot;;if ([deviceString isEqualToString:@&quot;iPad6,8&quot;]) return @&quot;iPad Pro 12.9&quot;;if ([deviceString isEqualToString:@&quot;iPad6,11&quot;]) return @&quot;iPad 5 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad6,12&quot;]) return @&quot;iPad 5 (Cellular)&quot;;if ([deviceString isEqualToString:@&quot;iPad7,1&quot;]) return @&quot;iPad Pro 12.9 inch 2nd gen (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad7,2&quot;]) return @&quot;iPad Pro 12.9 inch 2nd gen (Cellular)&quot;;if ([deviceString isEqualToString:@&quot;iPad7,3&quot;]) return @&quot;iPad Pro 10.5 inch (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad7,4&quot;]) return @&quot;iPad Pro 10.5 inch (Cellular)&quot;;if ([deviceString isEqualToString:@&quot;iPad7,5&quot;]) return @&quot;iPad 6th generation&quot;;if ([deviceString isEqualToString:@&quot;iPad7,6&quot;]) return @&quot;iPad 6th generation&quot;;if ([deviceString isEqualToString:@&quot;iPad8,1&quot;]) return @&quot;iPad Pro (11-inch)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,2&quot;]) return @&quot;iPad Pro (11-inch)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,3&quot;]) return @&quot;iPad Pro (11-inch)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,4&quot;]) return @&quot;iPad Pro (11-inch)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,5&quot;]) return @&quot;iPad Pro (12.9-inch) (3rd generation)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,6&quot;]) return @&quot;iPad Pro (12.9-inch) (3rd generation)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,7&quot;]) return @&quot;iPad Pro (12.9-inch) (3rd generation)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,8&quot;]) return @&quot;iPad Pro (12.9-inch) (3rd generation)&quot;;if ([deviceString isEqualToString:@&quot;AppleTV2,1&quot;]) return @&quot;Apple TV 2&quot;;if ([deviceString isEqualToString:@&quot;AppleTV3,1&quot;]) return @&quot;Apple TV 3&quot;;if ([deviceString isEqualToString:@&quot;AppleTV3,2&quot;]) return @&quot;Apple TV 3&quot;;if ([deviceString isEqualToString:@&quot;AppleTV5,3&quot;]) return @&quot;Apple TV 4&quot;;if ([deviceString isEqualToString:@&quot;i386&quot;]) return @&quot;Simulator&quot;;if ([deviceString isEqualToString:@&quot;x86_64&quot;]) return @&quot;Simulator&quot;;return deviceString;&#125; 获取 iPhone 设备颜色/外壳颜色12345678910111213141516#warning 该方法是私有API，上线会被拒// 由于每款手机同一颜色具体色号不一样，如 iPhone 6和 iPhone SE粉色的两个具体色值是不一样的，因此在这里只能返回一个色号UIDevice *device = [UIDevice currentDevice];SEL selector = NSSelectorFromString(@&quot;deviceInfoForKey:&quot;);if (![device respondsToSelector:selector]) &#123;selector = NSSelectorFromString(@&quot;_deviceInfoForKey:&quot;);&#125;if ([device respondsToSelector:selector]) &#123;// 消除警告“performSelector may cause a leak because its selector is unknown”IMP imp = [device methodForSelector:selector];NSString * (*func)(id, SEL, NSString *) = (void *)imp;NSString *deviceColor = func(device, selector, @&quot;DeviceColor&quot;);NSString *deviceEnclosureColor = func(device, selector, @&quot;DeviceEnclosureColor&quot;);NSLog(@&quot;deviceColor --&gt; %@ \\n @&quot;deviceEnclosureColor --&gt; %@ &quot;, deviceColor, deviceEnclosureColor);&#125; mac 地址12345678910111213141516171819202122232425262728293031323334353637383940414243- (NSString *)getMacAddress &#123;int mib[6];size_t len;char *buf;unsigned char *ptr;struct if_msghdr *ifm;struct sockaddr_dl *sdl;mib[0] = CTL_NET;mib[1] = AF_ROUTE;mib[2] = 0;mib[3] = AF_LINK;mib[4] = NET_RT_IFLIST;if ((mib[5] = if_nametoindex(&quot;en0&quot;)) == 0) &#123;printf(&quot;Error: if_nametoindex error/n&quot;);return NULL;&#125;if (sysctl(mib, 6, NULL, &amp;len, NULL, 0) &lt; 0) &#123;printf(&quot;Error: sysctl, take 1/n&quot;);return NULL;&#125;if ((buf = malloc(len)) == NULL) &#123;printf(&quot;Could not allocate memory. error!/n&quot;);return NULL;&#125;if (sysctl(mib, 6, buf, &amp;len, NULL, 0) &lt; 0) &#123;printf(&quot;Error: sysctl, take 2&quot;);return NULL;&#125;ifm = (struct if_msghdr *)buf;sdl = (struct sockaddr_dl *)(ifm + 1);ptr = (unsigned char *)LLADDR(sdl);NSString *outstring = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x&quot;, *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)];free(buf);return [outstring uppercaseString];&#125; IP地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354- (NSString *)getDeviceIPAddresses &#123;int sockfd = socket(AF_INET, SOCK_DGRAM, 0);NSMutableArray *ips = [NSMutableArray array];int BUFFERSIZE = 4096;struct ifconf ifc;char buffer[BUFFERSIZE], *ptr, lastname[IFNAMSIZ], *cptr;struct ifreq *ifr, ifrcopy;ifc.ifc_len = BUFFERSIZE;ifc.ifc_buf = buffer;if (ioctl(sockfd, SIOCGIFCONF, &amp;ifc) &gt;= 0)&#123;for (ptr = buffer; ptr &lt; buffer + ifc.ifc_len; )&#123;ifr = (struct ifreq *)ptr;int len = sizeof(struct sockaddr);if (ifr-&gt;ifr_addr.sa_len &gt; len) &#123;len = ifr-&gt;ifr_addr.sa_len;&#125;ptr += sizeof(ifr-&gt;ifr_name) + len;if (ifr-&gt;ifr_addr.sa_family != AF_INET) continue;if ((cptr = (char *)strchr(ifr-&gt;ifr_name, &apos;:&apos;)) != NULL) *cptr = 0;if (strncmp(lastname, ifr-&gt;ifr_name, IFNAMSIZ) == 0) continue;memcpy(lastname, ifr-&gt;ifr_name, IFNAMSIZ);ifrcopy = *ifr;ioctl(sockfd, SIOCGIFFLAGS, &amp;ifrcopy);if ((ifrcopy.ifr_flags &amp; IFF_UP) == 0) continue;NSString *ip = [NSString stringWithFormat:@&quot;%s&quot;, inet_ntoa(((struct sockaddr_in *)&amp;ifr-&gt;ifr_addr)-&gt;sin_addr)];[ips addObject:ip];&#125;&#125;close(sockfd);NSString *deviceIP = @&quot;&quot;;for (int i=0; i &lt; ips.count; i++) &#123;if (ips.count &gt; 0) &#123;deviceIP = [NSString stringWithFormat:@&quot;%@&quot;,ips.lastObject];&#125;&#125;return deviceIP;&#125; CPU12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// CPU总数目- (NSUInteger)getCPUCount &#123;return [NSProcessInfo processInfo].activeProcessorCount;&#125;// 已使用的CPU比例- (float)getCPUUsage &#123;float cpu = 0;NSArray *cpus = [self getPerCPUUsage];if (cpus.count == 0) return -1;for (NSNumber *n in cpus) &#123;cpu += n.floatValue;&#125;return cpu;&#125;// 获取每个cpu的使用比例- (NSArray *)getPerCPUUsage &#123;processor_info_array_t _cpuInfo, _prevCPUInfo = nil;mach_msg_type_number_t _numCPUInfo, _numPrevCPUInfo = 0;unsigned _numCPUs;NSLock *_cpuUsageLock;int _mib[2U] = &#123; CTL_HW, HW_NCPU &#125;;size_t _sizeOfNumCPUs = sizeof(_numCPUs);int _status = sysctl(_mib, 2U, &amp;_numCPUs, &amp;_sizeOfNumCPUs, NULL, 0U);if (_status)_numCPUs = 1;_cpuUsageLock = [[NSLock alloc] init];natural_t _numCPUsU = 0U;kern_return_t err = host_processor_info(mach_host_self(), PROCESSOR_CPU_LOAD_INFO, &amp;_numCPUsU, &amp;_cpuInfo, &amp;_numCPUInfo);if (err == KERN_SUCCESS) &#123;[_cpuUsageLock lock];NSMutableArray *cpus = [NSMutableArray new];for (unsigned i = 0U; i &lt; _numCPUs; ++i) &#123;Float32 _inUse, _total;if (_prevCPUInfo) &#123;_inUse = ((_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER])+ (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM])+ (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE]));_total = _inUse + (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE]);&#125; else &#123;_inUse = _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER] + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM] + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE];_total = _inUse + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE];&#125;[cpus addObject:@(_inUse / _total)];&#125;[_cpuUsageLock unlock];if (_prevCPUInfo) &#123;size_t prevCpuInfoSize = sizeof(integer_t) * _numPrevCPUInfo;vm_deallocate(mach_task_self(), (vm_address_t)_prevCPUInfo, prevCpuInfoSize);&#125;return cpus;&#125; else &#123;return nil;&#125;&#125; Disk磁盘空间123456789101112131415161718192021222324252627// 获取磁盘总空间- (int64_t)getTotalDiskSpace &#123;NSError *error = nil;NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&amp;error];if (error) return -1;int64_t space = [[attrs objectForKey:NSFileSystemSize] longLongValue];if (space &lt; 0) space = -1;return space;&#125;// 获取未使用的磁盘空间- (int64_t)getFreeDiskSpace &#123;NSError *error = nil;NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&amp;error];if (error) return -1;int64_t space = [[attrs objectForKey:NSFileSystemFreeSize] longLongValue];if (space &lt; 0) space = -1;return space;&#125;// 获取已使用的磁盘空间- (int64_t)getUsedDiskSpace &#123;int64_t totalDisk = [self getTotalDiskSpace];int64_t freeDisk = [self getFreeDiskSpace];if (totalDisk &lt; 0 || freeDisk &lt; 0) return -1;int64_t usedDisk = totalDisk - freeDisk;if (usedDisk &lt; 0) usedDisk = -1;return usedDisk;&#125; Memory内存相关数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 系统总内存空间- (int64_t)getTotalMemory &#123;int64_t totalMemory = [[NSProcessInfo processInfo] physicalMemory];if (totalMemory &lt; -1) totalMemory = -1;return totalMemory;&#125;// 活跃的内存,正在使用或者很短时间内被使用过- (int64_t)getActiveMemory &#123;mach_port_t host_port = mach_host_self();mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);vm_size_t page_size;vm_statistics_data_t vm_stat;kern_return_t kern;kern = host_page_size(host_port, &amp;page_size);if (kern != KERN_SUCCESS) return -1;kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);if (kern != KERN_SUCCESS) return -1;return vm_stat.active_count * page_size;&#125;// 最近使用过,但是目前处于不活跃状态的内存- (int64_t)getInActiveMemory &#123;mach_port_t host_port = mach_host_self();mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);vm_size_t page_size;vm_statistics_data_t vm_stat;kern_return_t kern;kern = host_page_size(host_port, &amp;page_size);if (kern != KERN_SUCCESS) return -1;kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);if (kern != KERN_SUCCESS) return -1;return vm_stat.inactive_count * page_size;&#125;// 空闲的内存空间- (int64_t)getFreeMemory &#123;mach_port_t host_port = mach_host_self();mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);vm_size_t page_size;vm_statistics_data_t vm_stat;kern_return_t kern;kern = host_page_size(host_port, &amp;page_size);if (kern != KERN_SUCCESS) return -1;kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);if (kern != KERN_SUCCESS) return -1;return vm_stat.free_count * page_size;&#125;// 已使用的内存空间- (int64_t)getUsedMemory &#123;mach_port_t host_port = mach_host_self();mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);vm_size_t page_size;vm_statistics_data_t vm_stat;kern_return_t kern;kern = host_page_size(host_port, &amp;page_size);if (kern != KERN_SUCCESS) return -1;kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);if (kern != KERN_SUCCESS) return -1;return page_size * (vm_stat.active_count + vm_stat.inactive_count + vm_stat.wire_count);&#125;// 用来存放内核和数据结构的内存,framework、用户级别的应用无法分配- (int64_t)getWiredMemory &#123;mach_port_t host_port = mach_host_self();mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);vm_size_t page_size;vm_statistics_data_t vm_stat;kern_return_t kern;kern = host_page_size(host_port, &amp;page_size);if (kern != KERN_SUCCESS) return -1;kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);if (kern != KERN_SUCCESS) return -1;return vm_stat.wire_count * page_size;&#125;// 可释放的内存空间：内存吃紧自动释放，针对大对象存放所需的大块内存空间- (int64_t)getPurgableMemory &#123;mach_port_t host_port = mach_host_self();mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);vm_size_t page_size;vm_statistics_data_t vm_stat;kern_return_t kern;kern = host_page_size(host_port, &amp;page_size);if (kern != KERN_SUCCESS) return -1;kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);if (kern != KERN_SUCCESS) return -1;return vm_stat.purgeable_count * page_size;&#125; 作者：si1ence链接：https://www.jianshu.com/p/b23016bb97af來源：简书","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"}]},{"title":"RunLoop详解","slug":"RunLoop详解","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T08:46:12.484Z","comments":true,"path":"2019/04/23/RunLoop详解/","link":"","permalink":"https://bigporo.github.io/2019/04/23/RunLoop详解/","excerpt":"RunLoop 详解RunLoop的概念一般来讲，一个线程一次只能执行一个任务，在执行完一个任务之后线程就退出了。通过RunLoop,我们可以让一个线程可以随时处理任务而不退出。","text":"RunLoop 详解RunLoop的概念一般来讲，一个线程一次只能执行一个任务，在执行完一个任务之后线程就退出了。通过RunLoop,我们可以让一个线程可以随时处理任务而不退出。 通常的代码逻辑是这样的：1234567function loop()&#123;do &#123;var message = get_next_message();process_message(message);&#125; while (message != quit);&#125; 这种模型通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。 所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。 OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 RunLoop与线程之间的关系CFRunLoop 是基于 pthread 来管理的。 线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。RunLoop是可以嵌套的。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。 1234567891011121314151617181920212223242526272829303132333435363738/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;/// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock;/// 获取一个 pthread 对应的 RunLoop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;OSSpinLockLock(&amp;loopsLock);if (!loopsDic) &#123;// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。loopsDic = CFDictionaryCreateMutable();CFRunLoopRef mainLoop = _CFRunLoopCreate();CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);&#125;/// 直接从 Dictionary 里获取。CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));if (!loop) &#123;/// 取不到时，创建一个loop = _CFRunLoopCreate();CFDictionarySetValue(loopsDic, thread, loop);/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。_CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);&#125;OSSpinLockUnLock(&amp;loopsLock);return loop;&#125;CFRunLoopRef CFRunLoopGetMain() &#123;return _CFRunLoopGet(pthread_main_thread_np());&#125;CFRunLoopRef CFRunLoopGetCurrent() &#123;return _CFRunLoopGet(pthread_self());&#125; RunLoop提供的接口1#include &lt;CoreFoundation/CFRunLoop.h&gt; 在 CoreFoundation 里面关于 RunLoop 有5个类: CFRunLoopRef CFRunLoopModeRef CFRunLoopSourceRef CFRunLoopTimerRef CFRunLoopObserverRef 其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。 他们的关系如下: 一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 CFRunLoopSourceRef是事件产生的地方。Source有两个版本：Source0 和 Source1。 Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。 处理APP内部事件、APP自己负责管理(触发)，如UIEvent等 Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。 由RunLoop和内核管理，Mach Port 驱动，如CFMachPort,CFMessagePort CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入LoopkCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 TimerkCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 SourcekCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 上面的 Source/Timer/Observer 被统称为mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 RunLoop的ModeCFRunLoopMode 和 CFRunLoop 的结构大致如下： 12345678910111213141516struct __CFRunLoopMode &#123;CFStringRef _name; // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;CFMutableSetRef _sources0; // SetCFMutableSetRef _sources1; // SetCFMutableArrayRef _observers; // ArrayCFMutableArrayRef _timers; // Array...&#125;;struct __CFRunLoop &#123;CFMutableSetRef _commonModes; // SetCFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;CFRunLoopModeRef _currentMode; // Current Runloop ModeCFMutableSetRef _modes; // Set...&#125;; 这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。 应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为“Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。 有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop自动更新到所有具有”Common”属性的 Mode 里去。 CFRunLoop对外暴露的管理 Mode 接口只有下面2个: 12CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);CFRunLoopRunInMode(CFStringRef modeName, ...); Mode 暴露的管理 mode item 的接口有下面几个：123456CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); 你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。 苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。还有一个私有的Mode是UIInitializationRunLoopMode, 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。 同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。 RunLoop内部逻辑RunLoop 内部的逻辑大致如下: 其内部代码整理如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/// 用DefaultMode启动void CFRunLoopRun(void) &#123;CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);&#125;/// 用指定的Mode启动，允许设置RunLoop超时时间int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&#125;/// RunLoop的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;/// 首先根据modeName找到对应modeCFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);/// 如果mode里没有source/timer/observer, 直接返回。if (__CFRunLoopModeIsEmpty(currentMode)) return;/// 1. 通知 Observers: RunLoop 即将进入 loop。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);/// 内部函数，进入loop__CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;Boolean sourceHandledThisLoop = NO;int retVal = 0;do &#123;/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);/// 执行被加入的block__CFRunLoopDoBlocks(runloop, currentMode);/// 4. RunLoop 触发 Source0 (非port) 回调。sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);/// 执行被加入的block__CFRunLoopDoBlocks(runloop, currentMode);/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。if (__Source0DidDispatchPortLastTime) &#123;Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)if (hasMsg) goto handle_msg;&#125;/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。if (!sourceHandledThisLoop) &#123;__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);&#125;/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。/// • 一个基于 port 的Source 的事件。/// • 一个 Timer 到时间了/// • RunLoop 自身的超时时间到了/// • 被其他什么调用者手动唤醒__CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg&#125;/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);/// 收到消息，处理消息。handle_msg:/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。if (msg_is_timer) &#123;__CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())&#125; /// 9.2 如果有dispatch到main_queue的block，执行block。else if (msg_is_dispatch) &#123;__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);&#125; /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件else &#123;CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);if (sourceHandledThisLoop) &#123;mach_msg(reply, MACH_SEND_MSG, reply);&#125;&#125;/// 执行加入到Loop的block__CFRunLoopDoBlocks(runloop, currentMode);if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;/// 进入loop时参数说处理完事件就返回。retVal = kCFRunLoopRunHandledSource;&#125; else if (timeout) &#123;/// 超出传入参数标记的超时时间了retVal = kCFRunLoopRunTimedOut;&#125; else if (__CFRunLoopIsStopped(runloop)) &#123;/// 被外部调用者强制停止了retVal = kCFRunLoopRunStopped;&#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;/// source/timer/observer一个都没有了retVal = kCFRunLoopRunFinished;&#125;/// 如果没超时，mode里没空，loop也没被停止，那继续loop。&#125; while (retVal == 0);&#125;/// 10. 通知 Observers: RunLoop 即将退出。__CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&#125; 可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 RunLoop底层实现RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。 为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图： 苹果用 RunLoop 实现的功能首先我们可以看一下 App 启动后 RunLoop 的状态： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CFRunLoop &#123;current mode = kCFRunLoopDefaultModecommon modes = &#123;UITrackingRunLoopModekCFRunLoopDefaultMode&#125;common mode items = &#123;// source0 (manual)CFRunLoopSource &#123;order =-1, &#123;callout = _UIApplicationHandleEventQueue&#125;&#125;CFRunLoopSource &#123;order =-1, &#123;callout = PurpleEventSignalCallback &#125;&#125;CFRunLoopSource &#123;order = 0, &#123;callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;// source1 (mach port)CFRunLoopSource &#123;order = 0, &#123;port = 17923&#125;&#125;CFRunLoopSource &#123;order = 0, &#123;port = 12039&#125;&#125;CFRunLoopSource &#123;order = 0, &#123;port = 16647&#125;&#125;CFRunLoopSource &#123;order =-1, &#123;callout = PurpleEventCallback&#125;&#125;CFRunLoopSource &#123;order = 0, &#123;port = 2407,callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;CFRunLoopSource &#123;order = 0, &#123;port = 1c03,callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;CFRunLoopSource &#123;order = 0, &#123;port = 1b03,callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;CFRunLoopSource &#123;order = 1, &#123;port = 1903,callout = __IOMIGMachPortPortCallback&#125;&#125;// OvserverCFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entrycallout = _wrapRunLoopWithAutoreleasePoolHandler&#125;CFRunLoopObserver &#123;order = 0, activities = 0x20, // BeforeWaitingcallout = _UIGestureRecognizerUpdateObserver&#125;CFRunLoopObserver &#123;order = 1999000, activities = 0xa0, // BeforeWaiting | Exitcallout = _afterCACommitHandler&#125;CFRunLoopObserver &#123;order = 2000000, activities = 0xa0, // BeforeWaiting | Exitcallout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exitcallout = _wrapRunLoopWithAutoreleasePoolHandler&#125;// TimerCFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0,next fire date = 453098071 (-4421.76019 @ 96223387169499),callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;&#125;,modes ＝ &#123;CFRunLoopMode &#123;sources0 = &#123; /* same as &apos;common mode items&apos; */ &#125;,sources1 = &#123; /* same as &apos;common mode items&apos; */ &#125;,observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,timers = &#123; /* same as &apos;common mode items&apos; */ &#125;,&#125;,CFRunLoopMode &#123;sources0 = &#123; /* same as &apos;common mode items&apos; */ &#125;,sources1 = &#123; /* same as &apos;common mode items&apos; */ &#125;,observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,timers = &#123; /* same as &apos;common mode items&apos; */ &#125;,&#125;,CFRunLoopMode &#123;sources0 = &#123;CFRunLoopSource &#123;order = 0, &#123;callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;&#125;,sources1 = (null),observers = &#123;CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000,callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;)&#125;,timers = (null),&#125;,CFRunLoopMode &#123;sources0 = &#123;CFRunLoopSource &#123;order = -1, &#123;callout = PurpleEventSignalCallback&#125;&#125;&#125;,sources1 = &#123;CFRunLoopSource &#123;order = -1, &#123;callout = PurpleEventCallback&#125;&#125;&#125;,observers = (null),timers = (null),&#125;,CFRunLoopMode &#123;sources0 = (null),sources1 = (null),observers = (null),timers = (null),&#125;&#125;&#125; 可以看到，系统默认注册了5个Mode: kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。 UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。 GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。 kCFRunLoopCommonModes: 这是一个占位的Mode,带有Common标记的字符串，没有实际作用。 AutoreleasePoolApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 小结：AutoreleasePool是在RunLoop即将开始的时候创建，是在RunLoop即将休眠时候释放。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 事件响应苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 手势识别当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 PerformSelecter当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 关于GCD实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。 当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。 定时器NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop， 关于网络请求iOS 中，关于网络请求的接口自下至上有如下几层: 1234CFSocketCFNetwork -&gt;ASIHttpRequestNSURLConnection -&gt;AFNetworkingNSURLSession -&gt;AFNetworking2, Alamofire CFSocket 是最底层的接口，只负责 socket 通信。 CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。 NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。 NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。 下面主要介绍下 NSURLConnection 的工作过程。 通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。 当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。 NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。 RunLoop 的实际应用举例AFNetworkingAFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop： 123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;@autoreleasepool &#123;[[NSThread currentThread] setName:@&quot;AFNetworking&quot;];NSRunLoop *runLoop = [NSRunLoop currentRunLoop];[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];[runLoop run];&#125;&#125;+ (NSThread *)networkRequestThread &#123;static NSThread *_networkRequestThread = nil;static dispatch_once_t oncePredicate;dispatch_once(&amp;oncePredicate, ^&#123;_networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];[_networkRequestThread start];&#125;);return _networkRequestThread;&#125; RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。 12345678910- (void)start &#123;[self.lock lock];if ([self isCancelled]) &#123;[self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];&#125; else if ([self isReady]) &#123;self.state = AFOperationExecutingState;[self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];&#125;[self.lock unlock];&#125; 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。 AsyncDisplayKitAsyncDisplayKit是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下： UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。 排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。 其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。 为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。 ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。 TableView中实现平滑滚动延迟加载图片利用CFRunLoopMode的特性，可以将图片的加载放到NSDefaultRunLoopMode的mode里，这样在滚动UITrackingRunLoopMode这个mode时不会被加载而影响到。 12345UIImage *downloadedImage = ...;[self.avatarImageView performSelector:@selector(setImage:)withObject:downloadedImageafterDelay:0inModes:@[NSDefaultRunLoopMode]]; ibireme：深入理解RunLoop iOS线下分享《RunLoop》by 孙源@sunnyxx","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"}]},{"title":"Runtime原理篇","slug":"Runtime原理篇","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T08:48:11.450Z","comments":true,"path":"2019/04/23/Runtime原理篇/","link":"","permalink":"https://bigporo.github.io/2019/04/23/Runtime原理篇/","excerpt":"Runtime介绍 Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。 Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。了解 Runtime ，要先了解它的核心 - 消息传递 （Messaging）","text":"Runtime介绍 Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。 Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。了解 Runtime ，要先了解它的核心 - 消息传递 （Messaging） Runtime其实有两个版本: “modern” 和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统，只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中。而 macOS 较老的32位程序仍采用 Objective-C 1 中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。 Runtime 基本是用 C 和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在这里下到苹果维护的开源代码。苹果和GNU各自维护一个开源的 runtime 版本，这两个版本之间都在努力的保持一致。平时的业务中主要是使用官方Api，解决我们框架性的需求。高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但是OC并不能直接编译为汇编语言，而是要先转写为纯C语言再进行编译和汇编的操作，从OC到C语言的过渡就是由runtime来实现的。然而我们使用OC进行面向对象开发，而C语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。 Runtime消息传递一个对象的方法像这样[obj foo]，编译器转成消息发送objc_msgSend(obj, foo)，Runtime时执行的流程是这样的： 首先，通过obj的isa指针找到它的 class ; 在 class 的 method list 找 foo ; 如果 class 中没到 foo，继续往它的 superclass 中找 ; 一旦找到 foo 这个函数，就去执行它的实现IMP 。 但这种实现有个问题，效率低。但一个class 往往只有 20% 的函数会被经常调用，可能占总调用次数的 80% 。每个消息都需要遍历一次objc_method_list 并不合理。如果把经常被调用的函数缓存下来，那可以大大提高函数查询的效率。这也就是objc_class 中另一个重要成员objc_cache 做的事情 - 再找到foo 之后，把foo 的method_name 作为key ，method_imp作为value 给存起来。当再次收到foo 消息的时候，可以直接在cache 里找到，避免去遍历objc_method_list。从前面的源代码可以看到objc_cache是存在objc_class 结构体中的。objec_msgSend的方法定义如下： 1OBJC_EXPORT id objc_msgSend(id self, SEL op, ...) 那消息传递是怎么实现的呢？我们看看对象(object)，类(class)，方法(method)这几个的结构体： 1234567891011121314151617181920212223242526272829303132333435//对象struct objc_object &#123;Class isa OBJC_ISA_AVAILABILITY;&#125;;//类struct objc_class &#123;Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__Class super_class OBJC2_UNAVAILABLE;const char *name OBJC2_UNAVAILABLE;long version OBJC2_UNAVAILABLE;long info OBJC2_UNAVAILABLE;long instance_size OBJC2_UNAVAILABLE;struct objc_ivar_list *ivars OBJC2_UNAVAILABLE;struct objc_method_list **methodLists OBJC2_UNAVAILABLE;struct objc_cache *cache OBJC2_UNAVAILABLE;struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;//方法列表struct objc_method_list &#123;struct objc_method_list *obsolete OBJC2_UNAVAILABLE;int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__int space OBJC2_UNAVAILABLE;#endif/* variable length structure */struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;//方法struct objc_method &#123;SEL method_name OBJC2_UNAVAILABLE;char *method_types OBJC2_UNAVAILABLE;IMP method_imp OBJC2_UNAVAILABLE;&#125; 系统首先找到消息的接收对象，然后通过对象的isa找到它的类。 在它的类中查找method_list，是否有selector方法。 没有则查找父类的method_list。 找到对应的method，执行它的IMP。 转发IMP的return值。 消息传递用到的一些概念类对象(objc_class)Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。类对象(Class)是由程序员定义并在运行时由编译器创建的，它没有自己的实例变量，这里需要注意的是类的成员变量和实例方法列表是属于实例对象的，但其存储于类对象当中的。 1typedef struct objc_class *Class; 查看objc/runtime.h中objc_class结构体的定义如下： 12345678910111213141516struct objc_class &#123;Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__Class _Nullable super_class OBJC2_UNAVAILABLE;const char * _Nonnull name OBJC2_UNAVAILABLE;long version OBJC2_UNAVAILABLE;long info OBJC2_UNAVAILABLE;long instance_size OBJC2_UNAVAILABLE;struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE;struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE;struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE;struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; struct objc_class结构体定义了很多变量，通过命名不难发现，结构体里保存了指向父类的指针、类的名字、版本、实例大小、实例变量列表、方法列表、缓存、遵守的协议列表等，一个类包含的信息也不就正是这些吗？没错，类对象就是一个结构体struct objc_class，这个结构体存放的数据称为元数据(metadata)，该结构体的第一个成员变量也是isa指针，这就说明了Class本身其实也是一个对象，因此我们称之为类对象，类对象在编译期产生用于创建实例对象，是单例。 参数解析 isa指针是和Class同类型的objc_class结构指针，类对象的指针指向其所属的类，即元类。元类中存储着类对象的类方法，当访问某个类的类方法时会通过该isa指针从元类中寻找方法对应的函数指针。 super_class指针指向该类所继承的父类对象，如果该类已经是最顶层的根类(如NSObject或NSProxy), 则 super_class为NULL。 cache：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，但提高了调用的效率。 version：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。 protocols：当然可以看出这一个objc_protocol_list的指针。关于objc_protocol_list的结构体构成后面会讲。 获取类名 1const char * class_getName ( Class cls ); 动态创建类 12345678// 创建一个新类和元类Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes ); //如果创建的是root class，则superclass为Nil。extraBytes通常为0// 销毁一个类及其相关联的类void objc_disposeClassPair ( Class cls ); //在运行中还存在或存在子类实例，就不能够调用这个。// 在应用中注册由objc_allocateClassPair创建的类void objc_registerClassPair ( Class cls ); //创建了新类后，然后使用class_addMethod，class_addIvar函数为新类添加方法，实例变量和属性后再调用这个来注册类，再之后就能够用了。 实例(objc_object)实例对象是我们对类对象alloc或者new操作时所创建的，在这个过程中会拷贝实例所属的类的成员变量，但并不拷贝类定义的方法。调用实例方法时，系统会根据实例的isa指针去类的方法列表及父类的方法列表中寻找与消息对应的selector指向的方法。1234567/// Represents an instance of a class.struct objc_object &#123;Class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id; 另外我们常见的id类型，它是一个objc_object结构类型的指针。该类型的对象可以转换为任何一种对象，类似于C语言中void *指针类型的作用。其定义如下所示: 123/// A pointer to an instance of a class.typedef struct objc_object *id;#endif 对对象的类操作 123456// 返回给定对象的类名const char * object_getClassName ( id obj );// 返回对象的类Class object_getClass ( id obj );// 设置对象的类Class object_setClass ( id obj, Class cls ); 获取对象的类定义 12345678910111213// 获取已注册的类定义的列表int objc_getClassList ( Class *buffer, int bufferCount );// 创建并返回一个指向所有已注册类的指针列表Class * objc_copyClassList ( unsigned int *outCount );// 返回指定类的类定义Class objc_lookUpClass ( const char *name );Class objc_getClass ( const char *name );Class objc_getRequiredClass ( const char *name );// 返回指定类的元类Class objc_getMetaClass ( const char *name ); 动态创建对象 12345678// 创建类实例id class_createInstance ( Class cls, size_t extraBytes ); //会在heap里给类分配内存。这个方法和+alloc方法类似。// 在指定位置创建类实例id objc_constructInstance ( Class cls, void *bytes ); // 销毁类实例void * objc_destructInstance ( id obj ); //不会释放移除任何相关引用 元类(Meta Class)类对象中的元数据存储的都是如何创建一个实例的相关信息，那么类对象和类方法应该从哪里创建呢？就是从isa指针指向的结构体创建，类对象的isa指针指向的我们称之为元类(metaclass)，元类中保存了创建类对象以及类方法所需的所有信息，因此整个结构应该如下图所示: 通过上图我们可以看出整个体系构成了一个自闭环，struct objc_object结构体实例它的isa指针指向类对象，类对象的isa指针指向了元类，super_class指针指向了父类的类对象，而元类的super_class指针指向了父类的元类，那元类的isa指针又指向了自己。元类(Meta Class)是一个类对象的类。 操作函数 1234567// 获取类的父类Class class_getSuperclass ( Class cls );// 判断给定的Class是否是一个meta classBOOL class_isMetaClass ( Class cls );// 获取实例大小size_t class_getInstanceSize ( Class cls ); 属性(property)在Objective-C中，属性(property)和成员变量是不同的。那么，属性的本质是什么？它和成员变量之间有什么区别？简单来说属性是添加了存取方法的成员变量，也就是:1@property = ivar + getter + setter; 因此，我们每定义一个@property都会添加对应的ivar, getter和setter到类结构体objc_class中。具体来说，系统会在objc_ivar_list中添加一个成员变量的描述，然后在methodLists中分别添加setter和getter方法的描述。下面的objc_property_t是声明的属性的类型，是一个指向objc_property结构体的指针。 用法举例 123456789101112131415//遍历获取所有属性Property- (void) getAllProperty &#123;unsigned int propertyCount = 0;objc_property_t *propertyList = class_copyPropertyList([Person class], &amp;propertyCount);for (unsigned int i = 0; i &lt; propertyCount; i++ ) &#123;objc_property_t *thisProperty = propertyList[i];const char* propertyName = property_getName(*thisProperty);NSLog(@&quot;Person拥有的属性为: &apos;%s&apos;&quot;, propertyName);&#125;/** objc_property_t:/// An opaque type that represents an Objective-C declared property.typedef struct objc_property *objc_property_t;&#125; 另外，关于属性有一个objc_property_attribute_t结构体列表，objc_property_attribute_t结构体包含name和value，定义如下:1234typedef struct &#123;const char * _Nonnull name; /**&lt; The name of the attribute */const char * _Nonnull value; /**&lt; The value of the attribute (usually empty) */&#125; objc_property_attribute_t; 常用的属性如下： 属性类型 name值：T value：变化 编码类型 name值：C(copy) &amp;(strong) W(weak)空(assign) 等 value：无 非/原子性 name值：空(atomic) N(Nonatomic) value：无 变量名称 name值：V value：变化1234567891011@interface person : NSObjec&#123; NSString *_name; &#125; int main()&#123; objc_property_attribute_t nonatomic = &#123;&quot;N&quot;, &quot;&quot;&#125;; objc_property_attribute_t strong = &#123;&quot;&amp;&quot;, &quot;&quot;&#125;; objc_property_attribute_t type = &#123;&quot;T&quot;, &quot;@\\&quot;NSString\\&quot;&quot;&#125;; objc_property_attribute_t ivar = &#123;&quot;V&quot;, &quot;_name&quot;&#125;; objc_property_attribute_t attributes[] = &#123;nonatomic, strong, type, ivar&#125;; BOOL result = class_addProperty([person class], &quot;name&quot;, attributes, 4); &#125; 操作函数 12345678// 获取属性名const char * property_getName ( objc_property_t property );// 获取属性特性描述字符串const char * property_getAttributes ( objc_property_t property );// 获取属性中指定的特性char * property_copyAttributeValue ( objc_property_t property, const char *attributeName );// 获取属性的特性列表objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, unsigned int *outCount ); 成员变量(objc_ivar)Ivar: 实例变量类型，是一个指向objc_ivar结构体的指针 12/// An opaque type that represents an instance variable.typedef struct objc_ivar *Ivar; objc_ivar结构体的组成如下： 12345678- struct objc_ivar &#123;char * _Nullable ivar_name OBJC2_UNAVAILABLE;char * _Nullable ivar_type OBJC2_UNAVAILABLE;int ivar_offset OBJC2_UNAVAILABLE;#ifdef __LP64__int space OBJC2_UNAVAILABLE;#endif&#125; 这里我们注意第三个成员 ivar_offset。它表示基地址偏移字节。 操作函数 12345678910111213141516171819//成员变量操作函数// 修改类实例的实例变量的值Ivar object_setInstanceVariable ( id obj, const char *name, void *value );// 获取对象实例变量的值Ivar object_getInstanceVariable ( id obj, const char *name, void **outValue );// 返回指向给定对象分配的任何额外字节的指针void * object_getIndexedIvars ( id obj );// 返回对象中实例变量的值id object_getIvar ( id obj, Ivar ivar );// 设置对象中实例变量的值void object_setIvar ( id obj, Ivar ivar, id value );// 获取类成员变量的信息Ivar class_getClassVariable ( Class cls, const char *name );// 添加成员变量BOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types ); //这个只能够向在runtime时创建的类添加成员变量// 获取整个成员变量列表Ivar * class_copyIvarList ( Class cls, unsigned int *outCount ); //必须使用free()来释放这个数组. 成员变量列表(objc_ivar_list)在objc_class中，所有的成员变量、属性的信息是放在链表ivars中的。ivars是一个数组，数组中每个元素是指向Ivar(变量信息)的指针。 12345678struct objc_ivar_list &#123;int ivar_count OBJC2_UNAVAILABLE;#ifdef __LP64__int space OBJC2_UNAVAILABLE;#endif/* variable length structure */struct objc_ivar ivar_list[1] OBJC2_UNAVAILABLE;&#125; 例子，获取所有成员变量 123456789101112//遍历获取Person类所有的成员变量IvarList- (void) getAllIvarList &#123;unsigned int methodCount = 0;Ivar * ivars = class_copyIvarList([Person class], &amp;methodCount);for (unsigned int i = 0; i &lt; methodCount; i ++) &#123;Ivar ivar = ivars[i];const char * name = ivar_getName(ivar);const char * type = ivar_getTypeEncoding(ivar);NSLog(@&quot;Person拥有的成员变量的类型为%s，名字为 %s &quot;,type, name);&#125;free(ivars);&#125; Method(objc_method)objc_method 存储了方法名，方法类型和方法实现： 1234567891011runtime.h/// An opaque type that represents a method in a class definition.代表类定义中一个方法的不透明类型typedef struct objc_method *Method;struct objc_method &#123;SEL method_name;OBJC2_UNAVAILABLE;char *method_types; OBJC2_UNAVAILABLE;IMP method_imp; OBJC2_UNAVAILABLE;&#125; Method和我们平时理解的函数是一致的，就是表示能够独立完成一个功能的一段代码，比如： 1234- (void)logName&#123;NSLog(@&quot;name&quot;);&#125; 我们来看下objc_method这个结构体的内容： SEL method_name 方法名 char *method_types 方法类型，存储方法的参数类型和返回值类型 IMP method_imp 指向了方法的实现，本质是一个函数指针 简言之，Method = SEL + IMP + method_types，相当于在SEL和IMP之间建立了一个映射。 在这个结构体中，我们已经看到了SEL和IMP，说明SEL和IMP其实都是Method的属性。 操作函数 1234567891011121314151617181920212223242526// 调用指定方法的实现，返回的是方法实现时的返回，参数receiver不能为空，这个比method_getImplementation和method_getName快id method_invoke ( id receiver, Method m, ... );// 调用返回一个数据结构的方法的实现void method_invoke_stret ( id receiver, Method m, ... );// 获取方法名，希望获得方法明的C字符串，使用sel_getName(method_getName(method))SEL method_getName ( Method m );// 返回方法的实现IMP method_getImplementation ( Method m );// 获取描述方法参数和返回值类型的字符串const char * method_getTypeEncoding ( Method m );// 获取方法的返回值类型的字符串char * method_copyReturnType ( Method m );// 获取方法的指定位置参数的类型字符串char * method_copyArgumentType ( Method m, unsigned int index );// 通过引用返回方法的返回值类型字符串void method_getReturnType ( Method m, char *dst, size_t dst_len );// 返回方法的参数的个数unsigned int method_getNumberOfArguments ( Method m );// 通过引用返回方法指定位置参数的类型字符串void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );// 返回指定方法的方法描述结构体struct objc_method_description * method_getDescription ( Method m );// 设置方法的实现IMP method_setImplementation ( Method m, IMP imp );// 交换两个方法的实现void method_exchangeImplementations ( Method m1, Method m2 ); 方法列表(objc_method_list)方法调用是通过查询对象的isa指针所指向归属类中的methodLists来完成。 12345678910struct objc_method_list &#123;struct objc_method_list * _Nullable obsolete OBJC2_UNAVAILABLE;int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__int space OBJC2_UNAVAILABLE;#endif/* variable length structure */struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125; 操作函数 123456789101112131415161718192021// 添加方法BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types ); //和成员变量不同的是可以为类动态添加方法。如果有同名会返回NO，修改的话需要使用method_setImplementation// 获取实例方法Method class_getInstanceMethod ( Class cls, SEL name );// 获取类方法Method class_getClassMethod ( Class cls, SEL name );// 获取所有方法的数组Method * class_copyMethodList ( Class cls, unsigned int *outCount );// 替代方法的实现IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );// 返回方法的具体实现IMP class_getMethodImplementation ( Class cls, SEL name );IMP class_getMethodImplementation_stret ( Class cls, SEL name );// 类实例是否响应指定的selectorBOOL class_respondsToSelector ( Class cls, SEL sel ); SEL(objc_selector)123Objc.h/// An opaque type that represents a method selector.代表一个方法的不透明类型typedef struct objc_selector *SEL; objc_msgSend函数第二个参数类型为SEL，它是selector在Objective-C中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:1@property SEL selector; 可以看到selector是SEL的一个实例。 1A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded. 其实selector就是个映射到方法的C字符串，你可以用 Objective-C 编译器命令@selector()或者 Runtime 系统的sel_registerName函数来获得一个 SEL 类型的方法选择器。 selector既然是一个string，我觉得应该是类似className+method的组合，命名规则有两条： 同一个类，selector不能重复 不同的类，selector可以重复 这也带来了一个弊端，我们在写C代码的时候，经常会用到函数重载，就是函数名相同，参数不同，但是这在Objective-C中是行不通的，因为selector只记了method的name，没有参数，所以没法区分不同的method。 操作函数 12345678// 返回给定选择器指定的方法的名称const char * sel_getName ( SEL sel );// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器SEL sel_registerName ( const char *str );// 在Objective-C Runtime系统中注册一个方法SEL sel_getUid ( const char *str );// 比较两个选择器BOOL sel_isEqual ( SEL lhs, SEL rhs ); IMP123/// A pointer to the function of a method implementation. 指向一个方法实现的指针typedef id (*IMP)(id, SEL, ...); #endif 就是指向最终实现程序的内存地址的指针。 在iOS的Runtime中，Method通过selector和IMP两个属性，实现了快速查询方法及实现，相对提高了性能，又保持了灵活性。 类缓存(objc_cache)当Objective-C运行时通过跟踪它的isa指针检查对象时，它可以找到一个实现许多方法的对象。然而，你可能只调用它们的一小部分，并且每次查找时，搜索所有选择器的类分派表没有意义。所以类实现一个缓存，每当你搜索一个类分派表，并找到相应的选择器，它把它放入它的缓存。所以当objc_msgSend查找一个类的选择器，它首先搜索类缓存。这是基于这样的理论：如果你在类上调用一个消息，你可能以后再次调用该消息。 为了加速消息分发， 系统会对方法和对应的地址进行缓存，就放在上述的objc_cache，所以在实际运行中，大部分常用的方法都是会被缓存起来的，Runtime系统实际上非常快，接近直接执行内存地址的程序速度。 Category(objc_category)Category是表示一个指向分类的结构体的指针，其定义如下： 12345678struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods;struct protocol_list_t *protocols;struct property_list_t *instanceProperties;&#125;; name：是指 class_name 而不是 category_name。 cls：要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对 应到对应的类对象。 instanceMethods：category中所有给类添加的实例方法的列表。 classMethods：category中所有添加的类方法的列表。 protocols：category实现的所有协议的列表。 instanceProperties：表示Category里所有的properties，这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，不过这个和一般的实例变量是不一样的。 从上面的category_t的结构体中可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，不可以添加成员变量。 Runtime消息转发前文介绍了进行一次发送消息会在相关的类对象中搜索方法列表，如果找不到则会沿着继承树向上一直搜索知道继承树根部（通常为NSObject），如果还是找不到并且消息转发都失败了就回执行doesNotRecognizeSelector:方法报unrecognized selector错。那么消息转发到底是什么呢？接下来将会逐一介绍最后的三次机会。 动态方法解析 备用接收者 完整消息转发 动态方法解析首先，Objective-C运行时会调用 +resolveInstanceMethod:或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数并返回YES， 那运行时系统就会重新启动一次消息发送的过程。 实现一个动态方法解析的例子如下： 123456789101112131415161718- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.//执行foo函数[self performSelector:@selector(foo:)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;if (sel == @selector(foo:)) &#123;//如果是执行foo函数，就动态解析，指定新的IMPclass_addMethod([self class], sel, (IMP)fooMethod, &quot;v@:&quot;);return YES;&#125;return [super resolveInstanceMethod:sel];&#125;void fooMethod(id obj, SEL _cmd) &#123;NSLog(@&quot;Doing foo&quot;);//新的foo函数&#125; 打印结果：2018-04-01 12:23:35.952670+0800 ocram[87546:23235469] Doing foo 可以看到虽然没有实现foo:这个函数，但是我们通过class_addMethod动态添加fooMethod函数，并执行fooMethod这个函数的IMP。从打印结果看，成功实现了。如果resolve方法返回 NO ，运行时就会移到下一步：forwardingTargetForSelector。 备用接收者如果目标对象实现了-forwardingTargetForSelector:，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。 实现一个备用接收者的例子如下：1234567891011121314151617181920212223242526272829303132333435363738394041#import &quot;ViewController.h&quot;#import &quot;objc/runtime.h&quot;@interface Person: NSObject@end@implementation Person- (void)foo &#123;NSLog(@&quot;Doing foo&quot;);//Person的foo函数&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.//执行foo函数[self performSelector:@selector(foo)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;return YES;//返回YES，进入下一步转发&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123;if (aSelector == @selector(foo)) &#123;return [Person new];//返回Person对象，让Person对象接收这个消息&#125;return [super forwardingTargetForSelector:aSelector];&#125;@end 打印结果：2018-04-01 12:45:04.757929+0800 ocram[88023:23260346] Doing foo 可以看到我们通过forwardingTargetForSelector把当前ViewController的方法转发给了Person去执行了。打印结果也证明我们成功实现了转发。 完整消息转发如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil ，Runtime则会发出 -doesNotRecognizeSelector: 消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation 对象并发送 -forwardInvocation:消息给目标对象。 实现一个完整转发的例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#import &quot;ViewController.h&quot;#import &quot;objc/runtime.h&quot;@interface Person: NSObject@end@implementation Person- (void)foo &#123;NSLog(@&quot;Doing foo&quot;);//Person的foo函数&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.//执行foo函数[self performSelector:@selector(foo)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;return YES;//返回YES，进入下一步转发&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123;return nil;//返回nil，进入下一步转发&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;foo&quot;]) &#123;return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];//签名，进入forwardInvocation&#125;return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;SEL sel = anInvocation.selector;Person *p = [Person new];if([p respondsToSelector:sel]) &#123;[anInvocation invokeWithTarget:p];&#125;else &#123;[self doesNotRecognizeSelector:sel];&#125;&#125;@end 打印结果：2018-04-01 13:00:45.423385+0800 ocram[88353:23279961] Doing foo 从打印结果来看，我们实现了完整的转发。通过签名，Runtime生成了一个对象anInvocation，发送给了forwardInvocation，我们在forwardInvocation方法里面让Person对象去执行了foo函数。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"}]},{"title":"《计算机网络（第七版）》读书总结","slug":"《计算机网络（第七版）》读书总结","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-23T16:31:41.143Z","comments":true,"path":"2019/04/23/《计算机网络（第七版）》读书总结/","link":"","permalink":"https://bigporo.github.io/2019/04/23/《计算机网络（第七版）》读书总结/","excerpt":"主要是摘录书中的重要概念。 概述 计算机网络(可简称为网络)把许多计算机连接在一起，而互连网则把许多网络连接在一起，是网络的网络。","text":"主要是摘录书中的重要概念。 概述 计算机网络(可简称为网络)把许多计算机连接在一起，而互连网则把许多网络连接在一起，是网络的网络。 以小写字母i开始的 internet(互连网)是通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议(即通信规则)可以是任意的。 以大写字母I开始的 Internet(互联网)是专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，并采用TCP/IP协议族作为通信规则，且其前身是美国的 ARPANET。 Internet的推荐译名是“因特网”，但很少被使用。 互联网现在采用存储转发的分组交换技术，以及三层ISP结构。 互联网按工作方式可划分为边缘部分与核心部分。主机在网络的边缘部分，其作用是进行信息处理。路由器在网络的核心部分，其作用是按存储转发方式进行分组交换。 计算机通信是计算机中的进程(即运行着的程序)之间的通信。计算机网络采用的通信方式是客户一服务器方式和对等连接方式(P2P方式)客户和服务器都是指通信中所涉及的应用进程。 客户是服务请求方，服务器是服务提供方。按作用范围的不同，计算机网络分为广域网WAN、城域网MAN、局域网LAN和个人区域网PAN。 计算机网络最常用的性能指标是:速率、带宽、吞吐量、时延(发送时延、传播延、处理时延、排队时延)、时延带宽积、往返时间和信道(或网络)利用率 网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构。 五层协议的体系结构由应用层、运输层、网络层(或网际层)、数据链路层和物理层组成。运输层最重要的协议是TCP和UDP协议，而网络层最重要的协议是IP协议。 物理层 物理层的主要任务就是确定与传输媒体的接口有关的一些特性，如机械特性、电气特性、功能特性和过程特性。 一个数据通信系统可划分为三大部分，即源系统、传输系统和目的系统。源系统包括源点(或源站、信源)和发送器，目的系统包括接收器和终点(或目的站，或信宿)。 通信的目的是传送消息。如话音、文字、图像、视频等都是消息。数据是运送消息的实体。信号则是数据的电气或电磁的表现。 根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号(或连续信号)和数字信号(或离散信号)。代表数字信号不同离散数值的基本波形称为码元。根据双方信息交互的方式，通信可以划分为单向通信(或单工通信)、双向交替通信(或半双工通信)和双向同时通信(或全双工通信)。 来自信源的信号叫做基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅、调频和调相。还有更复杂的调制方法，如正交振幅调制。 要提高数据在信道上的传输速率，可以使用更好的传输媒体，或使用先进的调制技型传输媒体(无线或红外或大气激光)。但数据传输速率不可能被任意地提高。 传输媒体可分为两大类，即导引型传输媒体(双绞线、同轴电缆或光纤)和非导引型传输媒体(无线或红外或大气激光)。 常用的信道复用技术有频分复用、时分复用、统计时分复用、码分复用和波分复用（光的频分复用）。 最初在数字传输系统中使用的传输标准是脉冲编码调制PCM。现在高速的数字传输系统使用同步光纤网 SONET(美国标准)或同步数字系列SDH(国际标准)。 用户到互联网的宽带接入方法有非对称数字用户线ADSL(用数字技术对现有的模拟电话用户线进行改造)、光纤同轴混合网HFC(在有线电视网的基础上开发的)和FTTx(即光纤到户)。 为了有效地利用光纤资源，在光纤干线和用户之间广泛使用无源光网络PON。无源光网络无须配备电源，其长期运营成本和管理成本都很低。最流行的无源光网经是以太网无源光网络EPON和吉比特无源光网络GPON。 数据链路层 链路是从一个结点到相部结点的一段物理线路，数据链路则是在链路的基础上增加了一些必要的硬件(如网络适配器)和软件(如协议的实现)。 数据链路层使用的信道主要有点对点信道和广播信道两种。数据链路层传送的协议数据单元是帧。数据链路层的三个基本问题则是:封装成帧、透明传输和差错检测。 循环冗余检验CRC是一种检错方法，而检验序列FCS是添加在数据后面的冗余码。 点对点协议PPP是数据链路层使用最多的一种协议，它的特点是:简单；只检测差错，而不是纠正差错:不使用序号，也不进行流量控制:可同时支持多种网络层协议。 PPPOE是为宽带上网的主机使用的链路层协议。 局域网的优点是:具有广播功能，从一个站点可很方便地访问全网:便于系统的扩展和逐渐演变；提高了系统的可靠性、可用性和生存性。 共享通信媒体资源的方法有二:一是静态划分信道(各种复用技术)，二是动态媒体接入控制，又称为多点接入(随机接入或受控接入)。 IEE802委员会曾把局域网的数据链路层拆成两个子层，即逻辑链路控制(LC)子层(与传输媒体无关)和媒体接入控制MAC)子层(与传输媒体有关)。但现在LC子层已成为历史。 计算机与处界局域网的通信要通过通信适配器(或网络适配器)，它又称为网络接口卡或网卡，主要功能是进行数据串行传输和并行传输的转换。计算机的硬件地址就在适配器ROM中。 以太网采用无连接的工作方式，对发送的数据不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢弃，其他什么也不做。 以太网采用的协议是具有冲突检测的載波监听多点接入 CSMA/CD。协议的要点是:发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。因此，每一个站在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。以太网上各站点都平等地争用以太网信道。 传统的总线以太网基本上都是使用集线器的双绞线以太网。这种以太网在物理上是星形网，但在逻辑上则是总线形网。集线器工作在物理层，它的每个接口仅仅简单地转发比特不进行碰撞检测。 以太网的硬件地址，即MAC地址事实上就是适配器地址或适配器标识符，与主机所在的地点无关。源地址和目的地址都是48位长。 以太网的适配器有过滤功能，它只接收单播帧、广播帧或多播帧。 使用集线器可以在物理层扩展以太网(扩展后的以太网仍然是一个网络)。 交换式集线器常称为以太网交換机或第二层交换机(工作在数据链路它就是个多接口的网桥），而每个接口都直接与某台单主机或另一个集线器相连，且工作在全双工方式。 以太网交换机其实就是个多接口的网桥，能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，无碰撞地传输数据。 高速以太网有100Mits的快速以太网、吉比特以太网和10 Gbit/s的10吉比特以太网。最近还发展到100吉比特以太网。在宽带接入技术中，也常使用高速以太网进行接入。 网络层 TCP/IP体系中的网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组可能出错、丢失、重复和失序。进程之间通信的可靠性由运输层负责。 IP网是虚拟的，因为从网络层上看，IP网就是一个统一的、抽象的网络(实际上是异构的)。IP层抽象的互联网屏蔽了下层网络很复杂的细节，使我们能够使用统一的、抽象的IP地址处理主机之间的通信问题。 在互联网上的交付有两种:在本网络上的直接交付(不经过路由器)和到其他网络的间接交付(经过至少一个路由器，但最后一次一定是直接交付)。 一个IP地址在整个互联网范围内是唯一的。分类的IP地址包括A类、B类和C类地址(单播地址)，以及D类地址(多播地址)。E类地址未使用。 分类的IP地址由网络号字段(指明网络)和主机号字段(指明主机)组成。网络号字段最前面的类别位指明IP地址的类别。 IP地址是一种分等级的地址结构。IP地址管理机构在分配IP地址时只分配网络号，而主机号则由得到该网络号的单位自行分配。路由器仅根据目的主机所连接的网络号来转发分组。 IP地址标志一台主机(或路由器)和一条链路的接口。多归属主机同时连接到两个或更多的网络上。这样的主机同时具有两个或更多的IP地址，其网络号必须不同的。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有2个不同的IP地址。 按照互联网的观点，用转发器或网桥连接起来的若干个局域网仍为一个网络。所分配到网络号的网络(不管是范围很小的局域网，还是可能覆盖很大地理范围的域网)都是平等的。 物理地址(即硬件地址)是数据链路层和物理层使用的地址，而P地址是网络和以上各层使用的地址，是一种逻辑地址(用软件实现的)，在数据路层看不见数据报的IP地址。 IP数据报分为首部和数据两部分。首部的前一部分是固定长度，共20字节，是所有IP数据报必须具有的(源地址、目的地址、总长度等重要字段部在定首部中)。一些长度可变的可选字段放在固定首部的后面。 IP首部中的生存时间字段给出了IP数据报在互联网中所能经过的最大路由器数，可防止IP数据报在互联网中无限制地兜圈子。 地址解析协议ARP把IP地址解析为硬件地址，它解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。ARP的高速缓存可以大大减少网络上的通信量。 在互联网中，我们无法仅根据硬件地址寻找到在某个网络上的某台主机。因此，从IP地址到硬件地址的解析是非常必要的。 无分类域间路由选择CIDR是解決目前IP地址紧缺的一个好方法。CIDR记法把IP地址后面加上斜线”/“，然后写上前缀所占的位数。前(或网络前级)用来指 明网络，前缀后面的部分是后缀，用来指明主机。CIDR把前绶都相同的连续的IP地址组成一个“CIDR地址块”。IP地址的分配都以CIDR地址块为单位。 CIDR的32位地址掩码(或子网掩码)由一串1和一串0组成，而1的个数就是前缀的长度。只要把IP地址和地址掩码逐位进行“逻辑与(AND)”运算，就很容易得出网络地址A类地址的默认地址掩码是25500。B类地址的默认地址码是255250.0。C类地址的默认地址掩码是255.2552550. 路由聚合(把许多前缀相同的地址用一个来代替)有利于减少路由表中的项目，减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。 “转发”和“路由选择”有区别。“转发”是单个路由器的动作。“路由选择”是许 多由置共同鼓作的过程，这些路由器相立交换信息，目的是生成路由表，再从路由表导出转发表。若采用自适应路由选择算法，则当网络拓扑变化时，路由表和转发表都能够自动更新。在许多情况下，可以不考虑转发表和路由表的区别，而都使用路由表这一名词。 自治系统(AS)就是在单一的技术管理下的一组路由器。一个自治系统对其他它自治系统表现出的是一个单一的和一致的路由选择策略。 路由选择协议有两大类:内部网关协议(或自治系统内部的路由选择协议)，如RIP和OSP；外部网关协议(或自治系统之间的路由选择协议)，如BGP-4。 RIP是分布式的基于距离向量的路由选择协议，只适用于小型互联网。RIP按固定的时间间隔与相邻路由器交换信息。交换的信息是自己当前的路由表，即到达本自治系统中所有网络的(最短)距离，以及到每个网络应经过的下一跳路由器。 OSPF是分布式的链路状态协议，适用于大型互联网。OSPF只在链路状态发生 化时，才向本自治系统中的所有路由器，用洪泛法发送与本路由器相邻的所有路由器的链路状态信息。“链路状态”指明本路由器都和哪些路由器相邻，以及该链路的“度量”。“度量”可表示费用、距离、时延、带宽等，可统称为“代价”。所有的路由器最终都能建立一个全网的拓扑结构图。 BGP4是不同AS的路由器之间交换路由信息的协议，是一种路径向量路由选择协议。BGP力求寻找一条能够到达目的网络(可达)且比较好的路由(不兜圈子)，而并非要寻找一条最佳路由。 网际控制报文协议ICMP是IP层的协议。ICMP报文作为IP数据报的数据，加上首部后组成IP数据报发送出去。使用ICMP并非为了实现可靠传输。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP报文的种类有两种，即ICMP差错报告报文和ICMP询问报文。 ICMP的一个重要应用就是分组网间探测PING，用来测试两台主机之间的连通性。PING使用了ICMP回送请求与回送回答报文。 要解决IP地址耗尽的问题，最根本的办法就是采用具有更大地址空间的新版本的IP协议，即IPv6。 IPV6所带来的主要变化是:(1)更大的地址空间(采用128位的地址):(2)灵活的首部格式:(3)改进的选项:(4)支持即插即用:(5)支持资源的预分配:(6)IPv6的首部改为8字节对齐。 IPv6数据报在基本首部的后面允许有零个或多个扩展首部，再后面是数据。所有的扩展首部和数据合起来叫做数据报的有效载荷或净负荷。 IPv6数据报的目的地址可以是以下三种基本类型地址之一:单播、多播和任播。 IPv6的地址使用冒号十六进制记法。 向IPV6过渡只能采用逐步演进的办法，必须使新安装的IPv6系统能够向后兼容向IPw6过渡可以使用双协议栈或使用隧道技术。 与单播相比，在一对多的通信中，IP多播可大大节约网络资源。IP多播使用D类IP地址。IP多播需要使用网际组管理协议IGMP和多播路由选择协议。 虚拟专用网VPN利用公用的互联网作为本机构各专用网之间的通信载体。VPN内部使用互联网的专用地址。ー个VPN至少要有一个路由器具有合法的全球IP地址，这样オ能和本系统的另ー个VPN通过互联网进行通信。所有通过互联网传送的数据都必须加密。 使用网络地址转换NAT技术，可以在专用网络内部使用专用IP地址，而仅在连接到互联网的路由器使用全球P地址。这样就大大节约了宝贵的IP地址。 MPLS的特点:(1)支持面向连接的服务质量；(2)支持流量工程，平衡网络负载:(3)有效地支持虚拟专用网VPN。 MPLS在入口结点给每一个IP数据报打上固定长度的“标记”，然后根据标记在第二层(链路层)用硬件进行转发(在标记交换路由器中进行标记对换)，因而转发速率大大加快。 运输层 运输层提供应用进程间的逻辑通信，也就是说，运输层之间的通信并不是真正在两 个运输层之间直接传送数据。运输层向应用层屏蔽了下面网络的细节(如网络拓扑、所采用的路由选择协议等)，它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。 网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。 运输层有两个主要的协议:TCP和UDP。它们都有复用和分用，以及检错的功能。当运输层采用面向连接的TCP协议时，尽管下面的网络是不可靠的(只提供尽最大努力服务)，但这种逻辑通信信道就相当于一条全双工通信的可靠信道。当运输层采用无连接的UDP协议时，这种逻辑通信信道仍然是一条不可靠信道。 运输层用一个16位端口号来标志一个端口。端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。 两台计算机中的进程要互相通信，不仅要知道对方的IP地址(为了找到对方的计算机)，而且还要知道对方的端口号(为了找到对方计算机中的应用进程)。 运输层的端口号分为服务器端使用的端口号(0~1023指派给熟知端口，1024~49151是登记端口号)和客户端暫时使用的端口号(49152~65535)。 UDP的主要特点是:(1)无连接:(2)尽最大努力交付:(3)面向报文；(4)无拥塞控制:(5)支持一对对多、多对一和多对多的交互通信；(6)首部开销小(只有四个字段:源端口、目的端口、长度、检验和) TCP的主要特点是:(1)面向连接；(2)每一条TCP连接只能是点对点的(一对一):(3)提供可靠交付的服务:(4)提供全双工通信:(5)面向字节流。 TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点。这样的端点就叫做套接字( socket)或插口。套接字用(IP地址:端口号)来表示。 停止等待协议能够在不可靠的传输网络上实现可靠的通信。每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。分组需要进行编号。 超时重传是指只要超过了一段时间仍然没有收到确认，就重传前面发送过的分组(认为刚オ发送的分组丢失了)。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。 连续ARQ协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都己正确收到了。 TCP报文段首部的前20个字节是固定的，后面有4N字节是根据需要而增加的选项(N是整数)。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号。 TCP首部中的确认号是期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则表明:到序号N-1为止的所有数据都已正确收到。 TCP首部中的窗口字段指出了现在允许对方发送的数据量。窗口值是经常在动态变化着的。 TCP使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到了确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动(没有收到新的确认)和前移(收到了新的确认) 发送窗口前沿通常是不断向前移动的。 流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做拥塞。拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。 流量控制是一个端到端的问题，是接收端抑制发送端发送数据的速率，以便使接收端来得及接收。拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 为了进行拥塞控制、TCP的发送方要推持一个拥塞窗口cwnd的状态变量。拥塞窗口的大小取決于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。 TCP的拥塞控制采用了四种算法，即慢开始、拥塞避免、快重传和快恢复。在网终层，也可以使路由器采用适当的分组丢弃策略(如主动队列管理AQM)，以减少网络拥塞的发生 运输连接有三个阶段，即:连接建立、数据传送和连接释放。 主动发起TCP连接建立的应用进程叫做客户，而被动等待连接建立的应用进程做眼务器。TCP的连接建立采用三报文握手机制。服务器要确认客户的连接请求，然后客户要对服务器的确认进行确认。 TCP的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发送连接释放的通知，待对方确认后就进入半关闭状态。当另一方也没有数据再发送时，则发送链接释放通知，对方确认后就完全关闭了TCP连接接释放的通知。 应用层 应用层协议是为了解决某一类应用问题，而问题的解决又是通过位于多个应用进程之间的通信和协同工作来完成的。应用层规定了应用进程在通信时所遵循的协议。 应用层的许多协议都是基于客户服务器方式的。客户是服务请求方，服务器是服务提供方。 域名系统DNS是互联网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址。DNS是一个联机分布式数据库系统，并采用客户服务器方式。 域名到IP地址的解析是由分布在互联网上的许多域名服务器程序(即域名服务器)共同完成的。 互联网采用层次树状结构的命名方法，任何一台连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。域名中的点和点分十进制IP地址中的点没有关系。 域名服务器分为根域名服务器、顶级域名服务器、权限域名服务器和本地域名服务器。 文件传送协议FTP使用TCP可靠的运输服务。FTP使用客户服务器方式。一个FTP服务器进程可同时为多个客户进程提供服务。在进行文件传输时，FTP 的客户和服务器之间要建立两个并行的TCP连接:控制连接和数据连接。实际用于传输文件的是数据连接。 万维网www是一个大规模的、联机式的信息储藏所，可以非常方便地从互联网上的一个站点链接到另一个站点。 万维网的客户程序向互联网中的服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。 在客户程序上显示出的万维网文档称为页面。 万维网使用统资源定位符URL来标志万维网上的各种文档，并使每一个文档在整个互联网的范围内具有唯一的标识符URL。 万维网客户程序与服务器程序之间进行交互所使用的协议是超文本传送协议HTTP。HTTP使用TCP连接进行可靠的传送。但HTTP协议本身是无连接、无状态的。HTTP/1.1 协议使用了持续连接(分为非流水线方式和流水线方式)。 万维网使用超文本标记语言HTML来显示各种万维网页面。 万维网静态文档是指在文档创作完毕后就存放在万维网服务器中，在被用户浏览的才由应用程序动态创建的。过程中，内容不会改变。动态文档是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建的。 活动文档技术可以使浏览器屏幕连续更新。活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。 在万维网中用来进行搜索的工具叫做搜索引擎。搜索引擎大体上可划分为全文检索搜索引擎和分类目录搜索引擎两大类。 电子邮件是互联网上使用最多的和最受用户欢迎的一种应用。电子邮件把邮件发到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自 送己使用的邮件服务器进行读取，相当于“电子信箱”。 这个电子邮件系统有三个主要组成构件即用户代理、邮件服务器，以及邮件协议(包括邮件发送协议，如SMTP，和邮件读取协议，如PPOP3和IMAP)。用户代理和邮件服务器都要运行这些协议。 电子邮件的用户代理就是用户与电子邮件系统的接口，它向用户提供一个很友好的视窗界面来发送和接收邮件。 从用户代理把邮件传送到邮件服务器，一级在邮件服务器之间的传送，都要使用SMTP协议。但用户代理从邮件服务器读取邮件时，则要使用POP3（或IMAP）协议。 基于万维网的电子邮件使用户能够利用浏览器收发电子邮件。用户浏 浏览器和邮件服务器之间的邮件传送使用HTTP协议，而在邮 件服务器之间邮件的传送仍然使用SMTP协议。 简单网络管理协议SNMP由三部分组成，即(1)SNMP本身，负责读取和改变各代理中的对象名及其状态数值: (2)管理信息结构SMI，定义命名对象和定义对象类型(包括范围和长度)的通用规则，以及把对象和对象的值进行编码的基本编码规则BER； (3) 管理信息库MIB，在被管理的实体中创建了命名对象，并规定了其类型。 系统调用接口是应用进程的控制权和操作系统的控制权进行转换的一个接口，又称为应用编程接口API。API 就是应用程序和操作系统之间的接口。 套接字是应用进程和运输层协议之间的接口，是应用进程为了获得网络通信服务而与操作系统进行交互时使用的一种机制。 目前P2P工作方式下的文件共享在互联网流量中已占据最大的份额，比万维网应用所占的比例大得多。 BT是很流行的种P2P应用。BT采用“是稀有的优先”的技术，可以尽早把取稀有的文件块收集到。此外，凡有当前以最高数据率向某个对等方传送文件块的相邻对等方，该对等方就优先把所请求的文件块传送给这些相邻对等方。这样做的结果是，这些对等方相互之间都能够以令人满意的速率交换文件块。 当对等方的数量很大时，采用P2P方式下载大文件，要比传统的客户-服务器方式快得多。 在P2P应用中，广泛使用的索引和查找技术是分布式散列表DHT。 网络安全 计算机网络上的通信面临的威胁可分为两大类， 即被动攻击(如截获)和主动攻击 (如中断、算改、伪造)。主动攻击的类型有更改报文流、拒绝服务、伪造初始 化、恶意程序(病毒、蠕虫、木马、逻辑炸弹、后门入侵、流氓软件)等。 计算机网络安全主要有以下一些内容:保密性、安全协议的设计和访问控制。 密码编码学是密码体制的设计学，而密码分析学则是在未知密钥的情况下从密文推演出明文或密钥的技术。密码编码学与密码分析学合起来即为密码学。 如果不论截取者获得了多少密文，都无法唯一地确定出对应的明文，则这一密码体制称为无条件安全的(或理论上是不可破的)。在无任何限制的条件下，目前几乎所有实用的密码体制均是可破的。如果一个密码体制中的密码不能在一定时间内被可以使用的计算资源破译，则这密码体制称为在计算上是安全的。 对称密钥密码体制是加密密钥与解密密钥相同的密码体制(如数据加密标准DES和高级加密标准AES)。这种加密的保密性仅取决于对密钥的保密，而算法是公开的。 公钥密码体制(又称为公开密钥密码体制)使用不同的加密密钥与解密密钥。加密算法和解密算法也都是公开的。加密密钥(即公钥)是向公众公开的，而解密密钥(即私钥或秘钥)则是需要保密的。 目前最著名的公钥密码体制是RSA体制，它是基于数论中的大数分解问题的体制。任何加密方法的安全性取决于密钥的长度，以及攻破密文所需的计算量，而不是简单地取决于加密的体制(公钥密码体制或传统加密体制)。 数字签名必须保证能够实现以三点功能(1)报文鉴别，即接收者能够核实发送者对报文的签名(2)报文的完整性，即接收者确信所收到的数据完全和发送者发送的完全一样而没有被篡改过；(3)不可否认，即发送者事后不能抵赖对报文的签名。 鉴别是要验证通信的对方的确是自己所要通信的对象，而不是其他的冒充者。鉴别与授权是不同的概念。 密钥管理包括:密钥的产生、分配、注入、验证和使用。密钥分配(或密钥分发)是密钥管理中最大的问题。密钥必须通过最安全的通路进行分配。目前常用的密钥分配方式是设立密钥分配中心KDC。 认证中心CA是一个值得信赖的机构，用来将公钥与其对应的实体(人或机器)进行绑定。每个实体都有CA发来的证书，里面有公钥及其拥有者的标识信息(人名或IP地址)。此证书被CA进行了数字签名。任何用户都可从可信的地方获得认证中心CA的公钥。 在网络层可使用IPsec协议族，IPsec包括鉴别首部协议AH和封装安全有效载荷协议ESP。AH协议提供源点鉴别和数据完整性，但不能保密。而ESP协议提供源点鉴别、数据完整性和保密。IPsec 支持IPv4和IPV6。在IPv6中，AH和ESP都是扩展首部的一部分。IPsee 数据报的工作方式有运输方式和隧道方式两种。 运输层的安全协议有SSL (安全套接字层)和TLS (运输层安全)。SSL最新的版本是SSL 3.0， 它是保护万维网HTTP通信量所公认的事实上的标准。SSL不仅被所有常用的浏览器和万维网服务器所支持，而且也是TLS的基础。 PGP是一个完整的电子邮件安全软件包，包括加密、鉴别、电子签名和压缩等技术。PGP并没有使用什么新的概念，它只是把现有的一些加密算法(如RSA公钥加密算法或MDS报文摘要算法)综合在一起而已。 防火墙是种特殊编程的路由器，安装在一个网点和网络的其余部分之间，目的是实施访问控制策略。防火墙里面的网络称为“可信的网络”，而把防火墙外面的网络称为“不可信的网络”。防火墙的功能有两个:一个是阻止(主要的)，另一个是允许。 防火墙技术分为:网络级防火墙，用来防止整个网络出现外来非法的入侵(属于这类的有分组过滤和授权服务器)；应用级防火墙，用来进行访问控制(用应用网关或代理服务器来区分各种应用)。 入侵检测系统IDS是在入侵已经开始，但还没有造成危害或在造成更大危害前，及时检测到入侵，以便尽快阻止入侵，把危害降低到最小。 网络上的音视频服务 多媒体信息有两个重要特点:(1)多媒体信息的信息量往往很大1(2)在传输多媒体数据时，对时延和时延抖动均有较高的要求。在互联网上传输多媒体数据时，我们都是指含有“边传输、边播放”的特点。 由多媒体信息构成的分组在发送时是等时的。这些分组在到达接收端时就变成为非等时的。当接收端存中的分组数达到一定的数量后，再以恒定速率按顺序将这些分组进行还原播放。这样就产生了播放时延，同时也可以在很大程度上消除时延的抖动。 在传送时延敏感的实时数据时，传输时延和时延抖动都必须受到限。通常宁可丢失少量分组，也不要接收太晚到达的分组。 目前互联网提供的音频视频服务有三种类型:(1)流式存储音频视频，用户通过互联网边下载、边播放。(2)流式实况音/视频，其特点是在发送方边录例、边发送，在接收时也是要求能够述续播放。(3)交互式音频视频，如互联网电话或互联网电视会议。 流媒体( streaming media)就是流式音频/视频，其特点是边下载、边播放，但不能存储在硬盘上成为用户的文件。 媒体服务器(或称为流式服务器)可以更好地支持流式音频和视频的传送。TCP能够保证流式音频/视频文件的播放质量，但开始播放的时间要比请求播放的时间滞后一些(必须先在缓存中存储一定数量的分组)。对于实时流式音频视频文件的传送则应当选用UDP。 实时流式协议RTSP是为了给流式过程增加更多功能而设计的协议。RTSP本身并不传送数据，而仅仅是使媒体放器能够控制多媒体流的传送。RTSP又称为“互联网录像机遥控协议” 。 狭义的IP电话是指在IP网络上打电话。广义的IP电话则不仅是电话通信，而且还可以在IP网络上进行交互式多媒体实时通信(包括话音、视像等),甚至还包括即时传信IM(如QQ和ssyp等)。 IP电话的通话质量主要由两个因素决定:(1)通话双方端到端的时延和时延抖动；(2)话音分组的丢失率。但这两个因素都是不确定的，而是取决于当时网络上的通信量。 实时运输协议RTP为实时应用提供端到端的运输，但不提供任何服务质量的保证。需要发送的多媒体数据块(音频/视频)经过压缩编码处理后，先送给RTP封装成为RTP分组，装入运输层的UDP用户数据报后，再向下递交给IP层。可以把RTP看成是在UDP之上的一个运输层子层的协议。 实时运输控制协议RTCP是与RTP配合使用的协议。RTCP协议的主要功能是:服务质量的监视与反馈，媒体间的同步，以及多播组中成员的标志。RTCP分组也使用UDP来传送，但RTCP并不对音频视频分组进行封装。 现在IP电话有两套信令标准。一套是ITU-T定义的H323协议，另一套是ETF提出的会话发起协议SIP。 H323不是一个单独的协议而是一组协议。H323包括系统和构件的描述、呼叫模型的描述、呼叫信令过程、控制报文、复用、话音编解码器、视像编解码器，以及数据协议等。H323标准的四个构件是:(1)H323终端:(2)网关；(3)网间(4)多点控制单元MCU . 会话发起协议SIP只涉及到P电话所需的信令和有关服务质量的间题。SIP使用文本方式的客户服务器协议。SP系统只有两种构件，即用户代理(包括用户代理客户和用户代理服务器)和网络服务器(包括代理服务器和重定向服务器)。SIP的地址十分灵活，它可以是电话号码，也可以是电子邮件地址、IP地址或其他类型的地址。 服务质量QoS是服务性能的总效果，此效果决定了一个用户对服务的满意程度。因此，有服务质量的服务就是能够满足用户的应用需求的服务。或者说，可提供致的、可预计的数据交付服务。 服务质量可用若干基本的性能指标来描述，包括可用性、差错率、响应时间、吞吐量、分组丢失率、连接建立时间、故障检测和改正时间等。服务提供者可向其用户保证某一种等级的服务质量。 为了使互联网具有一定的服务质量，可采取以下一些措施:(1)分类，如区分服务；(2)管制；(3)调度；(4)呼叫接纳；(5)加权公平排队等。 综合服务 Intserv可对单个的应用会话提供服务质量的保证，它定义了两类服务，即有保证的服务和受控负載的服务。Intserv共有以下四个组成部分，即(1)资源预留协议RSVP；(2)接纳控制；(3)分类器；(4)调度器。 区分服务 Diffserv在路由器中增加区分服务的功能，把IP协议中原有的服务类型字段重新定义为区分服务DS，利用DS字段的不同数值提供不同等级的服务质量。Diffserv将所有的复杂性放在DS域的边界结点中，而使DS域内部路由器工作得尽可能地简单。Diffserv定义了在转发分组时体现服务水平的每跳行为PHB，包括EF和AF，即迅速转发PHB和确保转发PHB。 无线网络和移动网络 无线局域网可分为两大类。第一类是有固定基础设施的，第二类是无固定基础设施的 无线局域网的标准是IE的802.11系列。使用802.11系列协议的局域网又称为Wi-Fi。 802.11无线以太网标准使用星形拓扑，其中心叫做接入点AP，它就是基本服务集内的基站。 应当弄清几种不同的接入:固定接入、移动接入、便携接入和游牧接入。 802.11无线以太网在MAC层使用CSMA/CA协议。不能使用CSMA/CD的原因是:在无线局域网中，并非所有的站点都能够听见对方(例如，当有障碍物出现在站点之间时)，因此无法实现碰撞检测。使用 CSMA/CA协议是为了尽量减小碰撞发生的概率。 802.11无线局域网在使用 CSMA/CA的同时，还使用停止等待协议。 8021标准规定，所有的站在完成发送后，必须再等待一段帧间间隔时间才能发送下一帧。帧间间隔的长短取决于该站要发送的帧的优先级。 在802.11无线局域网的MAC帧首部中有一个持续期字段，用来填入在本帧结束后还要占用信道多少时间(以微秒为单位)。 802.11标准允许要发送数据的站对信道进行预约，即在发送数据帧之前先发送RTS帧请求发送。在收到响应允许发送的CTS帧后，就可发送数据帧。 802.1的MAC帧共有三种类型，即控制帧、数据帧和管理帧。需要注意的是，地址字段，即源地址、目的地址和AP地址。MAC帧有四个地址字段。在有固定基础设施的无线局域网中，只使用其中的三个 几种无线网络简介:无线个人区域网(蓝牙系统、 Zigbee和超高速WPAN)。无线城域网 WIMAX。 当计算机移动到外地时，移动IP技术允许该计算机仍然保留其原来的IP地址。移动IP使用了一些新概念，如永久地址、归属地址、归属网络、被访网络或外地网络、归属代理、外地代理、转交地址、同址转交地址等。 移动IP使用了几种协议，如移动站到外地代理的协议，外地代理到归属代理的登记协议，归属代理数据报封装协议，外地代理拆封协议等。 移动IP的路由选择有间接路由选择和直接路由选择，后者需要使用通信者代理和锚外地代理。 蜂窝移动通信网中对移动用户的路由选择需要弄清一些概念:归属位置寄存器HLR和来访用户位置寄存器VLR，移动站漫游号码MSRN，归属网络交换中心，归属MSC，锚MSC，被访网络的MSC。","categories":[{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/categories/读书/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/tags/读书/"}]}]}