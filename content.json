{"meta":{"title":"iDog的精神时光屋","subtitle":null,"description":"一个记录工作和生活的小地方。","author":"iDog","url":"https://bigporo.github.io","root":"/"},"pages":[{"title":"关于我","date":"2019-04-19T08:40:39.000Z","updated":"2020-06-21T08:47:58.000Z","comments":true,"path":"about/index.html","permalink":"https://bigporo.github.io/about/index.html","excerpt":"","text":"17年毕业于铜院。 目前就职于科大讯飞。 心无所向。 一个iOS开发。 喜观山海，喜食烟火。 年轻无为，卖码为生。"},{"title":"分类","date":"2019-04-22T01:59:17.000Z","updated":"2019-04-23T16:27:49.000Z","comments":true,"path":"categories/index.html","permalink":"https://bigporo.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-16T13:49:09.085Z","updated":"2019-04-19T08:35:22.000Z","comments":true,"path":"404.html","permalink":"https://bigporo.github.io/404.html","excerpt":"","text":"var QZONE = window.QZONE || {}; function imagezoom(imgobj, box_w, box_h) { var src_w = imgobj.width; var src_h = imgobj.height; var r1 = src_w / src_h, r2 = box_w / box_h; var dst_w, dst_h; if (r1 > r2) { dst_w = box_w; dst_h = Math.round(dst_w / src_w * src_h); } else { if (r1 < r2) { dst_h = box_h; dst_w = Math.round(dst_h / src_h * src_w); } else { dst_w = box_w; dst_h = box_h; } } imgobj.style.marginLeft = (box_w - dst_w) / 2 + \"px\"; imgobj.style.marginTop = (box_h - dst_h) / 2 + \"px\"; imgobj.style.width = dst_w + \"px\"; imgobj.style.height = dst_h + \"px\"; imgobj.style.opacity = 1; } (function(_w, _d) { var ha = _d.head || _d.getElementsByTagName(\"head\")[0]; var $scope = {}; var current; var tmnow; var chId; var homePageUrl, homePageName; var scs = document.getElementsByTagName(\"script\"); if (location.href.indexOf(\"fm.qq.com\") > -1 || location.href.indexOf(\"fm.qzone.qq.com\") > -1) { homePageName = \"\\u8fd4\\u56de\\u4f01\\u9e45FM\"; homePageUrl = \"http://fm.qq.com\"; } else { if (location.href.indexOf(\"qzone.qq.com\") > -1) { homePageName = \"\\u8fd4\\u56de\\u6211\\u7684\\u7a7a\\u95f4\"; homePageUrl = \"http://qzone.qq.com\"; } else { homePageName = \"\\u8fd4\\u56de\\u817e\\u8baf\\u7f51\"; homePageUrl = \"http://www.qq.com\"; } } for (var i = 0;i < scs.length;i++) { if (scs[i].src.indexOf(\"404/search_children.js\") > -1) { if (scs[i].getAttribute(\"homePageUrl\")) { homePageUrl = scs[i].getAttribute(\"homePageUrl\"); } if (scs[i].getAttribute(\"homePageName\")) { homePageName = scs[i].getAttribute(\"homePageName\"); } break; } } $scope.rettext = homePageName; $scope.retlink = homePageUrl; function getData(srcUrl, callback) { var sc = _d.createElement(\"script\"); function orc() { if (sc.readyState === \"loaded\") { setTimeout(function() { callback && callback(); }, 0); } } if (sc.addEventListener) { if (callback) { sc.addEventListener(\"load\", callback, false); } } else { sc.attachEvent(\"onreadystatechange\", orc); } ha && ha.appendChild(sc); sc.src = srcUrl; } function resolveData(d) { var tid, len, ddata = [], tdata; if (\"object\" == typeof d && (d.data && (len = d.data.length))) { for (var i = 0;i < len;i++) { var expire = d.data[i].expire; d.data[i]._id = new Date * Math.random() * Math.random() * 1E7; if (expire && tmnow * 1E3 < Date.parse(expire.replace(/\\s[\\s\\S]*$/, \"\").replace(/\\-/g, \"/\"))) { var _c = d.data[i].city, _p = d.data[i].province; if (_c && city) { if ((\"_\" + _c + \"_\").indexOf(\"_\" + city + \"_\") > -1) { ddata.push(d.data[i]); continue; } } if (_p && province) { if ((\"_\" + _p + \"_\").indexOf(\"_\" + province + \"_\") > -1) { ddata.push(d.data[i]); } } } } tid = Math.floor(Math.random() * (ddata.length || len)); tdata = (ddata.length ? ddata : d.data)[chId = tid]; if (_w.foundjsondata) { tdata.ta = tdata.sex.indexOf(\"\\u5973\") > -1 ? \"\\u5979\" : \"\\u4ed6\"; tdata.name = \"\\u201c7\\u00b718\\u7279\\u5927\\u62d0\\u5356\\u5a74\\u513f\\u6848\\u201d\\u544a\\u7834\\uff0c\\u88ab\\u89e3\\u6551\\u768415\\u540d\\u5b69\\u5b50\\u4e2d\\uff0c2\\u4eba\\u7531\\u4eb2\\u751f\\u7236\\u6bcd\\u9886\\u56de\\uff0c\\u4ecd\\u670913\\u540d\\u5b69\\u5b50\\u672a\\u627e\\u5230\\u4eb2\\u751f\\u7236\\u6bcd\\uff0c\\u88ab\\u5b89\\u7f6e\\u5728\\u60e0\\u5dde\\u5e02\\u793e\\u4f1a\\u798f\\u5229\\u9662\\uff0c\" + tdata.ta + \"\\u662f\\u5176\\u4e2d\\u4e4b\\u4e00\\u3002\"; tdata.url = tdata.url.replace(/#p=(\\d{1,2})/, function(a, n) { return \"#p=\" + (+n + 1); }); return format(tmpl2, tdata); } if (!tdata.ext1) { tdata.ext1 = \"\\u4f46\\u6211\\u4eec\\u53ef\\u4ee5\\u4e00\\u8d77\\u5bfb\\u627e\\u5931\\u8e2a\\u5b9d\\u8d1d\"; } return tdata; } } function setTopData(tdata) { current = tdata; $scope.topname = tdata.name; $scope.topgender = tdata.sex; $scope.topbirth = tdata.birth_time; $scope.toplostdate = tdata.lost_time; $scope.toplostplace = tdata.lost_place; $scope.toplostdesc = tdata.child_feature; $scope.toplink = tdata.url; $scope.topimg = tdata.child_pic; $scope.topid = tdata._id; document.body.innerHTML = template(\"body\", $scope); } function init(data) { tmnow = data.tm_now * 1E3; var tdata = resolveData(jsondata); $scope.whichin = 0; jsondata.data.splice(chId, 1); $scope.otherdata = [tdata].concat(jsondata.data.slice(0, 5)); setTopData(tdata); } var timeout; window._Callback = function(d) { clearTimeout(timeout); init(d); }; timeout = setTimeout(function() { _Callback({tm_now:(new Date).getTime() / 1E3}); }, 2E3); _w.share = function(target) { var summary = [\"\\u80cc\\u666f\\uff1a\", current.name, \"\\uff0c\\u6027\\u522b\\uff1a\", current.sex, \"\\uff0c\\u51fa\\u751f\\u65f6\\u95f4\\uff1a\", current.birth_time, \"\\uff0c\\u5931\\u8e2a\\u65f6\\u95f4\\uff1a\", current.lost_time, \"\\uff0c\\u7279\\u5f81\\u63cf\\u8ff0\\uff1a\", current.child_feature].join(\"\"); if (summary) { summary = \"#\\u5bfb\\u627e\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d#\" + summary; } var stitle = \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8be6\\u60c5\"; var desc = \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\"; var encode = encodeURIComponent; var opts = {\"surl\":\"http://qzone.qq.com/gy/404/\" + current.id + \"/lostchild.html\", \"site\":\"QQ\\u7a7a\\u95f4\", \"summary\":summary || \"#\\u5b9d\\u8d1d\\u56de\\u5bb6#\\u817e\\u8baf\\u5fd7\\u613f\\u8005\\u7528\\u6280\\u672f\\u70b9\\u4eae\\u516c\\u76ca\\uff0c\\u8ba9\\u6211\\u4eec\\u4e00\\u8d77\\u5bfb\\u627e\\u8d70\\u5931\\u7684\\u513f\\u7ae5\\u5427\\uff01\", \"stitle\":stitle, \"pics\":current.child_pic, \"desc\":desc, \"origin_url\":current.url}; var surl = opts.surl || \"http://www.qq.com/404/\", summary = opts.summary || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u7684\\u5185\\u5bb9\", stitle = opts.stitle || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u7684\\u6807\\u9898\", pics = opts.pics || \"http://qzonestyle.gtimg.cn/qzone_v6/act/img/20120422_qzone_7_years/pop_up/icon-pop-seven-years.png\", site = opts.site || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u94fe\\u63a5\\u7684\\u6587\\u5b57\", desc = opts.desc || \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\", origin_url = opts.origin_url || \"http://www.qq.com/404/\"; var shareList = {weibo:{method:function(evt) { var w = \"http://v.t.qq.com/share/share.php\", q = [\"?site=\", encode(surl + \"#via=share_t_weib\"), \"&title=\", encode(summary), \"&pic=\", encode(pics), \"&url=\", encode(surl)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"weibo\", \"width=700, height=680, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, location=yes, resizable=no, status=no\"); }}, qzone:{method:function(evt) { var buff = [], ps = {url:surl + \"#via=404-qzoneshare\", desc:desc || \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\", summary:summary, title:stitle, pics:pics, site:site}; for (var k in ps) { buff.push(k + \"=\" + encode(ps[k] || \"\")); } var w = \"http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?\" + buff.join(\"&\"), q = [\"#via=share_t_qzone\", \"&title=\", encode(summary), \"&pic=\", encode(pics), \"&url=\", encode(surl)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"qzone\", \"width=700, height=680, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, location=yes, resizable=no, status=no\"); }}, sina:{method:function() { var w = \"http://v.t.sina.com.cn/share/share.php\", q = [\"?url=\", encode(surl + \"#via=share_x_weib\"), \"&title=\", encode(summary), \"&source=\", \"&sourceUrl=\", surl, \"&content=utf-8\", \"&pic=\", encode(pics)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"sina\", \"toolbar=0,status=0,resizable=1,width=440,height=430\"); }}, kaixin:{method:function() { var n = \"http://www.kaixin001.com/repaste/bshare.php?rurl=\" + encode(surl + \"#via=share_kaixin\") + \"&rcontent=&rtitle=\" + encode(summary); openit(n, \"kaixin\", \"toolbar=0,status=0,resizable=1,width=600,height=360\"); }}, renren:{method:function() { var n = \"http://www.connect.renren.com/share/sharer?title=\" + encode(summary) + \"&url=\" + encode(surl + \"#via=share_renren\"), p = window.open(n, \"rr\", \"toolbar=0,status=0,resizable=1,width=510,height=300\"); if (p) { p.focus(); } }}, weixin:{method:function() { var n = \"http://qzone.qq.com/gy/404/page/qrcode.html?url=\" + encode(origin_url + \"#via=share_weixin\"), p = window.open(n, \"rr\", \"toolbar=0,status=0,resizable=1,width=620,height=430\"); if (p) { p.focus(); } }}}; var openit = function(u, n, p) { function o() { var z; if (!(z = window.open(u, n, p))) { location.href = u; } else { z.focus(); } } o(); }; shareList[target] && shareList[target].method(); }; _w.toThis = function(id) { for (var i = 0;i < $scope.otherdata.length;i++) { if ($scope.otherdata[i]._id == id) { setTopData($scope.otherdata[i]); break; } } return false; }; var meta = document.createElement(\"meta\"); meta.name = \"viewport\"; meta.content = \"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"; ha.appendChild(meta); (function registerStyle() { var link = document.createElement(\"link\"); link.rel = \"stylesheet\"; link.type = \"text/css\"; link.href = \"https://qzone.qq.com/gy/404/style/404style.css\"; ha.appendChild(link); })(); (function initStat() { var qqDomainNameRE = /\\.qq\\.com$/i, qzoneDomainNameRE = /\\bqzone\\.qq\\.com$/i, qzsDomainNameRE = /\\bqzonestyle\\.gtimg\\.cn$/i; function cb() { var url = location.host; var src = \"\"; if (qzoneDomainNameRE.test(url)) { src = \"new404.qzone\"; } else { if (qqDomainNameRE.test(url)) { src = \"new404.qq\"; } else { if (qzsDomainNameRE.test(url)) { src = \"new404.qzonestyle\"; } else { src = url.replace(\".\", \"_\"); } } } _w.TCISD && (_w.TCISD.pv && _w.TCISD.pv(\"hat.qzone.qq.com\", \"/gy/lostchild/\" + src)); } getData(\"https://qzonestyle.gtimg.cn/ac/qzfl/stat.js\", cb); })(); })(window, document); !function() { function a(a, b) { return(/string|function/.test(typeof b) ? h : g)(a, b); } function b(a, c) { return \"string\" != typeof a && (c = typeof a, \"number\" === c ? a += \"\" : a = \"function\" === c ? b(a.call(a)) : \"\"), a; } function c(a) { return l[a]; } function d(a) { return b(a).replace(/&(?![\\w#]+;)|[\"']/g, c); } function e(a, b) { if (m(a)) { for (var c = 0, d = a.length;d > c;c++) { b.call(a, a[c], c, a); } } else { for (c in a) { b.call(a, a[c], c); } } } function f(a, b) { var c = /(\\/)[^/]+\\1\\.\\.\\1/, d = (\"./\" + a).replace(/[^/]+$/, \"\"), e = d + b; for (e = e.replace(/\\/\\.\\//g, \"/\");e.match(c);) { e = e.replace(c, \"/\"); } return e; } function g(b, c) { var d = a.get(b) || i({filename:b, name:\"Render Error\", message:\"Template not found\"}); return c ? d(c) : d; } function h(a, b) { if (\"string\" == typeof b) { var c = b; b = function() { return new k(c); }; } var d = j[a] = function(c) { try { return new b(c, a) + \"\"; } catch (d) { return i(d)(); } }; return d.prototype = b.prototype = n, d.toString = function() { return b + \"\"; }, d; } function i(a) { var b = \"{Template Error}\", c = a.stack || \"\"; if (c) { c = c.split(\"\\n\").slice(0, 2).join(\"\\n\"); } else { for (var d in a) { c += \"\\n\" + a[d] + \"\\n\\n\"; } } return function() { return \"object\" == typeof console && console.error(b + \"\\n\\n\" + c), b; }; } var j = a.cache = {}, k = this.String, l = {\"\":\"&#62;\", '\"':\"&#34;\", \"'\":\"&#39;\", \"&\":\"&#38;\"}, m = Array.isArray || function(a) { return \"[object Array]\" === {}.toString.call(a); }, n = a.utils = {$helpers:{}, $include:function(a, b, c) { return a = f(c, a), g(a, b); }, $string:b, $escape:d, $each:e}, o = a.helpers = n.$helpers; a.get = function(a) { return j[a.replace(/^\\.\\//, \"\")]; }, a.helper = function(a, b) { o[a] = b; }, \"function\" == typeof define ? define(function() { return a; }) : \"undefined\" != typeof exports ? module.exports = a : this.template = a, a(\"body\", function(a) { var b = this, c = (b.$helpers, b.$escape), d = a.retlink, e = a.rettext, f = a.topid, g = a.topimg, h = a.topname, i = a.topgender, j = a.topbirth, l = a.toplostdate, m = a.toplostplace, n = a.toplostdesc, o = a.toplink, p = b.$each, q = a.otherdata, r = (a.otheritem, a.index, \"\"); return r += ' 404\\uff0c\\u60a8\\u8bbf\\u95ee\\u7684\\u9875\\u9762\\u627e\\u4e0d\\u56de\\u6765\\u4e86\\uff0c\\u4f46\\u6211\\u4eec\\u53ef\\u4ee5\\u4e00\\u8d77\\u5e2e\\u4ed6\\u4eec\\u56de\\u5bb6\\uff01 ', r += c(e), r += ' ', r += c(h), r += '(', r += c(i), r += ') \\u51fa\\u751f\\u65e5\\u671f\\uff1a', r += c(j), r += ' \\u5931\\u8e2a\\u65f6\\u95f4\\uff1a', r += c(l), r += ' \\u5931\\u8e2a\\u5730\\u70b9\\uff1a', r += c(m), r += ' \\u5931\\u8e2a\\u4eba\\u7279\\u5f81\\u63cf\\u8ff0\\uff1a', r += c(n), r += ' \\u67e5\\u770b\\u8be6\\u60c5 \\u5206\\u4eab \\u817e\\u8baf\\u5fae\\u535a QQ\\u7a7a\\u95f4 \\u65b0\\u6d6a\\u5fae\\u535a \\u5fae\\u4fe1 ', p(q, function(a) { r += ' '; }), r += \" \", new k(r); }); }(); L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"debug\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/hijiki.model.json\"},\"display\":{\"position\":\"right\",\"width\":150,\"height\":300},\"mobile\":{\"show\":true},\"react\":{\"opacity\":0.7},\"log\":false});"},{"title":"标签","date":"2019-04-22T01:58:24.000Z","updated":"2019-04-23T16:18:38.000Z","comments":true,"path":"tags/index.html","permalink":"https://bigporo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"iOS常用设计模式","slug":"iOS常用设计模式","date":"2022-11-06T01:26:25.000Z","updated":"2022-11-06T01:35:56.316Z","comments":true,"path":"2022/11/06/iOS常用设计模式/","link":"","permalink":"https://bigporo.github.io/2022/11/06/iOS常用设计模式/","excerpt":"基本原则 开闭原则（Open Close Principle） 对扩展打开，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。 里氏替换原则（Liskov Substitution Principle） 父子可以相互调用，父类必须提供足够多的抽象方法供子类重载使用。 任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。","text":"基本原则 开闭原则（Open Close Principle） 对扩展打开，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。 里氏替换原则（Liskov Substitution Principle） 父子可以相互调用，父类必须提供足够多的抽象方法供子类重载使用。 任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒转原则（Dependence Inversion Principle） 抽象不依赖细节，细节依赖抽象。这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 尽量做必要的事。使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 最少知道原则（Demeter Principle），迪米特法则 个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成/聚合复用 尽量使用合成/聚合的方式，而不是使用继承。 适配器模式 是什么？ 适配器模式作为两个不兼容的接口之间的桥梁，它将一个类的接口转换成客户端希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 适配器模式有时也称作为包装器 （Wapper)。适配器实现客户端所要的某种接口的行为。同时，它又连接到另一个具有（完全）不同接口与行为的对象。一边是客户端懂得如何使用的目标接口，另一边是客户端一无所知的被适配者，适配器处于两者之间。适配器的主要作用是把被适配者的行为传递给管道另一端的客户端。 怎么用？ 当你想使用一个已经存在的类，而它的接口不符合你的需求； 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作； 你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口，对象适配器可以适配它的父亲接口。 优缺点？ 优点：降低数据层和视图层（对象）的耦合度，使之使用更加广泛，适应复杂多变的变化。 缺点：降低了可读性，代码量增加，对于不理解这种模式的人来说比较难看懂。 类适配器通过继承来适配两个接口，这称为类适配器。在 Objective-C 可以通过实现接口或协议，同时继承父类来实现类适配。 Target 指目标接口。 Adaptee 指被适配者。 request意为请求行为。 Adapter 是一个 遵守了 &lt;Target&gt; 协议，同时也是一个 Adaptee 类型。Adapter 实现了 Target 的 request 方法。但是 Adapter没有重载 Adaptee 的 specficRequest方法，而是在 Adapter 的 request 方法中的实现中，调用父类 specficRequest方法。request 方法在运行时向父类发送 [super specficRequest] 消息。super 就是 Adaptee ，它的 Adapter 的 request 方法的作用域内，按自己的方式执行 specficRequest 方法。 只有当 Target是协议而不是类时，类适配器才能够用 Objective-C 来实现。协议的设计与适配器模式的描述并不完全匹配。但它实现了该模式的目标：允许具有其他不兼容接口的类一起工作。 代码实现： 假设现在有一个TypeC接口的设备 123456789@interface TypeCDevice: NSObject- (void)connectWithTypeC;@end@implementation TypeCDevice- (void)connectWithTypeC &#123; NSLog(@&quot;TypeC connect&quot;);&#125;@end 现在需要将MicroUSB数据线通过MicroUSBToTypeCAdapter连接TypeC接口的设备 1234567891011121314@protocol MicroUSBProtocol&lt;NSObject&gt;;@required- (void)connectWithMicroUSB;//声明适配方法@end@interface MicroUSBToTypeCAdapter : TypeCDevice&lt;MicroUSBProtocol&gt;;@end@implementation MicroUSBToTypeCAdapter- (void)connectWithMicroUSB &#123; NSLog(@&quot;MicroUSB convert To TypeC&quot;); [super connectWithTypeC];&#125;@end 对象适配器对象适配器不继承被适配者，而是组合了一个对它的引用。实现为对象适配器时，它们之间的关系为： Target和Adapter之间的关系与类适配器相同，而Adapter与Adaptee之间的关系从“属于”变成了“包含”。这种关系下，Adapter需要保持一个对Adaptee的引用。在request方法中，Adapter发送[adaptee specficRequest]消息给引用adaptee，以间接访问它的行为，然后实现客户端请求的其余部分。由于Adapter与Adaptee之间是一种“包含”关系，用Adapter去适配Adaptee的子类也没什么问题。 代码实现： 假设当前有一个&lt;MediaPlayer&gt;协议和一个遵守&lt;MediaPlayer&gt;的类AudioPlayer。默认情况下，AudioPlayer可以播放mp3格式的音频文件。 123456789101112@protocol MediaPlayer &lt;NSObject&gt;;- (void)play:(NSString *)audioType FileName:(NSString *)fileName;@end@interface AudioPlayer: NSObject&lt;MediaPlayer&gt;@end@implementation AudioPlayer- (void)play:(NSString *)audioType FileName:(NSString *)fileName &#123; NSLog(@&quot;Playing audio file. Name:%@&quot;,fileName);&#125;@end 还有一个&lt;AdvancedMediaPlayer&gt;协议，和实现了&lt;AdvancedMediaPlayer&gt;接口的实体类。 1234567891011121314151617181920212223@protocol AdvancedMediaPlayer &lt;NSObject&gt;@optional- (void)playVlc:(NSString *)fileName;- (void)playMp4:(NSString *)fileName;@end@interface VlcPlayer : NSObject&lt;AdvancedMediaPlayer&gt;@end@implementation VlcPlayer- (void)playVlc:(NSString *)fileName&#123; NSLog(@&quot;Playing vlc file. Name:%@&quot;,fileName);&#125;@end@interface Mp4Player : NSObject&lt;AdvancedMediaPlayer&gt;@end@implementation Mp4Player- (void)playMp4:(NSString *)fileName &#123; NSLog(@&quot;Playing mpf4 file. Name:%@&quot;,fileName);&#125;@end 为了让 AudioPlayer 支持播放其他格式的音频文件。需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 遵守了AdvancedMediaPlayer 协议的实例来播放所需的格式。 12345678910111213141516171819202122232425262728293031323334@interface MediaAdapter : NSObject &lt;MediaPlayer&gt;@property (nonatomic, week) id &lt;AdvancedMediaPlayer&gt; advancedMusicPlayer;- (instancetype)initWithAudioType:(NSString *)audioType;- (instancetype)init NS_UNAVAILABLE;@end@implementation MediaAdapter- (instancetype)initWithAudioType:(NSString *)audioType &#123; self = [super init]; if (self) &#123; if ([audioType isEqualToString:@&quot;vlc&quot;]) &#123; self.advancedMusicPlayer = [VlcPlayer new]; &#125; else if ([audioType isEqualToString:@&quot;mp4&quot;])&#123; self.advancedMusicPlayer = [Mp4Player new]; &#125; &#125; return self;&#125;- (void)play:(NSString *)audioType FileName:(NSString *)fileName &#123; if ([audioType isEqualToString:@&quot;vlc&quot;]) &#123; if ([self.advancedMusicPlayer respondsToSelector:@selector(playVlc:)]) &#123; [self.advancedMusicPlayer playVlc:fileName]; &#125; &#125; else if ([audioType isEqualToString:@&quot;mp4&quot;]) &#123; if ([self.advancedMusicPlayer respondsToSelector:@selector(playMp4:)]) &#123; [self.advancedMusicPlayer playMp4:fileName]; &#125; &#125;&#125;@end 策略模式 是什么？ 策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的对象而独立变化。 怎么用？ 在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。 比如：小孩和大人，小孩吃蔬菜，大人吃肉，小孩每天跑步一小时，大人每天跑步2小时。使用继承会导致代码复用性交叉。 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 一个系统需要动态地在几种算法中选择一种。 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 优缺点？ 优点：简化操作，提高代码维护性。算法可以自由切换，避免使用多重条件判断，扩展性良好。 缺点：在使用之前就要确定使用某种策略，而不是动态的选择策略。策略类会增多，所有策略类都需要对外暴露。 代码实现： 定义一个通用算法协议 123456@protocol PlayerProtocol &lt;NSObject&gt;@optional- (NSString *)play;- (NSString *)pause;- (NSString *)stop;@end APlayer的算法封装 1234567891011121314151617181920212223242526272829@interface APlayer : NSObject&lt;PlayerProtocol&gt;@property (nonatomic, week) id &lt;PlayerProtocol&gt; player;@end@implementation APlayer- (instancetype)init &#123; self = [super init]; if (self) &#123; player = [[APlayer alloc] init];// 初始化AVPlayer播放器对象 &#125; return self;&#125;// 播放- (NSString *)play&#123; return [player a_play];&#125;// 暂停- (NSString *)pause&#123; return [player a_pause];&#125;// 停止- (NSString *)stop&#123; return [player a_stop];&#125;@end BPlayer的算法封装 12345678910111213141516171819202122232425262728@interface BPlayer : NSObject&lt;PlayerProtocol&gt;@property (nonatomic, week) id &lt;PlayerProtocol&gt; player;@end@implementation BPlayer- (instancetype)init &#123; self = [super init]; if (self) &#123; player = [[BPlayer alloc] init];// 初始化AVPlayer播放器对象 &#125; return self;&#125;// 播放- (NSString *)play&#123; return [player b_play];&#125;// 暂停- (NSString *)pause&#123; return [player b_pause];&#125;// 停止- (NSString *)stop&#123; return [player b_stop];&#125;@end 通用播放器类CPlayer的定义。根据不同的策略选择不同的算法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 播放器的类型typedef enum : NSUInteger &#123; PlayerType_APlayer, PlayerType_BPlayer&#125; PlayerType;@interface CPlayer : NSObject- (instancetype)initWithType:(layerType)type;@property (nonatomic, week) id &lt;PlayerProtocol&gt; player;- (NSString *)play;- (NSString *)pause; - (NSString *)stop; @end@implementation Clayer- (instancetype)initWithType:(PlayerType)type &#123; self = [super init]; if (self) &#123; [self initPlayerWithType:type]; &#125; return self;&#125;// 初始化播放器- (void)initPlayerWithType:(PlayerType)type &#123; switch (type) &#123; case PlayerType_APlayer: &#123; player = [[AVPlayer alloc] init]; break; &#125; case PlayerType_BPlayer: &#123; player = [[BPlayer alloc] init]; break; &#125; &#125;&#125;//开启视频- (NSString *)play &#123; return [player play];&#125;//暂停视频- (NSString *)pause &#123; return [player pause];&#125;//停止播放- (NSString *)stop &#123; return [player stop];&#125;@end 观察者模式 是什么？ 本质上是一种发布-订阅模型，当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。如NSNotificationCenter、KVO。 怎么用？ 一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 优缺点？ 优点：观察者和被观察者是抽象耦合的。 缺点： 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 原型模式 是什么？ 用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。 怎么用？ 需要创建的对象不依赖于具体的类型以及创建方式 具体实例化的对象类型是在运行期决定的 不同类型之间的差异仅仅是状态的组合 类型创建复杂,例如类型有复杂的嵌套 很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。 优缺点 优点：性能提高 缺点：配备克隆方法需要对类的功能进行通盘考虑。逃避构造函数的约束。 代码实现： 1234567// Person 需要遵循并实现NSCopyingPerson *p1 = [[Person alloc] init];p1.name = @&quot;jack&quot;;p1.age = 10; Person * p2 = [p1 copy];p2.name = @&quot;rose&quot;; 外观模式 是什么？ 外观模式为子系统中一组不同的接口提供统一的接口。外观定义了上层接口，通过降低复杂度和隐藏子系统间的通信及依存关系，让子系统更易于使用。外观模式是面向对象编程里使用得很频繁的一个模式。最经常见到的例子就是各种库里的Manager类。比如SDWebImage。 怎么用？ 外部不需要知道系统内部的复杂联系，整个系统只需提供一个接口即可。 每个子系统层级有一个外观作为入口，让它们通过其外观进行通信，可以简化它们之间的依赖关系。 优缺点 优点：减少系统相互依赖、提高灵活性、提高了安全性 缺点：不符合开闭原则，由于没有很多的接口暴露，如果要改东西很麻烦，继承重写都不合适。 装饰模式 是什么？ 是指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。是继承的替代方案，属于结构型模式，它是作为现有的类的一个包装，比继承子类方式更灵活。 怎么用？ 抽象构件（Component）：定义一个抽象接口以规范准备接收附加责任的对象。 具体构件（ConcreteComponent）：继承抽象构件，通过装饰角色为其添加一些职责。 抽象装饰（Decorator）：持有抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。 具体装饰（ConcreteDecorator）：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。 优缺点 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 缺点：多层继承装饰比较复杂。 代码实现： 先定义抽象构件类Hero，通过方法blessBuff展示英雄此时所加持的buff 123456789@interface Hero : NSObject- (void)blessBuff;@end@implementation Hero- (void)blessBuff &#123; NSAssert(false, @&quot;must implement in subClass&quot;);&#125;@end 定义具体构件英雄盖伦Galen和Timo 123456789101112131415161718// Galen.h@interface Galen : Hero@end@implementation Galen- (void)blessBuff &#123; NSLog(@&quot;盖伦被动技能：脱离战斗后回血加快&quot;);&#125;@end@interface Timo : Hero@end@implementation Timo- (void)blessBuff &#123; NSLog(@&quot;提莫被动技能：脱离战斗后，静止不动一段时间进入隐身&quot;);&#125;@end 定义抽象装饰器BuffDecorator 1234567891011121314151617181920// 集成抽象构件@interface BuffDecorator : NSObject- (instancetype)initWithHero:(Hero *)hero;@property (nonatomic, strong) Hero *hero;@end@implementation BuffDecorator- (instancetype)initWithHero:(Hero *)hero &#123; self = [super init]; if (self) &#123; _hero = hero; &#125; return self;&#125;- (void)blessBuff &#123; [_hero blessBuff]; NSLog(@&quot;额外buff:&quot;);&#125;@end 定义具体装饰器红buff 12345678910// 集成抽象装饰器@interface RedBuffDecorator : BuffDecorator@end@implementation RedBuffDecorator- (void)blessBuff &#123; [super blessBuff]; NSLog(@&quot;红buff: 攻击附加真实伤害，并造成灼烧效果&quot;);&#125;@end 定义具体装饰器蓝buff 12345678910// 集成抽象装饰器@interface BlueBuffDecorator : BuffDecorator@end@implementation BlueBuffDecorator- (void)blessBuff &#123; [super blessBuff]; NSLog(@&quot;蓝buff: 蓝量回复速度加快，并且缩减技能CD&quot;);&#125;@end 使用 1234567891011Hero *galen = [Galen new];galen = [[RedBuffDecorator alloc] initWithHero:galen];[galen blessBuff];galen = [[BlueBuffDecorator alloc] initWithHero:galen];[galen blessBuff];NSLog(@&quot;----------------Timo----------------------&quot;);Hero *timo = [Timo new];timo = [[RedBuffDecorator alloc] initWithHero:timo];[timo blessBuff];timo = [[BlueBuffDecorator alloc] initWithHero:timo];[timo blessBuff]; 工厂模式 是什么？ 这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 怎么用？ 明确地计划不同条件下创建不同实例时。 作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 优缺点 优点：扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。屏蔽对象的具体实现，调用者只关心产品的接口。 缺点：在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。 简单工厂模式 当系统中只有唯一的产品时，可以省略抽象产品，工厂角色与具体产品可以合并。 工厂类只有一个，它集中了所有产品创建的逻辑，它将是整个系统的瓶颈，同时造成系统难以拓展。 简单工厂模式通常使用静态工厂方法，这使得工厂类无法由子类继承，这使得工厂角色无法形成基于继承的等级结构。 代码实现： 定义抽象产品类 12345678@interface Food : NSObject@property (nonatomic, copy)NSString *product;- (void)productBreakfast; @end@implementation Food- (void)productBreakfast&#123; &#125; 定义具体产品类 123456789101112131415@interface Milk : Food@end@implementation Milk- (void)productBreakfast&#123; _product = @&quot;牛奶&quot;;&#125;@interface Bread : Food@end@implementation Bread- (void)productBreakfast&#123; _product = @&quot;面包&quot;;&#125; 定义工厂类 123456789101112131415161718192021222324252627typedef NS_ENUM(NSInteger, FactoryProductType)&#123; FactoryProductTypeMilk, FactoryProductTypeBread,&#125;;@interface Factory : NSObject//工厂（Factory）角色：接受客户端的请求，通过请求负责创建相应的产品对象。+ (Food *)operationBreakfast:(FactoryProductType )breakfastType;@end@implementation SFFactory+ (Food *)operationBreakfast:(FactoryProductType)breakfastType &#123; //通过枚举返回不同的产品 Food *food; switch (breakfastType) &#123; case FactoryProductTypeMilk: food = [[Milk alloc] init]; break; case FactoryProductTypeBread: food = [[Bread alloc] init]; break; default: return nil; break; &#125; return food;&#125;@end 标准工厂模式在简单工厂模式的基础上，增加抽象工厂。共有如下四个角色： 抽象工厂角色：与应用程序无关，任何在模式中创建对象的工厂必须实现这个接口。 具体工厂角色：实现了抽象工厂接口的具体类，含有与引用密切相关的逻辑，并且受到应用程序的调用以创建产品对象。 抽象产品角色：工厂方法所创建产品对象的超类型，也就是产品对象的共同父类或共同拥有的接口。 具体产品角色：这个角色实现了抽象产品角色所声名的接口。工厂方法所创建的每个具体产品对象都是某个具体产品角色的实例。 抽象工厂模式 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 参与角色与标准工厂模式一样，不过抽象工厂不仅仅作为接口存在，而可以产生其他工厂。 代码实现： 定义抽象产品、具体产品和简单工厂一致 定义抽象工厂 123456789101112131415161718192021222324252627@interface Factory : NSObjecttypedef NS_ENUM(NSInteger, FactoryProductType) &#123; FactoryProductTypeMilk, FactoryProductTypeBread,&#125;;+ (instancetype)factoryWithType:(FactoryProductType)type;- (Food *)createProduct;@implementation AFFactory+ (instancetype)factoryWithType:(FactoryProductType)type &#123; Factory *factory; switch (type) &#123; case FactoryProductTypeMilk: factory = [[FactoryMilk alloc] init]; break; case FactoryProductTypeBread: factory = [[FactoryBread alloc] init]; break; default: break; &#125; return factory;&#125;- (Food *)createProduct &#123; return nil;&#125; 定义具体工厂 123456789101112131415@interface FactoryMilk : Factory@end@implementation FactoryMilk- (Food *)createProduct &#123; return [[Milk alloc] init];&#125;@end@interface FactoryBread : Factory@end@implementation FactoryBread- (Food *)createProduct &#123; return [[Bread alloc] init];&#125;@end 使用 123Factory *factory = [Factory factoryWithType:FactoryProductTypeMilk];Food *milk = [factory createProduct];[milk productBreakfast]; 总结从简单工厂模式到工厂模式，再到抽象工厂模式。可以看到整个模式的一步步演进。 简单工厂模式在产品多样之后，整个工厂将会变得臃肿而难以维护。于是将简单工厂模式中的工程做了抽象处理，这样每种产品对应一个工厂。这样无疑会增加代码量。但是好处是显而易见的，单独让一个工厂处理一种产品会让逻辑变得好维护。 但是这样还不够，因为增加新的品类，就会产生新的类，对于调用者来说，处理太多具有相同接口的类显然是不合算的。于是，我们使用抽象工厂模式来解决这个问题。我们让抽象工厂内部做一个封装，用以隐藏真正的具体工厂。这样，对于调用者来说，即时内部增加了新的产品，外部也是不知道的。 桥接模式 是什么？ 从针对不同的实现中，分离出其可被复用的抽象称为桥接模式。这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。比如遥控器和电视机。 Abstraction 是定义了供客户端使用的上层抽象接口的父接口。它有一个对 Implementor 实例的引用，Implementor 定义了实现类的接口。这个接口不必跟 Abstraction 的接口一致。Implementor 的接口提供基本操作，而 Abstraction 的上层操作基于这些基本操作。当客户端向 Abstraction 的实例发送 operation 消息时，这个方法向 imp 发送 operationImp 消息。实际的 ConcreteImplementator 将作出响应并接收任务。 怎么用？ 不想在抽象与其实现之间形成固定的绑定关系 抽象及其实现都应可以通过子类独立化进行扩展 对抽象的实现进行修改不应影响客户端代码 如果每个实现需要额外的子类以细化抽象，则说明有必要把它们分成两个部分 想在带有不同抽象接口的多个对象之前共享一个实现。 优缺点？ 优点：抽象和实现的分离、优秀的扩展能力、实现细节对客户透明。 缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 代码实现： 定义实现类 123456789101112131415typedef NS_ENUM(NSUInteger, EcommandType) &#123; kUp, kDown, kLeft, kRight,&#125;;@interface AbstractImplementor : NSObject- (void)loadCommand:(EcommandType)command;@end@implementation AbstractImplementor- (void)loadCommand:(EcommandType)command &#123;&#125;@end 定义抽象类，并建立桥接 123456789101112131415161718192021222324252627282930@interface AbstractSystem : NSObject// 建立桥接@property (nonatomic, strong) AbstractImplementor *implementor;//上下左右 把调用实现类方法的桥接行为包装起来- (void)command_up;- (void)command_down;- (void)command_left;- (void)command_right;@end@implementation AbstractSystem- (void)command_up &#123; [self.implementor loadCommand:kUp];&#125;- (void)command_down &#123; [self.implementor loadCommand:kDown];&#125;- (void)command_left &#123; [self.implementor loadCommand:kLeft];&#125;- (void)command_right &#123; [self.implementor loadCommand:kRight];&#125;- (void)loadSystem &#123;&#125; 创建实现类的子类PSPImplementor 123456789101112131415161718192021222324@interface PSPImplementor : AbstractImplementor@end@implementation PSPImplementor- (void)loadCommand:(EcommandType)command &#123; switch (command) &#123; case kUp: NSLog(@&quot;PSP up&quot;); break; case kDown: NSLog(@&quot;PSP down&quot;); break; case kLeft: NSLog(@&quot;PSP left&quot;); break; case kRight: NSLog(@&quot;PSP right&quot;); break; default: NSLog(@&quot;PSP None&quot;); break; &#125;&#125;@end 创建抽象类的子类PSPSystem 12345678910111213141516@interface PSPSystem : AbstractSystem- (void)command_up;- (void)command_down;@end@implementation PSPSystem- (void)command_up &#123; [self.implementor loadCommand:kUp];&#125;- (void)command_down &#123; [self.implementor loadCommand:kDown];&#125;@end 使用 123PSPSystem *pspSystem = [[PSPSystem alloc] init];pspSystem.implementor = [[PSPImplementor alloc] init];[pspSystem command_up]; 代理模式 是什么？ 为其他对象提供一种代理可以控制对这个对象的访问。 怎么用？ 通俗讲一个例子，同学A给同学B送东西，但是同学A临时有事去不了，这时同学A需要找了另外同学C帮他去送东西，我们就说C是A的代理，送东西这件事就是他们之间的协议。 协议：用来指定代理双方要做什么事情（送东西） 代理：根据指定的协议，完成协议规定的事情（同学C） 委托：根据指定的协议，指定代理去完成的事情（同学A） 优缺点？ 优点：职责清晰、高扩展性。 缺点：实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 在iOS中对象是不支持多继承的，而协议可以多继承。1234// 当前协议继承了三个协议，这样其他三个协议中的方法列表都会被继承过来@protocol LoginProtocol &lt;UITableViewDataSource, UITableViewDelegate, UITextFieldDelegate&gt;- (void)userLoginWithUsername:(NSString *)username password:(NSString *)password;@end 单例模式 是什么？ 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。如UIApplication、NSNotificationCenter、NSFileManager。 怎么用？ 需要控制实例对象数目，节省系统资源。 优缺点？ 优点：在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。避免了对资源的多重占用比如写文件操作。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 代码实现：12345678910111213141516// 初始化static Myclass _instance;static dispatch_once_t onceToken;+ (id)shareInstance &#123; dispatch_once(&amp;onceToken, ^&#123; if(_instance == nil) _instance = [MyClass alloc] init]; &#125;); return _instance;&#125;// 销毁+ (void)dealloc &#123; onceToken = 0; _instance = nil;&#125; 备忘录模式 是什么？ 在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。备忘录模式总共需要三种对象 保存对象（即备忘录） 使用对象 管理备忘录对象 怎么用？ 功能比较复杂的，但是需要维护或记录属性历史的类。 需要保存的属性只是众多属性的一小部分时。一般而言，运用备忘录的思想很多，完整的运用备忘录模式的很少。 优缺点？ 优点：提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。实现了信息的封装，使得用户不需要关心状态的保存细节。 缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。 代码实现： 定义备忘录 123@interface Memo : NSObject@property (nonatomic, assign) NSInteger age;@property (nonatomic, assign) NSInteger height; 定义需要备份的抽象类 123456789101112131415161718192021@class Memo;@interface User : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger age;@property (nonatomic, assign) NSInteger height;- (Memo *)saveState;- (void)recoverStateFromMemo:(Memo *)memo;@implementation User- (Memo *)saveState &#123; Memo *m = [Memo new]; m.age = _age; m.height = _height; return m;&#125;- (void)recoverStateFromMemo:(Memo *)memo &#123; _age = memo.age; _height = memo.height;&#125;@end 使用 123456789101112User *user = [User new];user.name = @&quot;Bob&quot;;user.age = 18;user.height = 168;NSMutableArray *memoArray = [NSMutableArray array];for (int i=0; i&lt;10; i++) &#123; [memoArray addObject:[user saveState]]; user.age += 1; user.height += 0.8;&#125;/// 恢复到23岁时候的状态[user recoverStateFromMemo:memoArray[5]]; 生成器模式/建造者模式 是什么？ 将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表现。其整体思想是分离“什么”与“如何”。将复杂对象的构建过程分解为客户-指导者-生成器（client-director-builder）的关系。这样将更容易管理和复用整个过程。 Builder 抽象建造者类 为创建一个Product对象的各个部件指定抽象接口。 ConcreteBuilder 建造者类 实现Builder的接口以构造和装配该产品的各个部件。 定义并明确它所创建的表示。 提供一个检索产品的接口 Director 导向器类 构造一个使用Builder接口的对象。 Product 产品类 表示被构造的复杂对象。ConcreateBuilder创建该产品的内部表示并定义它的装配过程。 包含定义组成部件的类，包括将这些部件装配成最终产品的接口。 怎么用？ 需要创建设计各种部件的复杂对象。创建对象的算法应该独立于部件的装配方式。常见于构建组合对象。 构建过程需要以不同的方式（例如，部件或表现的不同组合）构建对象。 优缺点？ 优点：扩展性、封装性强 缺点：产品必须有共同点，范围有限制。如内部变化复杂，会有很多的建造类。 代码实现： 定义Product 1234567@interface Car : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, copy) NSString *price;@end@implementation Car@end 定义Builder 123456789101112131415@interface CarBuilder : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, copy) NSString *price;-(Car *)makeCar;@end@implementation CarBuilder- (Car *)makeCar &#123; Car *car = [[Car alloc] init]; car.name = self.name; car.price = self.price; return car;&#125;@end 定义两个ConcreteBuilder 12345678910111213@interface BMWCar : BuilderCar@end@implementation BMWCar- (instancetype)init &#123; self = [super init]; if (self) &#123; self.name = @&quot;BMW M5&quot;; self.price = @&quot;80万&quot;; &#125; return self;&#125;@end 12345678910111213@interface AudiCar : BuilderCar@end@implementation AudiCar- (instancetype)init &#123; self = [super init]; if (self) &#123; self.name = @&quot;Audi RS7&quot;; self.price = @&quot;120万&quot;; &#125; return self;&#125;@end 定义Director 12345678910@interface Director : NSObject+ (Car *)creatBuickCar:(BuilderCar *)builder;@end@implementation Director+ (Car *)creatBuickCar:(BuilderCar *)builder &#123; Car *car = [builder makeCar]; return car;&#125;@end 使用 12BuilderCar *car = [[BMWCar alloc] init];Director *dir = [Director creatBuickCar:car]; 与工厂模式的区别 建造者模式与工厂模式是极为相似的，总体上，建造者模式仅仅只比工厂模式多了一个”导演类”的角色。 在建造者模式的类图中，假如把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看作是一个简单的工厂模式了。 与工厂模式相比，建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类——导演类。 工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品； 建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。 命令模式 是什么？ 命令模式主要把请求对象封装成一个命令进行传递，由命令者和接受者组成。 怎么用？ 在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。 优缺点？ 优点：降低了系统耦合度，新的命令可以很容易添加到系统中去。 缺点：可能会导致某些系统有过多的具体命令类。 代码实现： 放大缩小红色视图 定义Receiver 123456789101112131415@interface Receiver : NSObject@property (assign, nonatomic) CGFloat width;@property (strong, nonatomic) UIView * redView;- (void)amplifyView:(CGFloat)pamameter;- (void)reduceView:(CGFloat)pamameter;@end@implementation Receiver- (void)amplifyView:(CGFloat)pamameter &#123;&#125;-(void)reduceView:(CGFloat)pamameter&#123;&#125;@end 定义抽象命令类Command 123456@protocol CommandProtocol &lt;NSObject&gt;/// 执行命令- (void)excute;/// 撤销命令- (void)backExcute;@end 定义命令类ConcreteCommand 123456789101112131415161718192021222324252627282930@interface AmplifyCommand : NSObject&lt;CommandProtocol&gt;// 绑定接收器- (instancetype)initWithReceiver:(Receiver *)receiver paramter:(CGFloat)paramter;@end@interface AmplifyCommand()@property (nonatomic, strong) Receiver *receiver;@property (nonatomic, assign) CGFloat paramter;@end@implementation AmplifyCommand- (instancetype)initWithReceiver:(Receiver *)receiver paramter:(CGFloat)paramter&#123; self = [super init]; if (self) &#123; self.receiver = receiver; self.paramter = paramter; &#125; return self;&#125;// 执行命令- (void)excute &#123; [self.receiver amplifyView:self.paramter];&#125;// 撤销命令- (void)backExcute &#123; [self.receiver reduceView:self.paramter];&#125;@end 定义调用者Invoker 123456789101112131415161718192021222324252627282930313233343536373839404142@interface Invoker : NSObject+ (instancetype)sharedInstance;// 回退指令- (void)rollBack;// 添加操作指令- (void)addAndExcute:(id &lt;CommandProtocol&gt;)command;@end@interface Invoker()@property (nonatomic, strong) NSMutableArray *mArr; //存储操作指令的数组@end@implementation Invoker+ (instancetype)sharedInstance &#123; static dispatch_once_t onceToken; static Invoker *cls = nil; dispatch_once(&amp;onceToken, ^&#123; cls = [[[self class] alloc] init]; cls.mArr = [[NSMutableArray alloc]init]; &#125;); return cls;&#125;- (void)rollBack &#123; // 1.获取数组中的最后一个操作 id &lt;CommandProtocol&gt; command = self.mArr.lastObject; // 2.操作调用,撤销的步骤 [command backExcute]; // 3.删除最后操作 [self.mArr removeLastObject];&#125;// 添加操作指令- (void)addAndExcute:(id &lt;CommandProtocol&gt;)command &#123; // 1.把操作添加到数组 [self.mArr addObject:command]; // 2.让操作调用实现的协议方法 [command excute];&#125;@end 使用 12345678/// 初始化接收者Receiver *receiver = [[Receiver alloc]init];receiver.redView = [UIView new];receiver.width = 50;/// 初始化命令并绑定接收者AmplifyCommand *command = [[AmplifyCommand alloc]initWithReceiver:receiver paramter:10];/// 执行命令[[Invoker sharedInstance] addAndExcute:command]; 组合模式/部分整体模式 是什么？ 组合模式描述了一组对象，它们的处理方式与相同类型对象的单个实例相同。组合的目的是将对象“组合”成树结构以表示部分-整体层次结构,实现让客户统一对待单个对象和组合。 为部分Leaf对象和整体Composite对象定义统一的 Component 接口。 单个 Leaf 对象直接实现 Component 接口，Composite 对象将请求转发给它们的子组件 这使客户端能够通过 Component 接口统一处理 Leaf 和 Composite 对象,Leaf 对象直接执行请求,Composite对象将请求向下递归转发到它们的子组件。这使得客户端类更易于实现、更改、测试和重用。 怎么用？ 应该表示部分-整体层次结构，以便客户端可以统一处理部分和整体对象 部分-整体层次结构应表示为树结构。 用在部分、整体场景，如树形菜单，文件、文件夹的管理。 优缺点： 优点：高层模块调用简单、节点自由增加。 缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。 代码实现： 定义Component 12345678910111213141516171819202122// 也可以用代理实现@interface Component : NSObject &#123; NSString *name; &#125;- (Component *)MyInit:(NSString *)myName;- (void)add:(Component *)c;- (void)remove:(Component *)c;-(void)display:(int)depth;@end@implementation Component- (Component *)MyInit:(NSString *)myName &#123; name = myName; return self;&#125;- (void)add:(Component *)c &#123;&#125;- (void)remove:(Component *)c &#123;&#125;- (void)display:(int)depth &#123;&#125;@end 定义Leaf 12345678910111213141516171819@interface Leaf : Components- (Leaf *)MyInit:(NSString *)myName;@end @implementation Leaf- (Leaf *)MyInit:(NSString *)myName &#123; name = myName; return self;&#125;- (void)add:(Components *)c &#123; NSLog(@&quot;Can not add a leaf&quot;);&#125;- (void)remove:(Components *)c &#123; NSLog(@&quot;Can not remove from a leaf&quot;);&#125;- (void)display:(int)depth &#123; NSLog(@&quot;[%dLevel]%@&quot;,depth,name);&#125;@end 定义Composite 1234567891011121314151617181920212223242526272829@interface Composite : Components &#123; NSMutableArray *childrenArr;&#125;- (Composite *)MyInit:(NSString *)myName;@end@implementation Composite- (Composite *)MyInit:(NSString *)myName &#123; name = myName; childrenArr = [NSMutableArray new]; return self;&#125;- (void)add:(Components *)c &#123; [childrenArr addObject:c];&#125;- (void)remove:(Components *)c &#123; [childrenArr removeObject:c];&#125;- (void)display:(int)depth &#123; NSLog(@&quot;[%dLevel]%@&quot;,depth,name); for(ComComponents *component in childrenArr) &#123; [component Display:depth+1]; &#125;&#125;@end 使用 123456789101112131415Composite *root = [[Composite alloc] MyInit:@&quot;root&quot;];[root Add:[[Leaf alloc] MyInit:@&quot;Leaf A&quot;]];[root Add:[[Leaf alloc] MyInit:@&quot;Leaf B&quot;]];Composite *comp = [[Composite alloc] MyInit:@&quot;Composite X&quot;];[comp Add:[[Leaf alloc]MyInit:@&quot;Leaf XA&quot;]];[comp Add:[[Leaf alloc]MyInit:@&quot;Leaf XB&quot;]];[root Add:comp]; // 添加到根节点Composite *comp2 = [[Composite alloc] MyInit:@&quot;Composite XY&quot;];[comp2 Add:[[Leaf alloc] MyInit:@&quot;Leaf XYA&quot;]];[comp2 Add:[[Leaf alloc] MyInit:@&quot;Leaf XYB&quot;]];[comp Add:comp2];[root Add:[[Leaf alloc] MyInit:@&quot;Leaf C&quot;]];","categories":[{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/categories/读书/"}],"tags":[]},{"title":"iOS核心动画高级技巧-读书笔记","slug":"iOS核心动画高级技巧-读书笔记","date":"2022-09-15T03:00:43.000Z","updated":"2022-11-06T01:25:58.361Z","comments":true,"path":"2022/09/15/iOS核心动画高级技巧-读书笔记/","link":"","permalink":"https://bigporo.github.io/2022/09/15/iOS核心动画高级技巧-读书笔记/","excerpt":"","text":"图层树UIView和CALayer的关系CALayer类在概念上和UIView类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。 它们有一些方法和属性用来做动画和变换。和UIView最大的不同是CALayer不处理用户的交互。但是它提供了一些方法来判断是否一个触点在图层的范围之内。 每一个UIView都有一个CALayer实例的图层属性，也就是所谓的backing layer，视图的职责就是创建并管理这个图层。 这些背后关联的图层才是真正用来在屏幕上显示和做动画，UIView仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。 CALayer的能力有一些UIView没有暴露出来的CALayer的功能： 阴影，圆角，带颜色的边框 3D变换 非矩形范围 透明遮罩 多级非线性动画 寄宿图contentsCALayer 有一个属性叫做contents，虽然是id类型，但是如果赋值不止CGImage,图层就会是空白的。 所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。 事实上，真正要赋值的类型应该是CGImageRef，它是一个指向CGImage结构的指针。UIImage有一个CGImage属性，它返回一个”CGImageRef“,如果你想把这个值直接赋值给CALayer的contents，那你将会得到一个编译错误。因为CGImageRef并不是一个真正的Cocoa对象，而是一个Core Foundation类型。 1layer.contents = (__bridge id)image.CGImage; 其他属性： contentGravity：设置拉伸方式，对应UIView的contentMode contentsScale：定义寄宿图的像素尺寸和试图大小的比例，默认为1.0，一般设置为[UIScreen mainScreen].scale; 12345layerView.layer.contentsGravity = .centerlayerView.layer.contentsScale = UIScreen.main.scale // 相当于上面两行layerView.layer.contentsGravity = .resizeAspect maskToBounds：是否绘制超过边界的内容,对应UIView的clipsToBounds; contentsRect:在图层边框里面显示寄宿图的子区域，使用单位坐标,默认为{0, 0, 1, 1} 该属性可用于图片拼合，可以打包真核一张大图一次性载入，相比多次载入不同的图片，在内存使用、载入时间、渲染性能能会有更好表现 12345func addSpriteImage(img:UIImage, rect:CGRect, superLayer:CALayer) &#123; superLayer.contents = img.cgImage superLayer.contentsGravity = .resizeAspect superLayer.contentsRect = rect&#125; contentsCenter：定义了一个固定的边框和一个在图层上可拉伸的区域，默认为{0, 0, 1, 1},类似resizableImageWithCapInsets Custom Drawing可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现-drawRect:方法来自定义绘制。 -drawRect: 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，。如果UIView检测到-drawRect: 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 contentsScale的值。 如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费 当视图在屏幕上出现的时候 -drawRect:方法就会被自动调用。-drawRect:方法里面的代码利用Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来直到它需要被更新（通常是因为开发者调用了-setNeedsDisplay方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如bounds属性）。虽然-drawRect:方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。 CALayer有一个可选的delegate属性，实现了CALayerDelegate协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。 当需要被重绘时，CALayer会请求它的代理给他一个寄宿图来显示。它通过调用下面这个方法做到的: 1open func display() 代理想直接设置contents属性的话，它就可以这么做，不然没有别的方法可以调用了。如果代理不实现-displayLayer:方法，CALayer就会转而尝试调用下面这个方法： 1func draw(_ layer: CALayer, in ctx: CGContext); CALayer创建了一个合适尺寸的空寄宿图（尺寸由bounds和contentsScale决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，他作为ctx参数传入。 1234567891011121314151617181920212223242526class CustomDrawingController: UIViewController, CALayerDelegate &#123; override func viewDidLoad() &#123; super.viewDidLoad() self.view.backgroundColor = .white let layerView = UIView.init(frame: CGRect(x: 100, y: 100, width: 200, height: 200)) layerView.backgroundColor = .white layerView.center = self.view.center self.view.addSubview(layerView) let blueLayer = CALayer.init() blueLayer.frame = layerView.bounds blueLayer.backgroundColor = UIColor.blue.cgColor blueLayer.delegate = self layerView.layer.addSublayer(blueLayer) blueLayer.display() // 需要手动display &#125; func draw(_ layer: CALayer, in ctx: CGContext) &#123; ctx.setLineWidth(10.0) ctx.setStrokeColor(UIColor.red.cgColor) ctx.strokeEllipse(in: layer.bounds) &#125;&#125; 需要在blueLayer上显式调用-display,当图层显示在屏幕上时，CALayer不会自动重绘它的内容 当使用CALayerDelegate绘制寄宿图的时候，并没有对超出边界外的内容提供绘制支持。 图层几何学布局UIView有三个比较重要的布局属性：frame，bounds和center，CALayer对应地叫做frame，bounds和position。为了能清楚区分，图层用了“position”，视图用了“center”，但是他们都代表同样的值。 UIView的frame，bounds和center属性仅仅是存取方法，当操纵视图的frame，实际上是在改变位于视图下方CALayer的frame，不能够独立于图层之外改变视图的frame。 frame代表了图层在父图层上占据的空间，bounds是内部坐标（{0, 0}通常是图层的左上角）center和position都代表了相对于父图层anchorPoint所在的位置。 当对图层做变换的时候，比如旋转或者缩放，frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说frame的宽高可能和bounds的宽高不再一致了。 锚点anchorPoint默认位于图层中点，所以图层的将会以这个点为中心放置。这也是视图的position属性被叫做“center”的原因。 anchorPoint使用单位坐标，默认{0.5,0.5}。 但是图层的anchorPoint可以被移动，比如可以把它置于图层frame的左上角，于是图层的内容将会向右下角的position方向移动，而不是居中了。 坐标系一个图层的position依赖于它父图层的bounds，如果父图层发生了移动，它的所有子图层也会跟着移动。 CALayer给不同坐标系之间的图层转换提供了一些工具类方法： 1234- (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer;- (CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer;- (CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;- (CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer; 翻转的几何结构常规说来，在iOS上，一个图层的position位于父图层的左上角，但是在Mac OS上，通常是位于左下角。Core Animation可以通过geometryFlipped属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个BOOL类型。在iOS上通过设置它为YES意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部（它的所有子图层也同理，除非把它们的geometryFlipped属性也设为YES）。 Z坐标轴CALayer有另外两个属性，zPosition和anchorPointZ，二者都是在Z轴上描述图层位置的浮点类型。 通常，图层是根据它们子图层的sublayers出现的顺序来类绘制的,后被绘制上的图层将会遮盖住之前的图层，但是通过增加图层的zPosition，就可以把图层前置，于是它就在所有其他图层的前面了（或者至少是小于它的zPosition值的图层的前面）。 Hit TestingCALayer并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法可以处理事件：-containsPoint:和-hitTest:。 -containsPoint:接受一个在本图层坐标系下的CGPoint，如果这个点在图层frame范围内就返回YES。 -hitTest:方法同样接受一个CGPoint类型参数，而不是BOOL类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。 注意当调用图层的-hitTest:方法时，返回的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。之前提到的zPosition属性可以明显改变屏幕上图层的顺序，但不能改变事件传递的顺序。 自动布局如果想随意控制CALayer的布局，就需要手工操作。最简单的方法就是使用CALayerDelegate如下函数： 1- (void)layoutSublayersOfLayer:(CALayer *)layer; 当图层的bounds发生改变，或者图层的-setNeedsLayout方法被调用的时候，这个函数将会被执行。可以手动地重新摆放或者重新调整子图层的大小，但是不能像UIView的autoresizingMask和constraints属性做到自适应屏幕旋转。 视觉效果阴影 shadowOpacity：是一个必须在0.0（不可见）和1.0（完全不透明）之间的浮点数。如果设置为1.0，将会显示一个有轻微模糊的黑色阴影稍微在图层之上。 shadowOffset：控制着阴影的方向和距离。它是一个CGSize的值，宽度控制这阴影横向的位移，高度控制着纵向的位移。shadowOffset的默认值是 {0, -3}，意即阴影相对于Y轴有3个点的向上位移。 shadowRadius：控制着阴影的模糊度，当它的值是0的时候，阴影就和视图一样有一个非常确定的边界线。当值越来越大的时候，边界线看上去就会越来越模糊和自然。 shadowPath：实时计算阴影也是一个非常消耗资源的，指定一个shadowPath来提高性能 阴影裁剪：阴影是根据寄宿图的轮廓来确定的，而不是根据边界和角半径来确定。 shouldRasterize：如果它被设置为YES，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了。 变换仿射变换主要是2D变换，主要API： 12345CGAffineTransformMakeRotation(CGFloat angle) //旋转CGAffineTransformMakeScale(CGFloat sx, CGFloat sy) // 缩放CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty) // 位移CGAffineTransformIdentity // 空值CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2); // 混合两个变换 3D变换123CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z)CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz) CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz) X轴和Y轴分别以右和下为正方向（这是iOS上的标准结构，在Mac OS，Y轴朝上为正方向），Z轴和这两个轴分别垂直，指向视角外为正方向。 旋转方向确定：左手点赞，大拇指朝向箭头方向，握手指的方向即为旋转方向 透视投影&lt;重点&gt;CATransform3D的透视效果通过一个矩阵中一个很简单的元素来控制：m34。m34用于按比例缩放X和Y的值来计算到底要离视角多远。 m34的默认值是0，可以通过设置m34为-1.0 /d来应用透视效果，d代表了想象中视角相机和屏幕之间的距离，以像素为单位，不需要精细计算，通常500-1000就已经很好了，但对于特定的图层有时候更小后者更大的值会看起来更舒服，减少距离的值会增强透视效果，所以一个非常微小的值会让它看起来更加失真，然而一个非常大的值会让它基本失去透视效果。 解决了图层看起来并没有被旋转，而是仅仅在水平方向上的一个压缩。 12345678//create a new transformCATransform3D transform = CATransform3DIdentity;//apply perspectivetransform.m34 = - 1.0 / 500.0;//rotate by 45 degrees along the Y axistransform = CATransform3DRotate(transform, M_PI_4, 0, 1, 0);//apply to layerself.layerView.layer.transform = transform; 灭点&lt;重点&gt;当在透视角度绘图的时候，远离相机视角的物体将会变小变远，当远离到一个极限距离，它们可能就缩成了一个点，于是所有的物体最后都汇聚消失在同一个点。 为了在应用中创建拟真效果的透视，这个点应该聚在屏幕中点，或者至少是包含所有3D对象的视图中点。 Core Animation定义了这个点位于变换图层的anchorPoint（通常位于图层中心，但也有例外）。这就是说，当图层发生变换时，这个点永远位于图层变换之前anchorPoint的位置。 当改变一个图层的position，也改变了它的灭点，做3D变换的时候要时刻记住这一点，当视图通过调整m34来让它更加有3D效果，应该首先把它放置于屏幕中央，然后通过平移来把它移动到指定位置（而不是直接改变它的position），这样所有的3D图层都共享一个灭点。 sublayerTransform 属性&lt;重点&gt;sublayerTransform是CATransform3D类型，但和对一个图层的变换不同，它影响到所有的子图层。这意味着可以一次性对包含这些图层的容器做变换，于是所有的子图层都自动继承了这个变换方法。 用于解决有多个视图或者图层，每个都做3D变换，那就需要分别设置相同的m34值，并且确保在变换之前都在屏幕中央共享同一个position。 灭点被设置在容器图层的中点，从而不需要再对子图层分别设置了。这意味着你可以随意使用position和frame来放置子图层，而不需要把它们放置在屏幕中点，然后为了保证统一的灭点用变换来做平移。 背面图层是双面绘制的，反面显示的是正面的一个镜像图片。 但这并不是一个很好的特性，因为如果图层包含文本或者其他控件，那用户看到这些内容的镜像图片当然会感到困惑。另外也有可能造成资源的浪费：想象用这些图层形成一个不透明的固态立方体，既然永远都看不见这些图层的背面，那为什么浪费GPU来绘制它们呢？ CALayer有一个叫做doubleSided的属性来控制图层的背面是否要被绘制。这是一个BOOL类型，默认为YES，如果设置为NO，那么当图层正面从相机视角消失的时候，它将不会被绘制。 扁平化图层由于尽管Core Animation图层存在于3D空间之内，但它们并不都存在同一个3D空间。每个图层的3D场景其实是扁平化的，从正面观察一个图层，看到的实际上由子图层创建的想象出来的3D场景，但当倾斜这个图层，实际上这个3D场景仅仅是被绘制在图层的表面。 当在玩一个3D游戏，实际上仅仅是把屏幕做了一次倾斜，或许在游戏中可以看见有一面墙在你面前，但是倾斜屏幕并不能够看见墙里面的东西。所有场景里面绘制的东西并不会随着观察它的角度改变而发生变化；图层也是同样的道理。 固体对象用六个独立的视图来构建一个立方体的各个面，不需要不关心在这个容器中如何摆放它们的位置，因为后续将会用图层的transform对它们进行重新布局。 如果需要动态地创建光线效果，可以根据每个视图的方向应用不同的alpha值做出半透明的阴影图层，但为了计算阴影图层的不透明度，需要得到每个面的正太向量（垂直于表面的向量），然后根据一个想象的光源计算出两个向量叉乘结果。叉乘代表了光源和图层之间的角度，从而决定了它有多大程度上的光亮。 专用图层CAShapeLayerCAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。指定诸如颜色和线宽等属性，用CGPath来定义想要绘制的图形，最后CAShapeLayer就自动渲染出来了。也可以用Core Graphics直接向原始的CALyer的内容中绘制一个路径，使用CAShapeLayer有以下一些优点： 渲染快速。CAShapeLayer使用了硬件加速，绘制同一图形会比用Core Graphics快很多。 高效使用内存。一个CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。 不会被图层边界剪裁掉。一个CAShapeLayer可以在边界之外绘制。你的图层路径不会像在使用Core Graphics的普通CALayer一样被剪裁掉。 不会出现像素化。当你给CAShapeLayer做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化。 CATextLayerCATextLayer它以图层的形式包含了UILabel几乎所有的绘制特性，并且额外提供了一些新的特性。 123456789101112131415161718192021222324252627282930let containerView = UIView()containerView.frame = CGRect(x: 0, y: 0, width: height: 300)containerView.center = self.view.centercontainerView.backgroundColor = .whiteself.view.addSubview(containerView)let textLayer = CATextLayer()textLayer.frame = containerView.boundscontainerView.layer.addSublayer(textLayer)textLayer.foregroundColor = UIColor.orange.cgColortextLayer.alignmentMoCATextLayerAlignmentMode.justifiedtextLayer.isWrapped = true// 设置字体let font = UIFont.systemFont(ofSize: 15)let cgFont = CGFont(font.fontName as CFString)!textLayer.font = cgFonttextLayer.fontSize = font.pointSizelet text = \"Lorem ipsum dolor sit amet, consectadipiscing elit. Quisque massa arcu, eleifend vel vain, facilisis pulvinar leo. Nunc quis nunc at mapharetra condimentum ut ac neque. Nunc elementum, liut porttitor dictum, diam odio congue lacus, fringilla sapien diam at purus. Etiam suscipit prenunc sit amet lobortis\"textLayer.string = texttextLayer.contentsScale = UIScreen.main.scale; CATransformLayerCore Animation图层可以在2D环境下做出这样的层级体系下的变换，但是3D情况下就不太可能，因为所有的图层都把他的子图层都平面化到一个场景中。 CATransformLayer解决了这个问题，CATransformLayer不同于普通的CALayer，因为它不能显示它自己的内容。只有当存在了一个能作用域子图层的变换它才真正存在。CATransformLayer并不平面化它的子图层，所以它能够用于构造一个层级的3D结构， 12345678910111213141516171819202122232425262728let cube = CATransformLayer() // face 1var ct = CATransform3DIdentitycube.addSublayer(self.faceWithTransform(transform: ct))// face 2ct = CATransform3DMakeTranslation(50, 0, 0)ct = CATransform3DRotate(ct, Double.pi/2, 0, 1, 0) cube.addSublayer(self.faceWithTransform(transform: ct))// face 3ct = CATransform3DMakeTranslation(0, -50, 0)ct = CATransform3DRotate(ct, Double.pi/2, 1, 0, 0)cube.addSublayer(self.faceWithTransform(transform: ct))// face 4ct = CATransform3DMakeTranslation(0, 50, 0)ct = CATransform3DRotate(ct, -Double.pi/2, 1, 0, 0)cube.addSublayer(self.faceWithTransform(transform: ct))// face 5ct = CATransform3DMakeTranslation(-50, 0, 0)ct = CATransform3DRotate(ct, -Double.pi/2, 0, 1, 0)cube.addSublayer(self.faceWithTransform(transform: ct))// face 6ct = CATransform3DMakeTranslation(0, 0, -50)ct = CATransform3DRotate(ct, Double.pi, 0, 1, 0)cube.addSublayer(self.faceWithTransform(transform: ct))let containerSize = containerView.boundscube.position = CGPoint(x: containerSize.width/2.0, y: containerSize.height/2.0)cube.transform = transform CAGradientLayerCAGradientLayer是用来生成两种或更多颜色平滑渐变的,真正好处在于绘制使用了硬件加速。 startPoint和endPoint：决定了渐变的方向。这两个参数是以单位坐标系进行的定义，所以左上角坐标是{0, 0}，右下角坐标是{1, 1}。 locations：调整颜色空间，需要和colors长度相同 1234567let gradientLayer = CAGradientLayer()gradientLayer.frame = containerView.boundsgradientLayer.colorUIColor.random().cgColor,UIColor.random().cgColor,UICrandom().cgColor]gradientLayer.startPoint = CGPoint(x: 0, y: 0)gradientLayer.endPoint = CGPoint(x: 1, y: 1)gradientLayer.locations = [NSNumber(val.1),NSNumber(value: 0.3),NSNumber(value: 0.8)]containerView.layer.addSublayer(gradientLayer) CAReplicatorLayerCAReplicatorLayer的目的是为了高效生成许多相似的图层。它会绘制一个或多个图层的子图层，并在每个复制体上应用不同的变换。 CAReplicatorlayer真正应用到实际程序上的场景比如：一个游戏中导弹的轨迹云，或者粒子爆炸。还有一个实际的用处反射。 1234567891011121314151617181920let replicator = CAReplicatorLayer()replicator.frame = containerView.boundscontainerView.layer.addSublayer(replicator)// 重复次数replicator.instanceCount = 15var transform = CATransform3DIdentitytransform = CATransform3DTranslate(transform, 0, 200, 0)transform = CATransform3DRotate(transform, Double.pi/50, 1)transform = CATransform3DTranslate(transform, 0, -200, 0)replicator.instanceTransform = transform// 改变颜色通道实现变换颜色replicator.instanceBlueOffset = -0.1replicator.instanceGreenOffset = -0.1// 添加子图层 作为内容let subLayer = CALayer()subLayer.frame = CGRect(x: 100, y: 100, width: height: 100)subLayer.backgroundColor = UIColor.white.cgColorreplicator.addSublayer(subLayer) 12345678910111213141516171819202122232425/**反射：需要添加自视图作为内容*/class ReflectionView: UIView &#123; override class var layerClass: AnyClass &#123; return CAReplicatorLayer.self &#125; override init(frame: CGRect) &#123; super.init(frame: frame) setup() &#125; required init?(coder: NSCoder) &#123; fatalError(\"init(coder:) has not been implemented\") &#125; func setup() &#123; guard let layer = self.layer as? CAReplicatorLayer elseeturn &#125; layer.instanceCount = 2 // 重复两次 var transform = CATransform3DIdentity let offset = self.bounds.size.width transform = CATransform3DTranslate(transform, offset, 0) transform = CATransform3DScale(transform, -1, 1, 0) layer.instanceTransform = transform layer.instanceAlphaOffset = -0.5 // 透明度 &#125;&#125; CAScrollLayerCAScrollLayer可以显示一个大图层里面的一小部分，通过-scrollToPoint:可以实现支持滑动。 Core Animation并不处理用户输入，所以CAScrollLayer并不负责将触摸事件转换为滑动事件，既不渲染滚动条，也不实现任何iOS指定行为例如滑动反弹。 主要是下面两个方法： -scrollToPoint:从图层树中查找并找到第一个可用的CAScrollLayer，然后滑动它使得指定点成为可视的。 -scrollRectToVisible:：实现了同样的事情只不过是作用在一个矩形上的。visibleRect属性决定图层（如果存在的话）的哪部分是当前的可视区域。 1234567891011121314151617181920212223242526272829/*用CAScrollLayer作为视图的宿主图层，并创建一个自定义的UIView，然后用UIPanGestureRecognizer实现触摸事件响应*/class ScrollView: UIView &#123; override class var layerClass: AnyClass &#123; return CAScrollLayer.self &#125; override init(frame: CGRect) &#123; super.init(frame: frame) setup() &#125; required init?(coder: NSCoder) &#123; fatalError(\"init(coder:) has not been implemented\") &#125; func setup() &#123; self.layer.masksToBounds = true let pan = UIPanGestureRecognizer(target: self, action: #selector(pan)) self.addGestureRecognizer(pan) &#125; @objc func pan(recognizer:UIPanGestureRecognizer) &#123; var offset = self.bounds.origin offset.x -= recognizer.translation(in: self).x offset.y -= recognizer.translation(in: self).y self.layer.scroll(offset) recognizer.setTranslation(CGPoint.zero, in: self) &#125;&#125; 滑动视图类并没有实现任何形式的边界检查（bounds checking）。图层内容极有可能滑出视图的边界并无限滑下去。 CAScrollLayer并没有等同于UIScrollView中contentSize的属性，所以当CAScrollLayer滑动的时候完全没有一个全局的可滑动区域的概念，也无法自适应它的边界原点至你指定的值。它之所以不能自适应边界大小是因为它不需要，内容完全可以超过边界。 CATiledLayer在渲染大内存图片会遇到以下问题： UIImage的-imageNamed:方法或者-imageWithContentsOfFile:方法）将会阻塞用户界面，至少会引起动画卡顿现象。 OpenGL有一个最大的纹理尺寸（通常是2048x2048，或4096x4096，这个取决于设备型号）。如果在单个纹理中显示一个比这大的图，即便图片已经存在于内存中了，仍然会遇到很大的性能问题，因为Core Animation强制用CPU处理图片而不是更快的GPU。 CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。 1234567let tileLayer = CATiledLayer()tileLayer.frame = CGRect(x: 0, y: 0, width: 2048, height: 2048)tileLayer.delegate = selftileLayer.contentsScale = UIScreen.main.scalescrollView.layer.addSublayer(tileLayer)scrollView.contentSize = tileLayer.frame.sizetileLayer.display() 1234567891011121314let layer = layer as! CATiledLayerlet bounds = ctx.boundingBoxOfClipPathlet x = Int(bounds.origin.x / layer.tileSize.width)let y = Int(bounds.origin.y / layer.tileSize.height)let index = x * (y + 1)print(\"x:\\(x)--y:\\(y)\")guard let imgPath = Bundle.main.path(forResource: \"202287155129659img_snowman_2048x2048_\\(index)\", ofType: \"jpeg\") else &#123;return &#125;guard let img = UIImage(contentsOfFile: imgPath) else &#123; return &#125;UIGraphicsPushContext(ctx)img.draw(in: bounds)UIGraphicsPopContext() CAEmitterLayerCAEmitterLayer是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果。 CAEmitterLayer看上去像是许多CAEmitterCell的容器，这些CAEmitierCell定义了一个粒子效果。你将会为不同的例子效果定义一个或多个CAEmitterCell作为模版，同时CAEmitterLayer负责基于这些模版实例化一个粒子流。一个CAEmitterCell类似于一个CALayer：它有一个contents属性可以定义为一个CGImage，另外还有一些可设置属性控制着表现和行为。 12345678910111213141516let emitter = CAEmitterLayer()emitter.frame = containerView.boundscontainerView.layer.addSublayer(emitter)emitter.renderMode = CAEmitterLayerRenderMode.unordered // 粒子混合方式emitter.emitterPosition = CGPoint(xemitter.frame.size.width/2, yemitter.frame.size.height/2)// 添加 Celllet cell = CAEmitterCell()cell.contents = UIImage.init(named:\"icon_start\")?.cgImagecell.birthRate = 100 // 生成速度cell.lifetime = 5.0cell.color = UIColor.random().cgColorcell.alphaSpeed = -0.4 // 透明度衰减速度cell.velocity = 50cell.velocityRange = 50cell.emissionRange = Double.pi * 2.0 // 粒子发射角度emitter.emitterCells = [cell] CAEAGLLayerOpenGL提供了Core Animation的基础，它是底层的C接口，直接和iPhone，iPad的硬件通信，极少地抽象出来的方法。OpenGL没有对象或是图层的继承概念。它只是简单地处理三角形。OpenGL中所有东西都是3D空间中有颜色和纹理的三角形。 为了能够以高性能使用Core Animation，需要判断你需要绘制哪种内容（矢量图形，例子，文本，等等），但后选择合适的图层去呈现这些内容，Core Animation中只有一些类型的内容是被高度优化的；所以如果绘制的东西并不能找到标准的图层类，高性能就很难实现。 因为OpenGL根本不会对内容进行假设，所以很多游戏都喜欢用OpenGL（这些情况下，Core Animation的限制就明显了：它优化过的内容类型并不一定能满足需求），但是这样依赖，方便的高度抽象接口就没了。 在iOS 5中，苹果引入了一个新的框架叫做GLKit，它去掉了一些设置OpenGL的复杂性，提供了一个叫做CLKView的UIView的子类，帮助处理大部分的设置和绘制工作。前提是各种各样的OpenGL绘图缓冲的底层可配置项仍然需要用CAEAGLLayer完成，它是CALayer的一个子类，用来显示任意的OpenGL图形。 AVPlayerLayerAVPlayerLayer的使用相当简单：你可以用+playerLayerWithPlayer:方法创建一个已经绑定了视频播放器的图层，或者你可以先创建一个图层，然后用player属性绑定一个AVPlayer实例。因为AVPlayerLayer是CALayer的子类，它继承了父类的所有特性。并不会受限于要在一个矩形中播放视频,可以增加圆角、边框甚至3D变换。 隐式动画事务Core Animation基于一个假设，说屏幕上的任何东西都可以（或者可能）做动画。动画并不需要在Core Animation中手动打开，相反需要明确地关闭，否则他会一直存在。 所谓的隐式动画指并没有指定任何动画的类型。仅仅改变了一个属性，然后Core Animation来决定如何并且何时去做动画。 但当改变一个属性，Core Animation是如何判断动画类型和持续时间的呢？实际上动画执行的时间取决于当前事务的设置，动画类型取决于图层行为。 事务实际上是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦提交的时候开始用一个动画过渡到新值。 事务是通过CATransaction类来做管理，这个类的设计有些奇怪，不像你从它的命名预期的那样去管理一个简单的事务，而是管理了一叠你不能访问的事务。CATransaction没有属性或者实例方法，并且也不能用+alloc和-init方法创建它。但是可以用+begin和+commit分别来入栈或者出栈。 任何可以做动画的图层属性都会被添加到栈顶的事务，可以通过+setAnimationDuration:方法设置当前事务的动画时间，或者通过+animationDuration方法来获取值（默认0.25秒）。 Core Animation在每个run loop周期中自动开始一次新的事务，即使不显式的用[CATransaction begin]开始一次事务，任何在一次run loop循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。 CATransaction的+begin和+commit方法在+animateWithDuration:animations:内部自动调用，这样block中所有属性的改变都会被事务所包含。这样也可以避免开发者由于对+begin和+commit匹配的失误造成的风险。 完成回调基于UIView的block的动画允许你在动画结束的时候提供一个完成的动作。CATranscation接口提供的+setCompletionBlock:方法也有同样的功能。 12345678CATransaction.begin()CATransaction.setAnimationDuration(1.2)CATransaction.setCompletionBlock &#123; let transform = CGAffineTransform(rotationAngle: Double.pi) self.colorLayer.setAffineTransform(transform)&#125;colorLayer.backgroundColor = UIColor.random().cgColorCATransaction.commit() 注意旋转动画要比颜色渐变快得多，这是因为完成块是在颜色渐变的事务提交并出栈之后才被执行，于是，用默认的事务做变换，默认的时间也就变成了0.25秒。 隐式动画实现&lt;重要&gt; Core Animation通常对CALayer的所有属性（可动画的属性）做动画，但是UIView把它关联的图层的这个特性关闭了。 把改变属性时CALayer自动应用的动画称作行为，当CALayer的属性被修改时候，它会调用-actionForKey:方法，传递属性的名称。剩下的操作都在CALayer的头文件中有详细的说明，实质上是如下几步： 图层首先检测它是否有委托，并且是否实现CALayerDelegate协议指定的-actionForLayer:forKey方法。如果有，直接调用并返回结果。 如果没有委托，或者委托没有实现-actionForLayer:forKey方法，图层接着检查包含属性名称对应行为映射的actions字典。 如果actions字典没有包含对应的属性，那么图层接着在它的style字典接着搜索属性名。 最后，如果在style里面也找不到对应的行为，那么图层将会直接调用定义了每个属性的标准行为的-defaultActionForKey:方法。 所以一轮完整的搜索结束之后，-actionForKey:要么返回空（这种情况下将不会有动画发生），要么是CAAction协议对应的对象，最后CALayer拿这个结果去对先前和当前的值做动画。 于是这就解释了UIKit是如何禁用隐式动画的：每个UIView对它关联的图层都扮演了一个委托，并且提供了-actionForLayer:forKey的实现方法。当不在一个动画块的实现中，UIView对所有图层行为返回nil，但是在动画block范围之内，它就返回了一个非空值。 当属性在动画块之外发生改变，UIView直接通过返回nil来禁用隐式动画。但如果在动画块范围之内，根据动画具体类型返回相应的属性。 返回nil并不是禁用隐式动画唯一的办法，CATransacition有个方法叫做+setDisableActions:，可以用来对所有属性打开或者关闭隐式动画。如果在[CATransaction begin]之后添加下面的代码，同样也会阻止动画的发生： CATransaction.setDisableActions(true) UIView关联的图层禁用了隐式动画，对这种图层做动画的唯一办法就是使用UIView的动画函数（而不是依赖CATransaction），或者继承UIView，并覆盖-actionForLayer:forKey:方法，或者直接创建一个显式动画。 对于单独存在的图层，可以通过实现图层的-actionForLayer:forKey:委托方法，或者提供一个actions字典来控制隐式动画。 自定义隐式动画： 12345let transition = CATransition.init()transition.type = CATransitionType.pushtransition.subtype = CATransitionSubtype.fromRightcolorLayer.actions = [\"backgroundColor\":transition] 呈现与模型CALayer的属性行为其实很不正常，因为改变一个图层的属性并没有立刻生效，而是通过一段时间渐变更新。 当设置CALayer的属性，实际上是在定义当前事务结束之后图层如何显示的模型。Core Animation扮演了一个控制器的角色，并且负责根据图层行为和事务设置去不断更新视图的这些属性在屏幕上的状态。 CALayer是一个连接用户界面（就是MVC中的view）虚构的类，但是在界面本身这个场景下，CALayer的行为更像是存储了视图如何显示和动画的数据模型。 在iOS中，屏幕每秒钟重绘60次。如果动画时长比60分之一秒要长，Core Animation就需要在设置一次新值和新值生效之间，对屏幕上的图层进行重新组织。这意味着CALayer除了“真实”值（就是你设置的值）之外，必须要知道当前显示在屏幕上的属性值的记录。 每个图层属性的显示值都被存储在一个叫做呈现图层的独立图层当中，他可以通过-presentationLayer方法来访问。这个呈现图层实际上是模型图层的复制，但是它的属性值代表了在任何指定时刻当前外观效果。 呈现树通过图层树中所有图层的呈现图层所形成。注意呈现图层仅仅当图层首次被提交（就是首次第一次在屏幕上显示）的时候创建，所以在那之前调用-presentationLayer将会返回nil。 有一个叫做–modelLayer的方法。在呈现图层上调用–modelLayer将会返回它正在呈现所依赖的CALayer。通常在一个图层上调用-modelLayer会返回–self（实际上已经创建的原始图层就是一种数据模型）。 大多数情况下，不需要直接访问呈现图层，你可以通过和模型图层的交互，来让Core Animation更新显示。两种情况下呈现图层会变得很有用，一个是同步动画，一个是处理用户交互。 如果实现一个基于定时器的动画，而不仅仅是基于事务的动画，这个时候准确地知道在某一时刻图层显示在什么位置就会对正确摆放图层很有用了。 如果想让做动画的图层响应用户输入，你可以使用-hitTest:方法来判断指定图层是否被触摸，这时候对呈现图层而不是模型图层调用-hitTest:会显得更有意义，因为呈现图层代表了用户当前看到的图层位置，而不是当前动画结束之后的位置。 1234567891011override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; guard let point = touches.first?.location(in: self.view) else &#123; return &#125; if ((colorLayer.presentation()?.hitTest(point)) != nil) &#123; colorLayer.backgroundColor = UIColor.random().cgColor &#125; else &#123; CATransaction.begin() CATransaction.setAnimationDuration(2.0) colorLayer.position = point CATransaction.commit() &#125;&#125; 显式动画&#x20;属性动画当更新属性的时候，我们需要设置一个新的事务，并且禁用图层行为。否则动画会发生两次，一个是因为显式的CABasicAnimation，另一次是因为隐式动画。 1234567891011121314@objc func basicAnimation() &#123; let animation = CABasicAnimation() animation.keyPath = \"backgroundColor\" animation.toValue = UIColor.random().cgColor animation.delegate = self colorLayer.add(animation, forKey: nibName)&#125;private func animationDidStop(_ anim: CABasicAnimation, finished flag: Bool) &#123; CATransaction.begin() CATransaction.setDisableActions(true) // 关闭隐式动画 防止多次动画 colorLayer.backgroundColor = anim.toValue as! CGColor? CATransaction.commit()&#125; 对CAAnimation而言，使用委托模式而不是一个完成块会带来一个问题，就是当有多个动画的时候，无法在在回调方法中区分。 动画本身会作为一个参数传入委托的方法，也许可以控制器中把动画存储为一个属性，然后在回调用比较，但实际上并不起作用，因为委托传入的动画参数是原始值的一个深拷贝，从而不是同一个值。 像所有的NSObject子类一样，CAAnimation实现了KVC（键-值-编码）协议，可以用-setValue:forKey:和-valueForKey:方法来存取属性。但是CAAnimation有一个不同的性能：它更像一个NSDictionary，可以随意设置键值对，即使使用的动画类所声明的属性并不匹配。这意味着你可以对动画用任意类型打标签。 在-animationDidStop:finished:委托方法调用之前，指针会迅速返回到原始值,可以用一个fillMode属性来解决这个问题。 关键帧动画CAKeyframeAnimation同样是CAPropertyAnimation的一个子类，它依然作用于单一的一个属性，但是和CABasicAnimation不一样的是，它不限制于设置一个起始和结束的值，而是可以根据一连串随意的值来做动画。 1234567@objc func keyframeAnimation() &#123; let animation = CAKeyframeAnimation() animation.keyPath = \"backgroundColor\" animation.duration = 2 animation.values = [UIColor.random().cgColor,UIColor.random().cgColor,UIColor.random().cgColor,UIColor.blue.cgColor] colorLayer.add(animation, forKey: nil)&#125; 注意到序列中开始和结束的颜色都是蓝色，这是因为CAKeyframeAnimation并不能自动把当前值作为第一帧（就像CABasicAnimation那样把fromValue设为nil）。动画会在开始的时候突然跳转到第一帧的值，然后在动画结束的时候突然恢复到原始的值。所以为了动画的平滑特性，需要开始和结束的关键帧来匹配当前属性的值。 当然可以创建一个结束和开始值不同的动画，那样的话就需要在动画启动之前手动更新属性和最后一帧的值保持一致，就和之前讨论的一样。 通过贝塞尔曲线对图层做动画： 1234567891011121314151617181920212223242526272829// 贝塞尔曲线动画func configAnimationPath() &#123; let bezierPath = UIBezierPath() bezierPath.move(to: CGPoint(x: 0, y: 150)) bezierPath.addCurve(to: CGPoint(x: 300, y: 150), controlPoint1: CGPoint(x: 75, y: 0), controlPoint2: CGPoint(x: 225, y: 300)) let pathLayer = CAShapeLayer() pathLayer.path = bezierPath.cgPath pathLayer.fillColor = UIColor.clear.cgColor pathLayer.strokeColor = UIColor.random().cgColor pathLayer.lineWidth = 3.0 self.view.layer.addSublayer(pathLayer) let snowmanLayer = CALayer() snowmanLayer.frame = CGRect(x: 0, y: 0, width: 50, height: 50) guard let imgPath = Bundle.main.path(forResource: \"img_snow_man\", ofType: \"jpeg\") else &#123; return &#125; let img = UIImage(contentsOfFile: imgPath) snowmanLayer.contents = img!.cgImage; self.view.layer.addSublayer(snowmanLayer) let animation = CAKeyframeAnimation() animation.keyPath = \"position\" animation.duration = 4.0 animation.path = bezierPath.cgPath animation.rotationMode = CAAnimationRotationMode.rotateAuto; // 调整旋转方向 snowmanLayer.add(animation, forKey: nibName)&#125; 虚拟属性属性动画实际上是针对于关键路径而不是一个键，这就意味着可以对子属性甚至是虚拟属性做动画。 考虑一个旋转的动画：如果想要对一个物体做旋转的动画，那就需要作用于transform属性，因为CALayer没有显式提供角度或者方向之类的属性。 为了旋转图层，我们可以对transform.rotation关键路径应用动画，而不是transform本身。 用transform.rotation而不是transform做动画的好处如下： 可以不通过关键帧一步旋转多于180度的动画。 可以用相对值而不是绝对值旋转（设置byValue而不是toValue）。 可以不用创建CATransform3D，而是使用一个简单的数值来指定角度。 不会和transform.position或者transform.scale冲突（同样是使用关键路径来做独立的动画属性）。 transform.rotation属性有一个奇怪的问题是它其实并不存在。这是因为CATransform3D并不是一个对象，它实际上是一个结构体，也没有符合KVC相关属性，transform.rotation实际上是一个CALayer用于处理动画变换的虚拟属性。 不可以直接设置transform.rotation或者transform.scale，他们不能被直接使用。当你对他们做动画时，Core Animation自动地根据通过CAValueFunction来计算的值来更新transform属性。 动画组CAAnimationGroup是另一个继承于CAAnimation的子类，它添加了一个animations数组的属性，用来组合别的动画。 1234let groupAnimation = CAAnimationGroup()groupAnimation.animations = [animation,animation]groupAnimation.duration = 4.0colorLayer.add(groupAnimation, forKey: nibName) 过渡属性动画只对图层的可动画属性起作用，所以如果要改变一个不能动画的属性（比如图片），或者从层级关系中添加或者移除图层，属性动画将不起作用。 过渡并不像属性动画那样平滑地在两个值之间做动画，而是影响到整个图层的变化。过渡动画首先展示之前的图层外观，然后通过一个交换过渡到新的外观。 为了创建一个过渡动画，我们将使用CATransition，同样是另一个CAAnimation的子类，和别的子类不同，CATransition有一个type和subtype来标识变换效果。type属性是一个NSString类型，可以被设置成如下类型： kCATransitionFade kCATransitionMoveIn kCATransitionPush kCATransitionReveal 后面三种过渡类型都有一个默认的动画方向，它们都从左侧滑入，但是你可以通过subtype来控制它们的方向，提供了如下四种类型： kCATransitionFromRight kCATransitionFromLeft kCATransitionFromTop kCATransitionFromBottom 对图层树的动画CATransition并不作用于指定的图层属性，就是可以在即使不能准确得知改变了什么的情况下对图层做动画，例如，在不知道UITableView哪一行被添加或者删除的情况下，直接就可以平滑地刷新它，或者在不知道UIViewController内部的视图层级的情况下对两个不同的实例做过渡动画。 它们不仅涉及到图层的属性，而且是整个图层树的改变–我们在这种动画的过程中手动在层级关系中添加或者移除图层。 一般来说，你只需要将动画添加到被影响图层的superlayer。 12345- (void)tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item &#123; CATransition *tran = [CATransition animation]; tran.type = kCATransitionFade; [self.view.layer addAnimation:tran forKey:nil];&#125; 在动画过程中取消动画用-addAnimation:forKey:方法中的key参数来在添加动画之后检索一个动画。 但并不支持在动画运行过程中修改动画，所以这个方法主要用来检测动画的属性，或者判断它是否被添加到当前图层中。 为了终止一个指定的动画，你可以用如下方法把它从图层移除掉： - (void)removeAnimationForKey:(NSString *)key; 或者移除所有动画： - (void)removeAllAnimations; 动画一旦被移除，图层的外观就立刻更新到当前的模型图层的值。一般说来，动画在结束之后被自动移除，除非设置removedOnCompletion为NO，如果你设置动画在结束之后不被自动移除，那么当它不需要的时候你要手动移除它；否则它会一直存在于内存中，直到图层被销毁。 通过代理判断是动画结束还是手动移除： - (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag { //log that the animation stopped NSLog(@&quot;The animation stopped (finished: %@)&quot;, flag? @&quot;YES&quot;: @&quot;NO&quot;); } 图层时间CAMediaTiming协议CAMediaTiming协议定义了在一段动画内用来控制逝去时间的属性的集合，CALayer和CAAnimation都实现了这个协议，所以时间可以被任意基于一个图层或者一段动画的类控制。 持续和重复duration是一个CFTimeInterval的类型（类似于NSTimeInterval的一种双精度浮点类型），对将要进行的动画的一次迭代指定了时间。 CAMediaTiming另外还有一个属性叫做repeatCount，代表动画重复的迭代次数。如果duration是2，repeatCount设为3.5（三个半迭代），那么完整的动画时长将是7秒。 duration和repeatCount默认都是0。但这不意味着动画时长为0秒，或者0次，这里的0仅仅代表了“默认”，也就是0.25秒和1次。 创建重复动画的另一种方式是使用repeatDuration属性，它让动画重复一个指定的时间，而不是指定次数，INFINITY代表无限循环。设置autoreverses的属性（BOOL类型）在每次间隔交替循环过程中自动回放。这对于播放一段连续非循环的动画很有用，例如打开一扇门，然后关上。 相对时间每个动画都有它自己描述的时间，可以独立地加速，延时或者偏移。 beginTime指定了动画开始之前的的延迟时间。这里的延迟从动画添加到可见图层的那一刻开始测量，默认是0（就是说动画会立刻执行）。 speed是一个时间的倍数，默认1.0，减少它会减慢图层/动画的时间，增加它会加快速度。如果2.0的速度，那么对于一个duration为1的动画，实际上在0.5秒的时候就已经完成了。 timeOffset和beginTime类似，但是和增加beginTime导致的延迟动画不同，增加timeOffset只是让动画快进到某一点，例如，对于一个持续1秒的动画来说，设置timeOffset为0.5意味着动画将从一半的地方开始。 和beginTime不同的是，timeOffset并不受speed的影响。所以如果你把speed设为2.0，把timeOffset设置为0.5，那么动画将从动画最后结束的地方开始，因为1秒的动画实际上被缩短到了0.5秒。然而即使使用了timeOffset让动画从结束的地方开始，它仍然播放了一个完整的时长，这个动画仅仅是循环了一圈，然后从头开始播放。 fillModeremoveOnCompletion被设置为NO的动画将会在动画结束的时候仍然保持之前的状态。 一种可能是属性和动画没被添加之前保持一致，也就是在模型图层定义的值。 另一种可能是保持动画开始之前那一帧，或者动画结束之后的那一帧。这就是所谓的填充，因为动画开始和结束的值用来填充开始之前和结束之后的时间。 它可以被CAMediaTiming的fillMode来控制。fillMode是一个NSString类型，可以接受如下四种常量： kCAFillModeForwards kCAFillModeBackwards kCAFillModeBoth kCAFillModeRemoved 默认是kCAFillModeRemoved，当动画不再播放的时候就显示图层模型指定的值剩下的三种类型向前，向后或者即向前又向后去填充动画状态，使得动画在开始前或者结束后仍然保持开始和结束那一刻的值。 需要把removeOnCompletion设置为NO，另外需要给动画添加一个非空的键，于是可以在不需要动画的时候把它从图层上移除。 animation.fillMode = CAMediaTimingFillMode.both animation.isRemovedOnCompletion = false 层级关系时间每个动画和图层在时间上都有它自己的层级概念，相对于它的父亲来测量。对图层调整时间将会影响到它本身和子图层的动画，但不会影响到父图层。另一个相似点是所有的动画都被按照层级组合（使用CAAnimationGroup实例）。 对CALayer或者CAGroupAnimation调整duration和repeatCount/repeatDuration属性并不会影响到子动画。但是beginTime，timeOffset和speed属性将会影响到子动画。然而在层级关系中，beginTime指定了父图层开始动画（或者组合关系中的父动画）和对象将要开始自己动画之间的偏移。类似的，调整CALayer和CAGroupAnimation的speed属性将会对动画以及子动画速度应用一个缩放的因子。 全局时间和本地时间CoreAnimation有一个全局时间的概念，也就是所谓的马赫时间（“马赫”实际上是iOS和Mac OS系统内核的命名）。马赫时间在设备上所有进程都是全局的–但是在不同设备上并不是全局的–不过这已经足够对动画的参考点提供便利了，使用CACurrentMediaTime函数来访问马赫时间： CFTimeInterval time = CACurrentMediaTime(); 这个函数返回的值其实无关紧要（它返回了设备自从上次启动后的秒数，并不是你所关心的），它真实的作用在于对动画的时间测量提供了一个相对值。注意当设备休眠的时候马赫时间会暂停，也就是所有的CAAnimations（基于马赫时间）同样也会暂停。 因此马赫时间对长时间测量并不有用。比如用CACurrentMediaTime去更新一个实时闹钟并不明智。（可以用[NSDate date]代替）。 每个CALayer和CAAnimation实例都有自己本地时间的概念，是根据父图层/动画层级关系中的beginTime，timeOffset和speed属性计算。就和转换不同图层之间坐标关系一样，CALayer同样也提供了方法来转换不同图层之间的本地时间。如下： - (CFTimeInterval)convertTime:(CFTimeInterval)t fromLayer:(CALayer *)l; - (CFTimeInterval)convertTime:(CFTimeInterval)t toLayer:(CALayer *)l; 当用来同步不同图层之间有不同的speed，timeOffset和beginTime的动画，这些方法会很有用。 暂停，倒回和快进设置动画的speed属性为0可以暂停动画，但在动画被添加到图层之后不太可能再修改它了，所以不能对正在进行的动画使用这个属性。 给图层添加一个CAAnimation实际上是给动画对象做了一个不可改变的拷贝，所以对原始动画对象属性的改变对真实的动画并没有作用。相反，直接用-animationForKey:来检索图层正在进行的动画可以返回正确的动画对象，但是修改它的属性将会抛出异常。 如果移除图层正在进行的动画，图层将会急速返回动画之前的状态。但如果在动画移除之前拷贝呈现图层到模型图层，动画将会看起来暂停在那里。但是不好的地方在于之后就不能再恢复动画了。 123456789101112131415- (void)pauseLayer:(CALayer*)layer &#123; CFTimeInterval pausedTime = [layer convertTime:CACurrentMediaTime() fromLayer:nil]; layer.speed = 0.0; layer.timeOffset = pausedTime;&#125; - (void)resumeLayer:(CALayer*)layer &#123; CFTimeInterval pausedTime = [layer timeOffset]; layer.speed = 1.0; layer.timeOffset = 0.0; layer.beginTime = 0.0; CFTimeInterval timeSincePause = [layer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime; layer.beginTime = timeSincePause;&#125; 一个简单的方法是可以利用CAMediaTiming来暂停图层本身。如果把图层的speed设置成0，它会暂停任何添加到图层上的动画。类似的，设置speed大于1.0将会快进，设置成一个负值将会倒回动画。 通过增加主窗口图层的speed，可以暂停整个应用程序的动画。 self.window.layer.speed = 100; 也可以通过这种方式来减速，但其实也可以在模拟器通过切换慢速动画来实现。 缓冲动画速度动画实际上就是一段时间内的变化，这就暗示了变化一定是随着某个特定的速率进行。速率由以下公式计算而来： velocity = change / time 对于这种恒定速度的动画我们称之为“线性步调”，而且从技术的角度而言这也是实现动画最简单的方式，但也是完全不真实的一种效果。 CAMediaTimingFunction首先需要设置CAAnimation的timingFunction属性，是CAMediaTimingFunction类的一个对象。如果想改变隐式动画的计时函数，同样也可以使用CATransaction的+setAnimationTimingFunction:方法。 这里有一些方式来创建CAMediaTimingFunction，最简单的方式是调用+timingFunctionWithName:的构造方法。这里传入如下几个常量之一： kCAMediaTimingFunctionLinear kCAMediaTimingFunctionEaseIn // 慢慢加速然后突然停止 kCAMediaTimingFunctionEaseOut // 一个全速开始，然后慢慢减速停止 kCAMediaTimingFunctionEaseInEaseOut // 慢慢加速然后再慢慢减速 kCAMediaTimingFunctionDefault // 同上 但加速和减速的过程都稍微有些慢 CATransaction.begin() CATransaction.setDisableActions(true) CATransaction.setAnimationDuration(1.2) CATransaction.setAnimationTimingFunction(CAMediaTimingFunction(name:.easeOut)) colorLayer.backgroundColor = UIColor.random().cgColor CATransaction.commit() UIView的动画缓冲UIKit的动画也同样支持这些缓冲方法的使用，尽管语法和常量有些不同，为了改变UIView动画的缓冲选项，给options参数添加如下常量之一： UIViewAnimationOptionCurveEaseInOut UIViewAnimationOptionCurveEaseIn UIViewAnimationOptionCurveEaseOut UIViewAnimationOptionCurveLinear 它们和CAMediaTimingFunction紧密关联，UIViewAnimationOptionCurveEaseInOut是默认值（这里没有kCAMediaTimingFunctionDefault相对应的值了）。 缓冲和关键帧动画CAKeyframeAnimation有一个NSArray类型的timingFunctions属性，我们可以用它来对每次动画的步骤指定不同的计时函数。但是指定函数的个数一定要等于keyframes数组的元素个数减一，因为它是描述每一帧之间动画速度的函数。 let animation = CAKeyframeAnimation() animation.keyPath = &quot;backgroundColor&quot; animation.duration = 2 animation.values = [UIColor.random().cgColor,UIColor.random().cgColor,UIColor.random().cgColor,UIColor.blue.cgColor] let fn = CAMediaTimingFunction(name:.easeOut) animation.timingFunctions = [fn,fn,fn,fn] colorLayer.add(animation, forKey: nil) 自定义缓冲函数除了+functionWithName:之外，CAMediaTimingFunction同样有另一个构造函数，一个有四个浮点参数的+functionWithControlPoints::::（注意这里奇怪的语法，并没有包含具体每个参数的名称，这在objective-C中是合法的，但是却违反了苹果对方法命名的指导方针，而且看起来是一个奇怪的设计）。 CAMediaTimingFunction函数的主要原则在于它把输入的时间转换成起点和终点之间成比例的改变。 CAMediaTimingFunction使用了一个叫做三次贝塞尔曲线的函数，它只可以产出指定缓冲函数的子集。 曲线的斜率代表了速度，斜率的改变代表了加速度。先加速，然后减速，最后快到达终点的时候又加速。 CAMediaTimingFunction有一个叫做-getControlPointAtIndex:values:的方法，可以用来检索曲线的点，但是使用它我们可以找到标准缓冲函数的点，然后用UIBezierPath和CAShapeLayer来把它画出来。 基于关键帧的缓冲为了使用关键帧实现反弹动画，需要在缓冲曲线中对每一个显著的点创建一个关键帧（在这个情况下，关键点也就是每次反弹的峰值），然后应用缓冲函数把每段曲线连接起来。同时，我们也需要通过keyTimes来指定每个关键帧的时间偏移，由于每次反弹的时间都会减少，于是关键帧并不会均匀分布。 123456789101112131415161718192021222324252627282930313233func animate() &#123; snowmanView.center = CGPoint(x: 150,y: 50); let animation = CAKeyframeAnimation() animation.keyPath = \"position\" animation.duration = 1.0 animation.delegate = self animation.values = [NSValue(cgPoint: CGPoint(x: 150, y: 50)), NSValue(cgPoint: CGPoint(x: 150, y: 300)), NSValue(cgPoint: CGPoint(x: 150, y: 200)), NSValue(cgPoint: CGPoint(x: 150, y: 250)), NSValue(cgPoint: CGPoint(x: 150, y: 150)), NSValue(cgPoint: CGPoint(x: 150, y: 100)), NSValue(cgPoint: CGPoint(x: 150, y: 300))] animation.timingFunctions = [ CAMediaTimingFunction(name: .easeIn), CAMediaTimingFunction(name: .easeIn), CAMediaTimingFunction(name: .easeOut), CAMediaTimingFunction(name: .easeOut), CAMediaTimingFunction(name: .easeIn), CAMediaTimingFunction(name: .easeOut), CAMediaTimingFunction(name: .easeIn) ]; animation.keyTimes = [NSNumber(value: 0.0), NSNumber(value: 0.3), NSNumber(value: 0.5), NSNumber(value: 0.7), NSNumber(value: 0.8), NSNumber(value: 0.9), NSNumber(value: 0.95), NSNumber(value: 1.0)] snowmanView.layer.position = CGPoint(x: 150, y: 300) snowmanView.layer.add(animation, forKey: nil)&#125; 流程自动化用代码获取属性动画的起始值之间的任意插值，我们就可以把动画分割成许多独立的关键帧，然后产出一个线性的关键帧动画。 需要做以下两点： 自动把任意属性动画分割成多个关键帧。 用一个数学函数表示弹性动画，使得可以对帧做偏移。 公式如下： value = (endValue – startValue) × time + startValue; 使用60 x 动画时间（秒做单位）作为关键帧的个数，这时因为Core Animation按照每秒60帧去渲染屏幕更新，所以如果我们每秒生成60个关键帧，就可以保证动画足够的平滑（尽管实际上很可能用更少的帧率就可以达到很好的效果）。 基于定时器的动画NSTimeriOS上的每个线程都管理了一个NSRunloop，字面上看就是通过一个循环来完成一些任务列表。但是对主线程，这些任务包含如下几项： 处理触摸事件 发送和接受网络数据包 执行使用gcd的代码 处理计时器行为 屏幕重绘 当设置一个NSTimer，他会被插入到当前任务列表中，然后直到指定时间过去之后才会被执行。但是何时启动定时器并没有一个时间上限，而且它只会在列表中上一个任务完成之后开始执行。这通常会导致有几毫秒的延迟，但是如果上一个任务过了很久才完成就会导致延迟很长一段时间。 屏幕重绘的频率是一秒钟六十次，但是和定时器行为一样，如果列表中上一个执行了很长时间，它也会延迟。这些延迟都是一个随机值，于是就不能保证定时器精准地一秒钟执行六十次。有时候发生在屏幕重绘之后，这就会使得更新屏幕会有个延迟，看起来就是动画卡壳了。有时候定时器会在屏幕更新的时候执行两次，于是动画看起来就跳动了。 可以通过一些途径来优化： 可以用CADisplayLink让更新频率严格控制在每次屏幕刷新之后。 基于真实帧的持续时间而不是假设的更新频率来做动画。 调整动画计时器的run loop模式，这样就不会被别的事件干扰。 CADisplayLinkCADisplayLink是CoreAnimation提供的另一个类似于NSTimer的类，它总是在屏幕完成一次更新之前启动，它的接口设计的和NSTimer很类似，所以它实际上就是一个内置实现的替代，但是和timeInterval以秒为单位不同，CADisplayLink有一个整型的frameInterval属性，指定了间隔多少帧之后才执行。默认值是1，意味着每次屏幕更新之前都会执行一次。但是如果动画的代码执行起来超过了六十分之一秒，可以指定frameInterval为2，就是说动画每隔一帧执行一次（一秒钟30帧）或者3，也就是一秒钟20次，等等。 用CADisplayLink而不是NSTimer，会保证帧率足够连续，使得动画看起来更加平滑，但即使CADisplayLink也不能保证每一帧都按计划执行，一些失去控制的离散的任务或者事件（例如资源紧张的后台程序）可能会导致动画偶尔地丢帧。 当使用NSTimer的时候，一旦有机会计时器就会开启，但是CADisplayLink却不一样：如果它丢失了帧，就会直接忽略它们，然后在下一次更新的时候接着运行。 &#x20;Run Loop 模式当创建CADisplayLink的时候，需要指定一个run loop和run loop mode，对于run loop来说，就使用了主线程的run loop，因为任何用户界面的更新都需要在主线程执行，但是模式的选择就并不那么清楚了，每个添加到run loop的任务都有一个指定了优先级的模式，为了保证用户界面保持平滑，iOS会提供和用户界面相关任务的优先级，而且当UI很活跃的时候的确会暂停一些别的任务。 一个典型的例子就是当是用UIScrollview滑动的时候，重绘滚动视图的内容会比别的任务优先级更高，所以标准的NSTimer和网络请求就不会启动，一些常见的run loop模式如下： NSDefaultRunLoopMode - 标准优先级 NSRunLoopCommonModes - 高优先级 UITrackingRunLoopMode - 用于UIScrollView和别的控件的动画 用了NSDefaultRunLoopMode，但是不能保证动画平滑的运行，所以就可以用NSRunLoopCommonModes来替代。但是要小心，因为如果动画在一个高帧率情况下运行，会发现一些别的类似于定时器的任务或者类似于滑动的其他iOS动画会暂停，直到动画结束。 同样可以同时对CADisplayLink指定多个run loop模式，于是可以同时加入NSDefaultRunLoopMode和UITrackingRunLoopMode来保证它不会被滑动打断，也不会被其他UIKit控件动画影响性能，像这样： 123self.timer = [CADisplayLink displayLinkWithTarget:self selector:@selector(step:)];[self.timer addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];[self.timer addToRunLoop:[NSRunLoop mainRunLoop] forMode:UITrackingRunLoopMode]; 物理模拟略 性能调优&lt;重点&gt;动画的舞台动画和屏幕上组合的图层实际上被一个单独的进程管理，而不是你的应用程序。这个进程就是所谓的渲染服务。在iOS5和之前的版本是SpringBoard进程（同时管理着iOS的主屏）。在iOS6之后的版本中叫做BackBoard。 当运行一段动画时候，这个过程会被四个分离的阶段被打破： 布局 - 这是准备你的视图/图层的层级关系，以及设置图层属性（位置，背景色，边框等等）的阶段。 显示 - 这是图层的寄宿图片被绘制的阶段。绘制有可能涉及你的-drawRect:和-drawLayer:inContext:方法的调用路径。 准备 - 这是Core Animation准备发送动画数据到渲染服务的阶段。这同时也是Core Animation将要执行一些别的事务例如解码动画过程中将要显示的图片的时间点。 提交 - 这是最后的阶段，Core Animation打包所有图层和动画属性，然后通过IPC（内部处理通信）发送到渲染服务进行显示。 一旦打包的图层和动画到达渲染服务进程，他们会被反序列化来形成另一个叫做渲染树的图层树（在第一章“图层树”中提到过）。使用这个树状结构，渲染服务对动画的每一帧做出如下工作： 对所有的图层属性计算中间值，设置OpenGL几何形状（纹理化的三角形）来执行渲染 在屏幕上渲染可见的三角形 所以一共有六个阶段；最后两个阶段在动画过程中不停地重复。前五个阶段都在软件层面处理（通过CPU），只有最后一个被GPU执行。而且，你真正只能控制前两个阶段：布局和显示。Core Animation框架在内部处理剩下的事务，你也控制不了它。 GPU相关的操作GPU为一个具体的任务做了优化：它用来采集图片和形状（三角形），运行变换，应用纹理和混合然后把它们输送到屏幕上。现代iOS设备上可编程的GPU在这些操作的执行上又很大的灵活性，但是Core Animation并没有暴露出直接的接口。除非想绕开Core Animation并编写你自己的OpenGL着色器，从根本上解决硬件加速的问题，那么剩下的所有都还是需要在CPU的软件层面上完成。 宽泛的说，大多数CALayer的属性都是用GPU来绘制。比如设置图层背景或者边框的颜色，那么这些可以通过着色的三角板实时绘制出来。如果对一个contents属性设置一张图片，然后裁剪它 - 它就会被纹理的三角形绘制出来，而不需要软件层面做任何绘制。 但是有一些事情会降低（基于GPU）图层绘制，比如： 太多的几何结构 - 这发生在需要太多的三角板来做变换，以应对处理器的栅格化的时候。现代iOS设备的图形芯片可以处理几百万个三角板，所以在Core Animation中几何结构并不是GPU的瓶颈所在。但由于图层在显示之前通过IPC发送到渲染服务器的时候（图层实际上是由很多小物体组成的特别重量级的对象），太多的图层就会引起CPU的瓶颈。这就限制了一次展示的图层个数。 重绘 - 主要由重叠的半透明图层引起。GPU的填充比率（用颜色填充像素的比率）是有限的，所以需要避免重绘（每一帧用相同的像素填充多次）的发生。在现代iOS设备上，GPU都会应对重绘；即使是iPhone 3GS都可以处理高达2.5的重绘比率，并任然保持60帧率的渲染（这意味着你可以绘制一个半的整屏的冗余信息，而不影响性能），并且新设备可以处理更多。 离屏绘制 - 这发生在当不能直接在屏幕上绘制，并且必须绘制到离屏图片的上下文中的时候。离屏绘制发生在基于CPU或者是GPU的渲染，或者是为离屏图片分配额外内存，以及切换绘制上下文，这些都会降低GPU性能。对于特定图层效果的使用，比如圆角，图层遮罩，阴影或者是图层光栅化都会强制Core Animation提前渲染图层的离屏绘制。但这不意味着你需要避免使用这些效果，只是要明白这会带来性能的负面影响。 过大的图片 - 如果视图绘制超出GPU支持的2048x2048或者4096x4096尺寸的纹理，就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性能。 CPU相关的操作大多数工作在Core Animation的CPU都发生在动画开始之前。这意味着它不会影响到帧率，所以很好，但是他会延迟动画开始的时间，让界面看起来会比较迟钝。 以下CPU的操作都会延迟动画的开始时间： 布局计算 - 如果你的视图层级过于复杂，当视图呈现或者修改的时候，计算图层帧率就会消耗一部分时间。特别是使用iOS6的自动布局机制尤为明显，它应该是比老版的自动调整逻辑加强了CPU的工作。 视图懒加载 - iOS只会当视图控制器的视图显示到屏幕上时才会加载它。这对内存使用和程序启动时间很有好处，但是当呈现到屏幕上之前，按下按钮导致的许多工作都会不能被及时响应。比如控制器从数据库中获取数据，或者视图从一个nib文件中加载，或者涉及IO的图片显示，都会比CPU正常操作慢得多。 Core Graphics绘制 - 如果对视图实现了-drawRect:方法，或者CALayerDelegate的-drawLayer:inContext:方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢，所以在一个对性能十分挑剔的场景下这样做十分不好。 解压图片 - PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（通常等同于图片宽 x 长 x 4个字节）。为了节省内存，iOS通常直到真正绘制的时候才去解码图片。根据你加载图片的方式，第一次对图层内容赋值的时候（直接或者间接使用UIImageView）或者把它绘制到Core Graphics中，都需要对它解压，这样的话，对于一个较大的图片，都会占用一定的时间。 当图层被成功打包，发送到渲染服务器之后，CPU仍然要做如下工作：为了显示屏幕上的图层，Core Animation必须对渲染树种的每个可见图层通过OpenGL循环转换成纹理三角板。由于GPU并不知晓Core Animation图层的任何结构，所以必须要由CPU做这些事情。这里CPU涉及的工作和图层个数成正比，所以如果在你的层级关系中有太多的图层，就会导致CPU没一帧的渲染，即使这些事情不是你的应用程序可控的。 IO相关操作上下文中的IO（输入/输出）指的是例如闪存或者网络接口的硬件访问。一些动画可能需要从闪存（甚至是远程URL）来加载。一个典型的例子就是两个视图控制器之间的过渡效果，这就需要从一个nib文件或者是它的内容中懒加载，或者一个旋转的图片，可能在内存中尺寸太大，需要动态滚动来加载。 IO比内存访问更慢，所以如果动画涉及到IO，就是一个大问题。总的来说，这就需要使用聪敏但尴尬的技术，也就是多线程，缓存和预加载（提前加载当前不需要的资源，但是之后可能需要用到）。 高效绘图术语绘图通常在Core Animation的上下文中指代软件绘图（意即：不由GPU协助的绘图）。在iOS中，软件绘图通常是由Core Graphics框架完成来完成。但是，在一些必要的情况下，相比Core Animation和OpenGL，Core Graphics要慢了不少。 软件绘图不仅效率低，还会消耗可观的内存。CALayer只需要一些与自己相关的内存：只有它的寄宿图会消耗一定的内存空间。即使直接赋给contents属性一张图片，也不需要增加额外的照片存储大小。如果相同的一张图片被多个图层作为contents属性，那么他们将会共用同一块内存，而不是复制内存块。 但是一旦你实现了CALayerDelegate协议中的-drawLayer:inContext:方法或者UIView中的-drawRect:方法（其实就是前者的包装方法），图层就创建了一个绘制上下文，这个上下文需要的大小的内存可从这个算式得出：图层宽*图层高*4字节，宽高的单位均为像素。对于一个在Retina iPad上的全屏图层来说，这个内存量就是 2048*1526*4字节，相当于12MB内存，图层每次重绘的时候都需要重新抹掉内存然后重新分配。 软件绘图的代价昂贵，除非绝对必要，应该避免重绘视图。提高绘制性能的秘诀就在于尽量避免去绘制。 矢量图形用Core Graphics来绘图的一个通常原因就是只是用图片或是图层效果不能轻易地绘制出矢量图形。矢量绘图包含一下这些： 任意多边形（不仅仅是一个矩形） 斜线或曲线 文本 渐变 用Core Graphics做一个简单的『画板』。这样实现的问题在于，画得越多，程序就会越慢。因为每次移动手指的时候都会重绘整个贝塞尔路径（UIBezierPath），随着路径越来越复杂，每次重绘的工作就会增加，直接导致了帧数的下降。 CAShapeLayer可以绘制多边形，直线和曲线。CATextLayer可以绘制文本。CAGradientLayer用来绘制渐变。这些总体上都比Core Graphics更快，同时他们也避免了创造一个寄宿图。 用CAShapeLayer替代Core Graphics，性能就会得到提高。虽然随着路径复杂性的增加，绘制性能依然会下降，但是只有当非常非常浮躁的绘制时才会感到明显的帧率差异。 1234567891011121314151617181920212223242526272829303132333435363738394041class DrawingView: UIView &#123; class override var layerClass: AnyClass &#123; return CAShapeLayer.self &#125; let path = UIBezierPath() override init(frame: CGRect) &#123; super.init(frame: frame) self.backgroundColor = .lightGray let shapeLayer = self.layer as! CAShapeLayer shapeLayer.strokeColor = UIColor.orange.cgColor shapeLayer.fillColor = UIColor.clear.cgColor shapeLayer.lineJoin = CAShapeLayerLineJoin.miter shapeLayer.lineCap = CAShapeLayerLineCap.round shapeLayer.lineWidth = 5.0 &#125; required init?(coder: NSCoder) &#123; fatalError(\"init(coder:) has not been implemented\") &#125; override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; super.touchesBegan(touches, with: event) if let point = touches.first?.location(in: self) &#123; path.move(to: point) &#125; &#125; override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; super.touchesMoved(touches, with: event) if let point = touches.first?.location(in: self) &#123; path.addLine(to: point) self.setNeedsDisplay() &#125; let shapeLayer = self.layer as! CAShapeLayer shapeLayer.path = self.path.cgPath &#125; override func draw(_ rect: CGRect) &#123; UIColor.clear.setFill() UIColor.orange.setStroke() path.stroke() &#125;&#125; 脏矩形为了减少不必要的绘制，Mac OS和iOS设备将会把屏幕区分为需要重绘的区域和不需要重绘的区域。那些需要重绘的部分被称作『脏区域』。在实际应用中，鉴于非矩形区域边界裁剪和混合的复杂性，通常会区分出包含指定视图的矩形位置，而这个位置就是『脏矩形』。 当一个视图被改动过了，TA可能需要重绘。但是很多情况下，只是这个视图的一部分被改变了，所以重绘整个寄宿图就太浪费了。但是Core Animation通常并不了解你的自定义绘图代码，它也不能自己计算出脏区域的位置。然而，你的确可以提供这些信息。 当你检测到指定视图或图层的指定部分需要被重绘，你直接调用`-setNeedsDisplayInRect:`来标记它，然后将影响到的矩形作为参数传入。这样就会在一次视图刷新时调用视图的`-drawRect:`（或图层代理的`-drawLayer:inContext:`方法）。 传入-drawLayer:inContext:的CGContext参数会自动被裁切以适应对应的矩形。为了确定矩形的尺寸大小，你可以用CGContextGetClipBoundingBox()方法来从上下文获得大小。调用-drawRect()会更简单，因为CGRect会作为参数直接传入。 异步绘制UIKit的单线程天性意味着寄宿图通畅要在主线程上更新，这意味着绘制会打断用户交互，甚至让整个app看起来处于无响应状态。 针对这个问题，有一些方法可以用到：一些情况下，可以推测性地提前在另外一个线程上绘制内容，然后将由此绘出的图片直接设置为图层的内容。这实现起来可能不是很方便，但是在特定情况下是可行的。Core Animation提供了一些选择：CATiledLayer和drawsAsynchronously属性。 CATiledLayerCATiledLayer还有一个有趣的特性：在多个线程中为每个小块同时调用-drawLayer:inContext:方法。这就避免了阻塞用户交互而且能够利用多核心新片来更快地绘制。只有一个小块的CATiledLayer是实现异步更新图片视图的简单方法。 drawsAsynchronouslydrawsAsynchronously属性对传入-drawLayer:inContext:的CGContext进行改动，允许CGContext延缓绘制命令的执行以至于不阻塞用户交互。 它与CATiledLayer使用的异步绘制并不相同。它自己的-drawLayer:inContext:方法只会在主线程调用，但是CGContext并不等待每个绘制命令的结束。相反地，它会将命令加入队列，当方法返回时，在后台线程逐个执行真正的绘制。 根据苹果的说法。这个特性在需要频繁重绘的视图上效果最好（比如我们的绘图应用，或者诸如`UITableViewCell`之类的），对那些只绘制一次或很少重绘的图层内容来说没什么太大的帮助。 图像IO 大图需要异步加载 PNG图片加载会比JPEG更长，因为文件可能更大，但是解码会相对较快，而且Xcode会把PNG图片进行解码优化之后引入工程。JPEG图片更小，加载更快，但是解压的步骤要消耗更长的时间，因为JPEG解压算法比基于zip的PNG算法更加复杂。 当加载图片的时候，iOS通常会延迟解压图片的时间，直到加载到内存之后。这就会在准备绘制图片的时候影响性能，因为需要在绘制之前进行解压（通常是消耗时间的问题所在）。 最简单的方法就是使用UIImage的+imageNamed:方法避免延时加载。不像+imageWithContentsOfFile:（和其他别的UIImage加载方法），这个方法会在加载图片之后立刻进行解压（就和本章之前我们谈到的好处一样）。 [UIImage imageNamed:]方法有另一个非常显著的好处：它在内存中自动缓存了解压后的图片，即使你自己没有保留对它的任何引用。 但是并不是对应用程序需要显示的所有类型的图片都适用： [UIImage imageNamed:]方法仅仅适用于在应用程序资源束目录下的图片，但是大多数应用的许多图片都要从网络或者是用户的相机中获取，所以[UIImage imageNamed:]就没法用了。 [UIImage imageNamed:]缓存用来存储应用界面的图片（按钮，背景等等）。如果对照片这种大图也用这种缓存，那么iOS系统就很可能会移除这些图片来节省内存。那么在切换页面时性能就会下降，因为这些图片都需要重新加载。对传送器的图片使用一个单独的缓存机制就可以把它和应用图片的生命周期解耦。 [UIImage imageNamed:]缓存机制并不是公开的，不能很好地控制它。例如，没法做到检测图片是否在加载之前就做了缓存，不能够设置缓存大小，当图片没用的时候也不能把它从缓存中移除。 使用NSCache做预加载代替[UIImage imageNamed:可以实现自定义缓存机制。 图层性能光栅化CALayer的shouldRasterize属性，它可以解决重叠透明图层的混合失灵问题。它也是作为绘制复杂图层树结构的优化方法。 启用shouldRasterize属性会将图层绘制到一个屏幕之外的图像。然后这个图像将会被缓存起来并绘制到实际图层的contents和子图层。如果有很多的子图层或者有复杂的效果应用，这样做就会比重绘所有事务的所有帧划得来得多。但是光栅化原始图像需要时间，而且还会消耗额外的内存。 当使用得当时，光栅化可以提供很大的性能优势，但是一定要避免作用在内容不断变动的图层上，否则它缓存方面的好处就会消失，而且会让性能变的更糟。 为了检测是否正确地使用了光栅化方式，用Instrument查看一下Color Hits Green和Misses Red项目，是否已光栅化图像被频繁地刷新（这样就说明图层并不是光栅化的好选择，或则无意间触发了不必要的改变导致了重绘行为）。 离屏渲染图层的以下属性将会触发屏幕外绘制： 圆角（当和maskToBounds一起使用时） 图层蒙板 阴影 屏幕外渲染和我们启用光栅化时相似，除了它并没有像光栅化图层那么消耗大，子图层并没有被影响到，而且结果也没有被缓存，所以不会有长期的内存占用。但是，如果太多图层在屏幕外渲染依然会影响到性能。 对于那些需要动画而且要在屏幕外渲染的图层来说，可以用CAShapeLayer，contentsCenter或者shadowPath来获得同样的表现而且较少地影响到性能。 CAShapeLayercornerRadius和maskToBounds独立作用的时候都不会有太大的性能问题，但是当他俩结合在一起，就触发了屏幕外渲染。有时候想显示圆角并沿着图层裁切子图层的时候，会发现你并不需要沿着圆角裁切，这个情况下用CAShapeLayer就可以避免这个问题了。 shadowPath如果图层是一个简单几何图形如矩形或者圆角矩形（假设不包含任何透明部分或者子图层），创建出一个对应形状的阴影路径就比较容易，而且Core Animation绘制这个阴影也相当简单，避免了屏幕外的图层部分的预排版需求。这对性能来说很有帮助。 如果图层是一个更复杂的图形，生成正确的阴影路径可能就比较难了，这样子的话可以用绘图软件预先生成一个阴影背景图。 混合和过度绘制GPU每一帧可以绘制的像素有一个最大限制（就是所谓的fill rate），这个情况下可以轻易地绘制整个屏幕的所有像素。但是如果由于重叠图层的关系需要不停地重绘同一区域的话，掉帧就可能发生了。 GPU会放弃绘制那些完全被其他图层遮挡的像素，但是要计算出一个图层是否被遮挡也是相当复杂并且会消耗处理器资源。同样，合并不同图层的透明重叠像素（即混合）消耗的资源也是相当客观的。所以为了加速处理进程，不到必须时刻不要使用透明图层。任何情况下，应该这样做： 给视图的backgroundColor属性设置一个固定的，不透明的颜色 设置opaque属性为YES 该属性为BOOL值，UIView的默认值是YES，但UIButton等子类的默认值都是NO。\\opaque表示当前UIView是否不透明，不过搞笑的是事实上它却决定不了当前UIView是不是不透明，比如你将opaque设为NO，该UIView照样是可见的。其作用在于：给绘图系统提供一个性能优化开关。如果该值为YES，那么绘图在绘制该视图的时候把整个视图当做不透明对待。这样，绘图系统在执行绘图过程中会优化一些操作并提供系统性能；如果是设置为NO，绘图系统将其和其他内容平等对待，不去做优化操作。为了性能方面的考量，默认被置为YES（意味着优化）。 UIView当有背景颜色时：并且背景颜色有透明度（透明度不为1时），将opaque设置为YES性能较高。 UIVIew有背景颜色时：并且背景颜色的透明度为1，opaque的值不影响性能。 UIVIew没有背景颜色时：opaque的值不影响性能。 这样做减少了混合行为（因为编译器知道在图层之后的东西都不会对最终的像素颜色产生影响）并且计算得到了加速，避免了过度绘制行为因为Core Animation可以舍弃所有被完全遮盖住的图层，而不用每个像素都去计算一遍。 如果用到了图像，尽量避免透明除非非常必要。如果图像要显示在一个固定的背景颜色或是固定的背景图之前，你没必要相对前景移动，你只需要预填充背景图片就可以避免运行时混色了。 如果是文本的话，一个白色背景的UILabel（或者其他颜色）会比透明背景要更高效。 最后，明智地使用shouldRasterize属性，可以将一个固定的图层体系折叠成单张图片，这样就不需要每一帧重新合成了，也就不会有因为子图层之间的混合和过度绘制的性能问题了。 减少图层数量初始化图层，处理图层，打包通过IPC发给渲染引擎，转化成OpenGL几何图形，这些是一个图层的大致资源开销。事实上，一次性能够在屏幕上显示的最大图层数量也是有限的。 在对图层做任何优化之前，需要确定你不是在创建一些不可见的图层，图层在以下几种情况下回事不可见的： 图层在屏幕边界之外，或是在父图层边界之外。 完全在一个不透明图层之后。 完全透明 Core Animation非常擅长处理对视觉效果无意义的图层。但是经常性地，代码会比Core Animation更早地想知道一个图层是否是有用的。理想状况下，在图层对象在创建之前就想知道，以避免创建和配置不必要图层的额外工作。 对象回收对象回收的基础原则就是你需要创建一个相似对象池。当一个对象的指定实例（本例子中指的是图层）结束了使命，你把它添加到对象池中。每次当你需要一个实例时，你就从池中取出一个。当且仅当池中为空时再创建一个新的。 这样做的好处在于避免了不断创建和释放对象（相当消耗资源，因为涉及到内存的分配和销毁）而且也不必给相似实例重复赋值。","categories":[],"tags":[]},{"title":"关于App Extension","slug":"关于App-Extension","date":"2020-08-27T01:48:28.000Z","updated":"2022-11-06T01:25:58.362Z","comments":true,"path":"2020/08/27/关于App-Extension/","link":"","permalink":"https://bigporo.github.io/2020/08/27/关于App-Extension/","excerpt":"App Extension App Extension可以让你扩展你APP的自定义功能和内容，使用户可以在与其他应用或者系统进行互动的时候去使用它。 extension并不是一个独立的app，它有一个包含在app bundle中的独立bundle； extension不能单独存在，必须有一个包含它的containing app； 不同的extension激活方式不同； 常见的种类包括Today Widget、Share Extension、Action Extension、Document Provider、Custom Keyboard","text":"App Extension App Extension可以让你扩展你APP的自定义功能和内容，使用户可以在与其他应用或者系统进行互动的时候去使用它。 extension并不是一个独立的app，它有一个包含在app bundle中的独立bundle； extension不能单独存在，必须有一个包含它的containing app； 不同的extension激活方式不同； 常见的种类包括Today Widget、Share Extension、Action Extension、Document Provider、Custom Keyboard containing appcontaining app我们可以把它理解为容器App。 尽管苹果开放了extension，但是在iOS中extension并不能单独存在，要想提交到AppStore，必须将extension包含在一个app中提交，并且app的实现部分不能为空,这个包含extension的app就叫containing app。 host app我们可以把它理解为宿主的App，能够调起extension的app被称为host app。 比如：Safari app 里面网页分享到微信, Safari就是 host app ; widget的host app就是Today。 App Extensions的生命周期以下是Apple官方提供的图片 用户选择要使用的App extension 系统启动App Extension App Extension 代码运行 运行完之后系统kill掉App Extension 这就是App Extension的生命周期，举个例子： 一个Share Extension，在图库里面你选择了一张图片，然后点击分享，选择你的Share Extension(第一步)，此时系统会启动你的Share Extension（第二步）。然后你将选择的图片分享到指定的程序（例如微信的发送给朋友）（第三步）。接下来分享页面关闭，系统kill掉了Share Extension。 与Host App的通讯Host app (如微信) ； App extension （safari里面分享点击出来的微信extension）；Containing app (safari) Containing App和app Extension并没有直接的沟通。甚至有的时候Containing app可以不运行，而App Extension直接运行。Containing app和Host app没有任何的沟通。 还有一种是app extension可以直接和他的containing app沟通： 例如Today Widget，可以直接告诉系统打开他的Containing app，只需要调用NSExtensionContext的openURL:CompletionHandler:方法即可。 app extension和containing app可以共同读写一个被称为Shared resources的存储区域，这是通过App Groups实现的。 App Groups 实现数据共享 需要先配置好开发者账号中的 app group id 在app中开启 TARGETS–&gt;ApplictionExtension–&gt;Capabilities–&gt;App Groups 在extension中开启 TARGETS–&gt;BPToday–&gt;Capabilities–&gt;App Groups 通过NSUserDefaults共享数据写入数据 12345// AppDelegate.m NSUserDefaults *userDefaults = [[NSUserDefaults alloc] initWithSuiteName:@&quot;app group name&quot;]; [userDefaults setObject:@&quot;共享数据&quot; forKey:@&quot;content&quot;]; [userDefaults synchronize]; 读取数据 1234// TodayViewController.m NSUserDefaults *userDefaults = [[NSUserDefaults alloc] initWithSuiteName:@&quot;app group name&quot;]; NSLog(@&quot;%@&quot;,[userDefaults objectForKey:@&quot;content&quot;]); 通过NSFileManager共享数据保存数据 123456789101112131415161718192021- (BOOL)saveTextByNSFileManager &#123; NSError *err = nil; NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@&quot;app group name&quot;]; containerURL = [containerURL URLByAppendingPathComponent:@&quot;Library/Caches/good&quot;]; NSString *value = _textField.text; BOOL result = [value writeToURL:containerURL atomically:YES encoding:NSUTF8StringEncoding error:&amp;err]; if (!result) &#123; NSLog(@&quot;%@&quot;,err); &#125; else &#123; NSLog(@&quot;save value:%@ success.&quot;,value); &#125; return result; &#125; 读取数据 123456789101112- (NSString *)readTextByNSFileManager &#123; NSError *err = nil; NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@&quot;app group name&quot;]; containerURL = [containerURL URLByAppendingPathComponent:@&quot;Library/Caches/good&quot;]; NSString *value = [NSString stringWithContentsOfURL:containerURL encoding:NSUTF8StringEncoding error:&amp;err]; return value; &#125; 代码共享framework 可以在extension和containing app之间共享代码。 即将framework分别嵌入到extension和containing app的target中实现代码共享。 在App Extension中不可以做的事情 访问sharedApplication对象。因此不能使用任何该对象的防范； 使用任何标记NS_EXTENSION_UNAVAILABLE宏的API，或者类似的宏，或者不可用framework里面的API，例如HealthKit framework不能用于app extensions； iOS设备访问相机或者麦克风（iMessage app可以访问这些资源，只要在Info.plist里面进行配置使用描述即可）； 运行一个长时间的后台任务（根据不同平台而异）； 使用隔空投送接收数据； Demo传送门","categories":[],"tags":[]},{"title":"组件化方案的对比和分析","slug":"组件化方案的对比和分析","date":"2020-08-23T14:37:08.000Z","updated":"2020-08-23T15:06:19.000Z","comments":true,"path":"2020/08/23/组件化方案的对比和分析/","link":"","permalink":"https://bigporo.github.io/2020/08/23/组件化方案的对比和分析/","excerpt":"本文将介绍下主流的三种组件化方案，并对比分析各自的优缺点。","text":"本文将介绍下主流的三种组件化方案，并对比分析各自的优缺点。 Target Action主要思路 抽离业务逻辑 通过中间层进行调用 中间层使用Runtime反射 缺点 硬编码 中间层容易臃肿&lt;可以用分类做拆分&gt; performSelector 方法传参有限 代码实现.h文件 12345678@interface BPMediator : NSObject// Target Action+ (__kindof UIViewController *)twoViewControllerWithParam:(NSString *)param;@end .m文件 1234567891011@implementation BPMediator+ (__kindof UIViewController *)twoViewControllerWithParam:(NSString *)param &#123; Class twoCls = NSClassFromString(@&quot;TwoViewController&quot;); UIViewController *controller = [[twoCls alloc] performSelector:NSSelectorFromString(@&quot;initWithParam:&quot;) withObject:param]; return controller; &#125;@end 调用&lt;控制器1&gt; 1[self.navigationController pushViewController:[BPMediator twoViewControllerWithParam:@&quot;Target Action&quot;] animated:YES]; URL Scheme主要思路 使用URL处理本地的跳转 通过中间层进行注册和调用 注册表无需使用反射 缺点 具体参数不透明 非懒加载 注册表的维护 代码实现.h文件 12345678910@interface BPMediator : NSObjecttypedef void(^BPMediatorProgressBlock)(NSDictionary *param);+ (void)registerScheme:(NSString *)scheme processBlock:(BPMediatorProgressBlock)processBlock;+ (void)openUrl:(NSString *)url params:(NSString *)params;@end .m文件 123456789101112131415161718192021222324252627282930@implementation BPMediator+ (NSMutableDictionary *)mediatorCache &#123; static NSMutableDictionary *cache; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; cache = [NSMutableDictionary dictionary]; &#125;); return cache;&#125;+ (void)registerScheme:(NSString *)scheme processBlock:(BPMediatorProgressBlock)processBlock &#123; if (scheme &amp;&amp; processBlock) &#123; [[[self class] mediatorCache] setObject:processBlock forKey:scheme]; &#125;&#125;+ (void)openUrl:(NSString *)url params:(NSDictionary *)params &#123; /** url 可携带额外参数 此时取scheme作为key 当前简便实用url为key */ BPMediatorProgressBlock block = [[[self class] mediatorCache] objectForKey:url]; if (block) &#123; block(params); &#125;&#125;@end 注册URL&lt;控制器2&gt; 12345678910+ (void)load &#123; // URL Scheme [BPMediator registerScheme:@&quot;twoController://&quot; processBlock:^(NSDictionary * _Nonnull params) &#123; NSString *param = [params objectForKey:@&quot;param&quot;]; UINavigationController *nav = (UINavigationController *)[params objectForKey:@&quot;controller&quot;]; TwoViewController *controller = [[TwoViewController alloc] initWithParam:param]; [nav pushViewController:controller animated:YES]; &#125;]; &#125; 调用URL&lt;控制器1&gt; 12[BPMediator openUrl:@&quot;twoController://&quot; params:@&#123;@&quot;controller&quot;:self.navigationController,@&quot;param&quot;:@&quot;URL Scheme&quot;&#125;]; Protocol Class主要思路 增加 Protocol Wrapper 层 中间件返回 Protocol 对应的 Class 解决硬编码的问题 缺点 同URL Scheme 代码实现.h文件 1234567891011121314@protocol BPTwoViewControllerProtocol &lt;NSObject&gt;- (__kindof UIViewController *)twoViewControllerWithParam:(NSString *)param;@end@interface BPMediator : NSObject// Protocol Class+ (void)registerProtocol:(Protocol *)protocol cls:(Class)cls;+ (Class)classForProtocol:(Protocol *)protocol;@end .m文件 123456789101112131415161718192021222324@implementation BPMediator+ (NSMutableDictionary *)mediatorCache &#123; static NSMutableDictionary *cache; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; cache = [NSMutableDictionary dictionary]; &#125;); return cache;&#125;+ (void)registerProtocol:(Protocol *) protocol cls:(Class)cls &#123; if (protocol &amp;&amp; cls) &#123; [[[self class] mediatorCache] setObject:cls forKey:NSStringFromProtocol(protocol)]; &#125;&#125;+ (Class)classForProtocol:(Protocol *) protocol &#123; return [[[self class] mediatorCache] objectForKey:NSStringFromProtocol(protocol)];&#125;@end 遵守、实现、注册Protocol &lt;控制器2&gt; 12345678910+ (void)load &#123; // Protocol Class [BPMediator registerProtocol:@protocol(BPTwoViewControllerProtocol) cls:[self class]]; &#125;// BPTwoViewControllerProtocol- (__kindof UIViewController *)twoViewControllerWithParam:(NSString *)param &#123; return [self initWithParam:param];&#125; 调用Protocol &lt;控制器1&gt; 1234Class cls = [BPMediator classForProtocol:@protocol(BPTwoViewControllerProtocol)];[self.navigationController pushViewController:[[cls alloc] twoViewControllerWithParam:@&quot;Protocol Class&quot;] animated:YES]; 总结Demo传送门 这三种方案各有优劣。 在实际的开发中，结合当前的业务情况，有可能采用多种方案。要根据当前的需求细节和团队开发能力，选择合适的方案。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"}]},{"title":"Cocoapods私有库搭建","slug":"Cocoapods私有库搭建","date":"2019-08-20T14:02:19.000Z","updated":"2019-08-20T14:06:31.000Z","comments":true,"path":"2019/08/20/Cocoapods私有库搭建/","link":"","permalink":"https://bigporo.github.io/2019/08/20/Cocoapods私有库搭建/","excerpt":"Cocoapods是非常好用的一个iOS依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，以及将自己的项目中的公共组件交由它去管理。","text":"Cocoapods是非常好用的一个iOS依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，以及将自己的项目中的公共组件交由它去管理。 整体先说明一下创建一个私有的podspec包括如下那么几个步骤： 创建并设置一个私有的Spec Repo。 创建Pod的所需要的项目工程文件，并且有可访问的项目版本控制地址。 创建Pod所对应的podspec文件。 本地测试配置好的podspec文件是否可用。 向私有的Spec Repo中提交podspec。 在个人项目中的Podfile中增加刚刚制作的好的Pod并使用。 更新维护podspec。 在这一系列的步骤中需要创建两个Git仓库，分别是第一步和第二步（第二步不一定非要是Git仓库，只要是可以获取到相关代码文件就可以，也可以是SVN的，也可以说zip包，区别就是在podspec中的source项填写的内容不同），并且第一步只是在初次创建私有podspec时才需要，之后在创建其他的只需要从第二步开始就可以。 本文只介绍在Git环境下的操作，其他环境其他方式不做讨论。 创建私有Spec Repo先来说第一步，什么是Spec Repo？他是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，他实际是一个Git仓库remote端。 在GitHub上，但是当你使用了Cocoapods后他会被clone到本地的~/.cocoapods/repos目录下，可以进入到这个目录看到master文件夹就是这个官方的Spec Repo了。这个master目录的结构是这个样子的： ├── Specs └── [SPEC_NAME] └── [VERSION] └── [SPEC_NAME].podspec 因此我们需要创建一个类似于master的私有Spec Repo。 这里我们可以fork官方的Repo，也可以自己创建，个人建议不fork，因为我们只是想添加自己的Pods，没有必要把现有的公开Pods都copy一份。 所以创建一个 Git仓库，这个仓库可以创建私有的也可以创建公开的，不过既然私有的Spec Repo，还是创建私有的仓库吧，需要注意的就是如果项目中有其他同事共同开发的话，你还要给他这个Git仓库的权限。因为GitHub的私有仓库是收费的，所以建议使用其他Git服务，比如CODING，当然还有其他的可供选择开源中国、Bitbucket以及CSDN。 创建完成之后在终端中执行如下命令： # pod repo add [Private Repo Name] [GitHub HTTPS clone URL] $ pod repo add DemoSpecs https://git.dev.tencent.com/iDog/DemoSepcs.git 此时如果成功的话进入到~/.cocoapods/repos目录下就可以看到DemoSpecs这个目录了。至此第一步创建私有Spec Repo完成。 如果有其他合作人员共同使用这个私有Spec Repo的话在他有对应Git仓库的权限的前提下执行相同的命令添加这个Spec Repo即可。 创建Pod项目工程文件这个第二步没有什么好介绍的，如果是有现有的组件项目，并且在Git的版本管理下，那么这一步就算完成了，可以直接进行下一步了。 不过我们的组件还在你冗余庞大的项目中，需要拆分出来或者需要自己从零开始创建一个组件库，那么建议使用Cocoapods提供的一个工具将第二步与第三步结合起来做。 现在来说一下这个工具，相关的文档介绍是Using Pod Lib Create ,就拿我创建的podTestLibrary为例子具体讲一下这里是如何操作的，先cd到要创建项目的目录然后执行： $ pod lib create DSButton 之后他会问你几个问题： To get you started we need to ask a few questions, this should only take a minute. 2019-08-20 11:11:49.065 defaults[30170:835168] The domain/default pair of (org.cocoapods.pod-template, HasRunBefore) does not exist If this is your first time we recommend running through with the guide: - https://guides.cocoapods.org/making/using-pod-lib-create.html ( hold cmd and click links to open in a browser. ) Press return to continue. What platform do you want to use?? [ iOS / macOS ] &gt; iOS What language do you want to use?? [ Swift / ObjC ] &gt; ObjC Would you like to include a demo application with your library? [ Yes / No ] &gt; Yes Which testing frameworks will you use? [ Specta / Kiwi / None ] &gt; None Would you like to do view based testing? [ Yes / No ] &gt; No What is your class prefix? &gt; DS 问题和答案如上。 问完这几个问题他会自动执行pod install命令创建项目并生成依赖。 $ tree DSButton -L 2 DSButton ├── Example #demo APP │ ├── DSButton │ ├── DSButton │ ├── DSButtonxcworkspace │ ├── Podfile #demo APP 的依赖描述文件 │ ├── Podfile.lock │ ├── Pods #demo APP 的依赖文件 │ └── Tests ├── LICENSE #开源协议 默认MIT ├── Pod #组件的目录 │ ├── Assets #资源文件 │ └── Classes #类文件 ├── DSButton.podspec #第三步要创建的podspec文件 └── README.md #markdown格式的README 9 directories, 5 files 接下来就是向Pod文件夹中添加库文件和资源，并配置podspec文件，我把一个DSButton的共有组件放入Pod/Classes中，然后进入Example文件夹执行pod update命令，再打开项目工程可以看到，刚刚添加的组件已经在Pods子工程下Development Pods/DSButton中了，然后编辑demo工程，测试组件，我并没有使用提供的测试框架进行测试，这里就先不介绍了。 这里需要注意的是每当你向Pod中添加了新的文件或者以后更新了podspec的版本都需要重新执行一遍pod update命令。 测试无误后需要将该项目添加并推送到远端仓库，并编辑podspec文件。 通过Cocoapods创建出来的目录本身就在本地的Git管理下，我们需要做的就是给它添加远端仓库，同样去GitHub或其他的Git服务提供商那里创建一个私有的仓库，拿到SSH或者HTTP地址，然后cd到DSButton目录。 $ git add . $ git commit -s -m &quot;Initial Commit of Library&quot; $ git remote add origin https://git.dev.tencent.com/iDog/DSButton.git #添加远端仓库 $ git push origin master #提交到远端仓库 因为podspec文件中获取Git版本控制的项目还需要tag号，所以我们要打上一个tag： $ git tag -m &quot;first release&quot; 0.1.0 $ git push --tags #推送tag到远端仓库 做完这些就可以开始编辑podspec文件了，它是一个Ruby的文件，把编辑器的格式改成Ruby就能看到语法高亮，下面我贴上我的podspec文件，并在后面以注释的形式说明每个字段的含义，没有涉及到的字段可以去官方文档查阅 # Be sure to run `pod lib lint podTestLibrary.podspec&apos; to ensure this is a # valid spec before submitting. # # Any lines starting with a # are optional, but their use is encouraged # To learn more about a Podspec see https://guides.cocoapods.org/syntax/podspec.html # Pod::Spec.new do |s| s.name = &apos;DSButton&apos; s.version = &apos;0.1.0&apos; s.summary = &apos;A short description of podTestLibrary.&apos; # This description is used to generate tags and improve search results. # * Think: What does it do? Why did you write it? What is the focus? # * Try to keep it short, snappy and to the point. # * Write the description between the DESC delimiters below. # * Finally, don&apos;t worry about the indent, CocoaPods strips it! s.description = &lt;&lt;-DESC TODO: Add long description of the pod here. DESC s.homepage = &apos;https://dev.tencent.com/u/iDog/p/DSButton&apos; # s.screenshots = &apos;www.example.com/screenshots_1&apos;, &apos;www.example.com/screenshots_2&apos; s.license = { :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; } s.author = { &apos;iDog&apos; =&gt; &apos;idoghuan@163.com&apos; } s.source = { :git =&gt; &apos;https://git.dev.tencent.com/iDog/DSButton.git&apos;, :tag =&gt; s.version.to_s } # s.social_media_url = &apos;https://twitter.com/&lt;TWITTER_USERNAME&gt;&apos; s.ios.deployment_target = &apos;8.0&apos; s.source_files = &apos;podTestLibrary/Classes/**/*&apos; # s.resource_bundles = { # &apos;podTestLibrary&apos; =&gt; [&apos;podTestLibrary/Assets/*.png&apos;] # } # s.public_header_files = &apos;Pod/Classes/**/*.h&apos; # s.frameworks = &apos;UIKit&apos;, &apos;MapKit&apos; # s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos; end 编辑完podspec文件后，需要验证一下这个文件是否可用，如果有任何WARNING或者ERROR都是不可以的，它就不能被添加到Spec Repo中，不过Xdode的WARNING是可以存在的，验证需要执行一下命令 pod spec lint xxx.podspec --verbose 如果输出如下： DSButton.podspec passed validation. 说明验证通过了，不过这只是这个podspec文件是合格的，不一定说明这个Pod是可以用的，我们需要在本地做一下验证，这就是第四步的内容了，第四步在具体说明。 创建podspec文件如果从第二步过来，已经有了现成的项目，那么就需要给这个项目创建一个podspec文件，创建它需要执行Cocoapods的另外一个命令，官方文档在这里 $ pod spec create DemoSepcs git@git.dev.tencent.com:iDog/DemoSepcs.git 执行完之后，就创建了一个podspec文件，他其中会包含很多内容，可以按照我之前介绍的进行编辑，没用的删掉。编辑完成之后使用验证命令验证一下 pod spec lint xxx.podspec --verbose 验证无误就可以进入下一步了。 向Spec Repo提交podspec向Spec Repo提交podspec需要完成两点一个是podspec必须通过验证无误，在一个就是删掉无用的注释（这个不是必须的，为了规范还是删掉吧）。 向我们的私有Spec Repo提交podspec只需要一个命令。 $ pod repo push DemoSpecs DSButton.podspec #前面是本地Repo名字 后面是podspec名字 完成之后这个组件库就添加到我们的私有Spec Repo中了，可以进入到~/.cocoapods/repos/DemoSpecs目录下查看 ├── LICENSE ├── DemoSpecs │ └── 0.2.0 │ └── DSButton.podspec └── README.md 再去看我们的Spec Repo远端仓库，也有了一次提交，这个podspec也已经被push上去了。 至此，我们的这个组件库就已经制作添加完成了，使用pod search命令就可以查到我们自己的库了 -&gt; DSButton (0.2.0) A short description of DSButton. pod &apos;DSButton&apos;, &apos;~&gt; 0.2.0&apos; - Homepage: https://dev.tencent.com/u/iDog/p/DSButton - Source: https://git.dev.tencent.com/iDog/DSButton.git - Versions: 0.2.0 [DemoSpecs repo] 这里说的是添加到私有的Repo，如果要添加到Cocoapods的官方库了，可以使用trunk工具，具体可以查看官方文档 使用制作好的Pod在完成这一系列步骤之后，我们就可以在正式项目中使用这个私有的Pod了只需要在项目的Podfile里增加以下一行代码即可 $ pod &apos;DSButton&apos;, &apos;~&gt; 0.2.0&apos; 然后执行pod update，更新库依赖，然后打开项目可以看到，我们自己的库文件已经出现在Pods子项目中的Pods子目录下了，而不再是Development Pods。 更新维护podspec说一下制作好的podspec文件后续的更新维护工作，比如如何添加新的版本，如何删除Pod。 我已经制作好了DSButton的0.2.0版本，现在我对他进行升级工作，这次我添加了更多的模块到DSButton之中。这里又尝试了一下subspec功能，给DSButton创建了多个子分支。 具体做法是先将源文件添加到Pod/Classes中，然后按照不同的模块对文件目录进行整理，因为我有四个模块，所以在Pod/Classes下有创建了四个子目录，完成之后继续编辑之前的DSButton.podspec，这次增加了subspec特性。 # Be sure to run `pod lib lint DSButton.podspec&apos; to ensure this is a # valid spec before submitting. # # Any lines starting with a # are optional, but their use is encouraged # To learn more about a Podspec see https://guides.cocoapods.org/syntax/podspec.html # Pod::Spec.new do |s| s.name = &apos;DSButton&apos; s.version = &apos;0.3.0&apos; s.summary = &apos;A short description of DSButton.&apos; # This description is used to generate tags and improve search results. # * Think: What does it do? Why did you write it? What is the focus? # * Try to keep it short, snappy and to the point. # * Write the description between the DESC delimiters below. # * Finally, don&apos;t worry about the indent, CocoaPods strips it! s.description = &lt;&lt;-DESC TODO: Add long description of the pod here. DESC s.homepage = &apos;https://dev.tencent.com/u/iDog/p/DSButton&apos; # s.screenshots = &apos;www.example.com/screenshots_1&apos;, &apos;www.example.com/screenshots_2&apos; s.license = { :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; } s.author = { &apos;liuhuan&apos; =&gt; &apos;idoghuan@163.com&apos; } s.source = { :git =&gt; &apos;https://git.dev.tencent.com/iDog/DSButton.git&apos;, :tag =&gt; s.version.to_s } # s.social_media_url = &apos;https://twitter.com/&lt;TWITTER_USERNAME&gt;&apos; s.ios.deployment_target = &apos;8.0&apos; s.requires_arc = true #s.source_files = &apos;DSButton/Classes/**/*&apos; # s.resource_bundles = { # &apos;DSButton&apos; =&gt; [&apos;DSButton/Assets/*.png&apos;] # } s.subspec &apos;DSButtton&apos; do |ds| ds.source_files = &apos;DSButton/Classes/DSButtton/*.{h,m}&apos; ds.public_header_files = &apos;DSButton/Classes/DSButtton/*.h&apos; end s.subspec &apos;DSButttonA&apos; do |a| a.source_files = &apos;DSButton/Classes/DSButttonA/*.{h,m}&apos; a.public_header_files = &apos;DSButton/Classes/DSButttonA/*.h&apos; a.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos; end s.subspec &apos;DSButttonB&apos; do |b| b.source_files = &apos;DSButton/Classes/DSButttonB/*.{h,m}&apos; b.public_header_files = &apos;DSButton/Classes/DSButttonB/*.h&apos; b.dependency &apos;OpenUDID&apos; end s.subspec &apos;DSButttonC&apos; do |c| c.source_files = &apos;DSButton/Classes/DSButttonC/*.{h,m}&apos; c.public_header_files = &apos;DSButton/Classes/DSButttonC/*.h&apos; #c.dependency &apos;DSButtton/DSButtton&apos; end # s.public_header_files = &apos;Pod/Classes/**/*.h&apos; s.frameworks = &apos;UIKit&apos; # s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos; end 因为我们创建了subspec所以项目整体的依赖dependency，源文件source_files，头文件public_header_files，资源文件resource等都移动到了各自的subspec中。 每个subspec之间也可以有相互的依赖关系，比如DSButttonC就依赖于DSButtton。依赖失败。 编辑完成之后，在测试项目里pod update一下，几个子项目都被加进项目工程了，写代码验证无误之后，就可以将这个工程push到远端仓库，并打上新的tag-&gt;0.3.0。 最后再次使用pod lib lint验证编辑好的podsepc文件，没有自身的WARNING或者ERROR之后，就可以再次提交到Spec Repo中了，命令跟之前是一样的。 pod repo push DemoSpecs DSButton.podspec --verbose --allow-warnings 之后再次到~/.cocoapods/repos/DemoSpecs目录下查看 . ├── DSButton │ ├── 0.2.0 │ │ └── DSButton.podspec │ └── 0.3.0 │ └── DSButton.podspec ├── LICENSE └── README.md 3 directories, 4 files 已经有两个版本了，使用pod search查找得到的结果为 -&gt; DSButton (0.3.0) A short description of DSButton. pod &apos;DSButton&apos;, &apos;~&gt; 0.3.0&apos; - Homepage: https://dev.tencent.com/u/iDog/p/DSButton - Source: https://git.dev.tencent.com/iDog/DSButton.git - Versions: 0.3.0, 0.2.0 [DemoSpecs repo] - Subspecs: - DSButton/DSButtton (0.3.0) - DSButton/DSButttonA (0.3.0) - DSButton/DSButttonB (0.3.0) - DSButton/DSButttonC (0.3.0) 完成这些之后，在实际项目中我们就可以选择使用整个组件库或者是组件库的某一个部分了，对应的Podfile中添加的内容为 source &apos;https://github.com/CocoaPods/Specs.git&apos; # 官方库 source &apos;https://git.dev.tencent.com/iDog/DemoSepcs.git&apos; # 私有库 platform :ios, &apos;8.0&apos; target &quot;TestButton&quot; do pod &apos;DSButton/DSButttonA&apos; #导入小组件 pod &apos;DSButton/DSButttonB&apos; #导入小组件 pod &apos;DSButton&apos; #导入全部组件 end 删除和添加删除一个私有Spec Repo，只需要执行一条命令即可 $ pod repo remove DSButton 这样这个Spec Repo就在本地删除了，我们还可以通过 $ pod repo add DemoSepcs git@git.dev.tencent.com:iDog/DemoSepcs.git 再把它给加回来。 如果我们要删除私有Spec Repo下的某一个podspec怎么操作呢，此时无需借助Cocoapods，只需要cd到~/.cocoapods/repos/DemoSpecs目录下，删掉库目录 $ rm -Rf DemoSpecs 然后在将Git的变动push到远端仓库即可。 $ git add . $ git ci -m &quot;remove unuseful pods&quot; $ git push origin master 常见问题 error: unable to find utility “simctl”, not a developer tool or in PATH 解决方案就是去xcode设置里面，将Command line Tools设置一下，在Xcode&gt;preferences&gt;Locations里面，设置之后再运行终端即可 The spec did not pass validation, due to 1 warning (but you can use --allow-warnings to ignore it). $ pod spec lint xxx.podspec --verbose --allow-warnings 如果.podspec文件验证通过还是报如下的错误： specification does not validate $ pod repo push DemoSpecs DSButton.podspec --verbose --allow-warnings pod search时报错： Unable to find a pod with name, author, summary, or description matching $ rm ~/Library/Caches/CocoaPods/search_index.json $ pod search DSButton 参考博客","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"从App启动开始","slug":"从App启动开始","date":"2019-05-17T03:34:23.000Z","updated":"2022-11-06T01:25:58.362Z","comments":true,"path":"2019/05/17/从App启动开始/","link":"","permalink":"https://bigporo.github.io/2019/05/17/从App启动开始/","excerpt":"App启动时都干了哪些事？一般情况下，App的启动分为冷启动和热启动。 冷启动App点击启动前，它的进程不在系统里，需要系统新创建一个进程给它启动的情况，这是一次完成的启动过程。 热启动APP在冷启动后被用户退到后台，在App的进程还在系统里的情况下，用户重新启动进入App的过程，这个过程所做的事情非常少。","text":"App启动时都干了哪些事？一般情况下，App的启动分为冷启动和热启动。 冷启动App点击启动前，它的进程不在系统里，需要系统新创建一个进程给它启动的情况，这是一次完成的启动过程。 热启动APP在冷启动后被用户退到后台，在App的进程还在系统里的情况下，用户重新启动进入App的过程，这个过程所做的事情非常少。 都做了什么事一般来说，App的启动时间，是指用户点击App开始，到用户看到第一个界面之前的时间。包含如下三个阶段： main()函数执行前； main()函数执行后； 首屏渲染完成后。 main()函数执行前main()函数执行前，系统主要做下面几件事。 加载可执行文件(App的.o文件的集合) 加载动态链接库，进行rebase指针调整和bind符号绑定 Objc运行时的初始处理，包括Objc相关类的注册、category注册、selector唯一性检查等 初始化，包含了执行+load()方法、attribute((constructor))修饰的函数的调用、创建C++静态全局变量。 所以一般优化启动速度的话可以做如下几件事： 减少动态库加载。每个库本身都有依赖关系，苹果公司建议使用更少的动态库，并且建议在使用动态库的数量较多时，尽量将多个动态库进行合并。 减少加载启动后不会去使用的类和方法。 +load() 方法里的内容可以放到首屏渲染完成后再执行，或使用 +initialize() 方法替换掉。因为，在一个 +load() 方法里，进行运行时方法替换操作会带来 4 毫秒的消耗。不要小看这 4 毫秒，积少成多，执行 +load() 方法对启动速度的影响会越来越大。 控制C++全局变量的数量。 main()函数执行后main()函数执行后的阶段，指的是从main()函数执行开始，到appDelegate的didFinishLaunchingWithOptions方法里首屏渲染相关方法执行完成。 首页的业务代码都是要在这个阶段，主要包括了： 首屏初始化所需配置文件的读写操作； 首屏列表大数据的读取； 首屏渲染的大量计算等。 在日常操作中，我们总是把各种初始化工作都放到这个阶段执行，导致渲染完成滞后。 更加优化的方法应该是：在功能上梳理出那些是首屏渲染必要的初始化功能，哪些是App启动必要的初始化功能，哪些是在对应功能开始使用才需要初始化的。将这些初始化功能分别放到合适的阶段执行。 首屏渲染完成后这个阶段是从渲染完成时开始，到didFinishLaunchingWithOptions方法作用域结束时结束。 这个阶段用户已经可以看到App的首页信息了，所以优化的优先级排在最后。但是那些卡住主线程的方法还是需要最优先处理的。 怎么优化主要是功能级别优化和方法级别优化。 功能级别优化从main()函数执行后这个阶段下手。 优化的思路是：main()函数开始执行到首屏渲染完成前，只处理首屏相关的业务，其他非首屏业务的初始化、监听注册、配置文件的读写等都放到首屏渲染完成后去做。 方法级别优化这个阶段主要是检查首屏渲染完成前，主线程上有哪些耗时方法，将不必要的耗时方法滞后或者异步执行。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"}]},{"title":"怎么应对各种富文本表现需求？","slug":"怎么应对各种富文本表现需求？","date":"2019-05-17T02:23:12.000Z","updated":"2019-05-17T03:33:03.000Z","comments":true,"path":"2019/05/17/怎么应对各种富文本表现需求？/","link":"","permalink":"https://bigporo.github.io/2019/05/17/怎么应对各种富文本表现需求？/","excerpt":"前言在iOS的日常开发中，会经常使用到富文本。 简单来说，富文本就是一段有属性的字符串，可以包含不同字体、不同字号、不同背景、不同颜色、不同字间距的文字，还可以设置段落、图文混排等属性。 正常在使用富文本的时候，有如下方式：HTML、TextKit、YYKit。一般在长列表的场景下，我们使用性能更高、内存占用更少的TextKit、YYKit。","text":"前言在iOS的日常开发中，会经常使用到富文本。 简单来说，富文本就是一段有属性的字符串，可以包含不同字体、不同字号、不同背景、不同颜色、不同字间距的文字，还可以设置段落、图文混排等属性。 正常在使用富文本的时候，有如下方式：HTML、TextKit、YYKit。一般在长列表的场景下，我们使用性能更高、内存占用更少的TextKit、YYKit。 WebView加载HTML这个是个常规操作 1[self.wbView loadHTMLString:articleString baseURL:nil]; 与loadRequest方法相比，loadHTMLString可以直接读取HTML代码，省去了网络请求的时间，展示速度很快。 不过HTML里面的图片资源还是需要通过网络获取的，如果能够在展示之前就缓存下图片，无需等待，就能够快速的展示了。 如何缓存HTML里面的图片在Cocoa层使用NSURLProtocol可以拦截所有HTTP请求，所有可以利用NSURLProtocol来缓存文章中的图片。 推荐戴铭的这个Web页面预加载库STMURLCache来预缓存HTML里面的图片。具体的使用方法都在仓库里面。 YYText集成十分简单，cocoapods就可以。下面看下如何使用:1234567891011121314151617181920NSMutableAttributedString *text = [NSMutableAttributedString new];UIFont *font = [UIFont systemFontOfSize:16];NSMutableAttributedString *attachment = nil; // 嵌入 UIImageUIImage *image = [UIImage imageNamed:@&quot;dribbble64_imageio&quot;];attachment = [NSMutableAttributedString yy_attachmentStringWithContent:image contentMode:UIViewContentModeCenter attachmentSize:image.size alignToFont:font alignment:YYTextVerticalAlignmentCenter];[text appendAttributedString: attachment]; // 嵌入 UIViewUISwitch *switcher = [UISwitch new];[switcher sizeToFit];attachment = [NSMutableAttributedString yy_attachmentStringWithContent:switcher contentMode:UIViewContentModeBottom attachmentSize:switcher.size alignToFont:font alignment:YYTextVerticalAlignmentCenter];[text appendAttributedString: attachment]; // 嵌入 CALayerCASharpLayer *layer = [CASharpLayer layer];layer.path = ...attachment = [NSMutableAttributedString yy_attachmentStringWithContent:layer contentMode:UIViewContentModeBottom attachmentSize:switcher.size alignToFont:font alignment:YYTextVerticalAlignmentCenter];[text appendAttributedString: attachment]; 最后对比代码可以看到，原生代码描述富文本跟HTML比，既啰嗦又复杂。HTML代码更已读、更容易维护，所以除了长列表外，都建议使用HTML来描述富文本。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"}]},{"title":"《剑指Offer》读书总结","slug":"《剑指Offer》读书总结","date":"2019-04-25T02:42:13.000Z","updated":"2019-05-16T03:46:50.000Z","comments":true,"path":"2019/04/25/《剑指Offer》读书总结/","link":"","permalink":"https://bigporo.github.io/2019/04/25/《剑指Offer》读书总结/","excerpt":"面试的三个环节行为面试 主要是暖场，需要快速调节以进入面试状态。 项目经验 项目背景：项目的规模，开发的软件的功能，目标用户等。 任务：详细介绍自己的的任务，注意区分“参与”和“负责”。 具体工作：介绍完成任务所做的工作，可以具体到结构、框架、技术细节等。 贡献：详细介绍在任务中的贡献，最好可以数字化。","text":"面试的三个环节行为面试 主要是暖场，需要快速调节以进入面试状态。 项目经验 项目背景：项目的规模，开发的软件的功能，目标用户等。 任务：详细介绍自己的的任务，注意区分“参与”和“负责”。 具体工作：介绍完成任务所做的工作，可以具体到结构、框架、技术细节等。 贡献：详细介绍在任务中的贡献，最好可以数字化。 可能会问的问题 在该项目中遇到的最大的问题是什么？ 从这个项目中学到了什么？ 什么时候会和其他成员有怎样的冲突？怎么解决的？ 为什么跳槽需要避免以下原因： 老板太苛刻 同事难相处 加班太频繁 工资太低(即使是实际原因也不建议说) 常规回答： 现在的工作做的太久，没有激情了，希望有一份更有挑战性的工作。 现在的工作的方向和自己预想的有偏差。 技术面试这块是重头戏，对面试的结果会有决定性的影响。一般会关注如下几个方面： 基础知识扎实全面，包括编程语言、数据结构、算法等。 能写出高质量的代码。 能思路清晰的分析和解决复杂问题。 能从时间、空间复杂度两个方面优化算法的效率。 具备优秀的沟通能力、学习能力、发散思维等能力。 应聘者提问环节 不要问与自己入职之后的工作无关的问题。 不要问薪水，技术面试不是问薪水的时候。 不要立刻打听面试的结果。 面试需要的基础知识编程语言:C++、C#（卒） 数据结构数组 占据一块连续的内存并按照顺序存储数据，初始化时就已经确定了大小，然后根据大小分配内存。所以导致空间效率不是很好。 数组的内存是连续的，所以根据下标进行读写的时候，时间效率很高。 动态数组可以在一定程度上解决空间效率不高的问题，但是每一次扩充数组的时候都有大量的额外操作，对时间性能有影响。 字符串在C#中，封装字符串的类型System.String有一个非常特殊的性质：String中的内容是不能改变的。一旦试图改变String的内容，就会产生一个新的实例。 链表内存分配不是在创建链表时一次性完成，而是每添加一个结点分配一次内存。没有闲置的内存，所以空间效率比较高。 树逻辑除了根结点之外每个结点只有一个父结点，根结点没有父结点；除了叶结点之外所有结点都有一个或多个子结点，叶结点没有子结点。父结点和子结点之间用指针链接。 遍历方式 前序遍历：先访问根结点，再访问左子结点，最后访问右子结点。 中序遍历：先访问左子结点，再访问根结点，最后访问右子结点。 后序遍历：先访问左子结点，再访问右子结点，最后访问根结点。 后序遍历：先访问左子结点，再访问右子结点，最后访问根结点。 堆：堆分为最大堆和最小堆。在最大堆中根结点的值最大，在最小堆中根结点的值最小。有很多需要快速找到最大值或者最小值的问题都可以用堆来解决。 红黑树：红黑树是把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短路径的两倍。 二叉树：数中的每个节点只能有两个子节点。 栈和队列栈特点：后进先出，弹栈。 队列特点：先进先出。 算法和数据操作重点掌握二分查找、归并排序和快速排序，做到能随时正确、完整地写出它们的代码。 查找和排序查找顺序查找、二分查找、哈希表查找、二叉排序树查找 排序插入排序、冒泡排序、归并排序、快速排序等。 递归和循环递归 斐波拉契数列: f(n) = f(n-1) + f(n-2).面试题：青蛙上台阶。 通常递归的代码会比较简洁。 但是递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址及临时变量，而且往栈里压入数据和弹出数据都需要时间。严重的话会造成栈溢出。 递归中可能会有很多重复的计算，对性能造成负面影响。 位运算位运算是把数字用二进制表示之后，对每一位上0或者1的运算。 位运算总共只有五种运算：与、或、异或、左移和右移。 高质量的代码 若干经典面试题 书写清晰、布局清晰、命名合理。 考虑边界情况和特殊情况，提升代码的完整性。 提升代码的鲁棒性(健壮性)。 解决面试题的思路 画图让抽象问题具象化。 举例让抽象问题具体化。 分解让复杂问题简单化。 优化空间效率和时间效率权衡好空间换时间。 面试中的各项能力两个案列","categories":[{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/categories/读书/"}],"tags":[{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/tags/读书/"}]},{"title":"ImageOptim - 图片压缩","slug":"ImageOptim - 图片压缩","date":"2019-04-23T09:17:43.000Z","updated":"2019-08-12T14:50:57.000Z","comments":true,"path":"2019/04/23/ImageOptim - 图片压缩/","link":"","permalink":"https://bigporo.github.io/2019/04/23/ImageOptim - 图片压缩/","excerpt":"下载地址 ImageOptim是一款基于Mac的图像“瘦身”软件，内置有6种压缩算法，通过删除图片部分无用的EXIF等信息来减小PNG、JPEG和GIF图片的大小。","text":"下载地址 ImageOptim是一款基于Mac的图像“瘦身”软件，内置有6种压缩算法，通过删除图片部分无用的EXIF等信息来减小PNG、JPEG和GIF图片的大小。ImageOptim合并了OptiPNG、PNGCrush、AdvanceComp、PNGOUT、Jpegoptim+Jpegtran和Gifsicle等几个工具，旨在为设计师提供最好的优化效果。在最新发布的1.4.4版本中，ImageOptim改进了文件在文件列表中的拖拽、复制、粘贴功能。","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"Injection：iOS热重载-所见即所得","slug":"Injection：iOS热重载-所见即所得","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T09:23:45.000Z","comments":true,"path":"2019/04/23/Injection：iOS热重载-所见即所得/","link":"","permalink":"https://bigporo.github.io/2019/04/23/Injection：iOS热重载-所见即所得/","excerpt":"","text":"参考博客 参考博客","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"Fastlane--自动打包","slug":"Fastlane-自动打包","date":"2019-04-23T09:17:43.000Z","updated":"2019-08-12T14:39:37.000Z","comments":true,"path":"2019/04/23/Fastlane-自动打包/","link":"","permalink":"https://bigporo.github.io/2019/04/23/Fastlane-自动打包/","excerpt":"Fastlane是一套使用Ruby写的自动化工具集，旨在简化Android和iOS的部署过程，自动化你的工作流。它可以简化一些乏味、单调、重复的工作，像截图、代码签名以及发布App","text":"Fastlane是一套使用Ruby写的自动化工具集，旨在简化Android和iOS的部署过程，自动化你的工作流。它可以简化一些乏味、单调、重复的工作，像截图、代码签名以及发布App 安装安装xcode命令行工具xcode-select –install，如果没有安装，会弹出对话框，点击安装。如果提示1xcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates 表示已经安装 安装Fastlanegem install fastlane -NV```或是 ```brew cask install fastlane ```123我这里使用第一种方式安装的如果报错： ERROR: While executing gem … (Errno::EPERM) Operation not permitted - /usr/bin/commander1执行: sudo gem install -n /usr/local/bin fastlane1完成之后执行: fastlane –version1确认下是否安装完成和当前使用的版本号。 fastlane installation at path: /Library/Ruby/Gems/2.3.0/gems/fastlane-2.117.1/bin/fastlane[✔] 🚀fastlane 2.117.1 123## 初始化Fastlanecd到你的项目目录执行``` fastlane init 1234567891. 📸 Automate screenshots2. 👩‍✈️ Automate beta distribution to TestFlight3. 🚀 Automate App Store distribution4. 🛠 Manual setup - manually setup your project to automate your tasks? Ambiguous choice. Please choose one of [1, 2, 3, 4, 📸 Automatescreenshots, 👩‍✈️ Automate beta distribution to TestFlight, 🚀 AutomateApp Store distribution, 🛠 Manual setup - manually setup your project toautomate your tasks]. 选几都行，后续我们自行根据需求完善就可以，这里我选的是3。12[17:38:53]: Please enter your Apple ID developer credentials[17:38:53]: Apple ID Username: 按照提示输入开发者账号和密码，登录成功后会提示你是否需要下载你的App的metadata。点y等待就可以。 文件夹结构初始化成功后会在当前工程目录生成一个fastlane文件夹，文件目录为下。 metadata和screenshots分别对应App元数据和商店应用截图。 Appfile主要存放App的apple_id team_id app_identifier等信息 Deliverfile中为发布的配置信息，一般情况用不到。 Fastfile是我们最应该关注的文件，也是我们的工作文件。 Fastfile文件内容如下:123456789101112131415161718192021222324# This file contains the fastlane.tools configuration# You can find the documentation at https://docs.fastlane.tools## For a list of all available actions, check out## https://docs.fastlane.tools/actions## For a list of all available plugins, check out## https://docs.fastlane.tools/plugins/available-plugins## Uncomment the line if you want fastlane to automatically update itself# update_fastlanedefault_platform(:ios)platform :ios do desc &quot;Push a new release build to the App Store&quot; lane :release do build_app(workspace: &quot;XXX.xcworkspace&quot;, scheme: &quot;XXX&quot;) upload_to_app_store endend 之前我们了解了action，那action的组合就是一个lane，打包到蒲公英是一个lane，打包到应用商店是一个lane，打包到testflight也是一个lane。可能理解为任务会好一些。 打包到蒲公英这里以打包上传到蒲公英为例子，实现我们的一行命令自动打包。 蒲公英在Fastlane是作为一个插件存在的，所以要打包到蒲公英必须先安装蒲公英的插件。 打开终端输入fastlane add_plugin pgyer 更多信息查看蒲公英文档 新建一个lane:12345678910111213desc &quot;打包到pgy&quot;lane :test do |options|gym( clean:true, #打包前clean项目 export_method: &quot;ad-hoc&quot;, #导出方式 scheme:&quot;shangshaban&quot;, #scheme configuration: &quot;Debug&quot;,#环境 output_directory:&quot;./app&quot;,#ipa的存放目录 output_name:get_build_number()#输出ipa的文件名为当前的build号 )#蒲公英的配置 替换为自己的api_key和user_keypgyer(api_key: &quot;xxxxxxx&quot;, user_key: &quot;xxxxxx&quot;,update_description: options[:desc])end option用于接收我们的外部参数，这里可以传入当前build的描述信息到蒲公英平台 执行在工作目录的终端执行 1fastlane test desc:测试打包 打包成功12345678910111213[10:17:35]: Upload success. Visit this URL to see: https://www.pgyer.com/feixiuman+------+------------------+-------------+| fastlane summary |+------+------------------+-------------+| Step | Action | Time (in s) |+------+------------------+-------------+| 1 | default_platform | 0 || 2 | gym | 129 || 3 | pgyer | 12 |+------+------------------+-------------+[10:17:35]: fastlane.tools finished successfully 🎉 参考博客 参考博客 Github 官网 文档","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"Reveal 4.0 使用指南","slug":"Reveal 4.0 使用指南","date":"2019-04-23T09:17:43.000Z","updated":"2019-08-12T14:37:52.000Z","comments":true,"path":"2019/04/23/Reveal 4.0 使用指南/","link":"","permalink":"https://bigporo.github.io/2019/04/23/Reveal 4.0 使用指南/","excerpt":"Reveal 简介Reveal是一款iOS程序界面调试工具，可以让我们在开发时动态的查看和修改APP的界面。免去了每次修改完代码重新启动的痛苦。 启动界面如下图：","text":"Reveal 简介Reveal是一款iOS程序界面调试工具，可以让我们在开发时动态的查看和修改APP的界面。免去了每次修改完代码重新启动的痛苦。 启动界面如下图： Reveal 的安装安装很简单，直接下载一路到底就可以。 官方正版下载地址 破解版下载地址 Reveal 的使用集成方式官方一共提供了三种集成方式 三种集成指南对比 使用cocoapods集成 app内集成Reveal Server framework 利用Xcode的Breakpoint 断点加载Reveal Server 对比:1和2基本相似，需要修改工程文件，3不需要修改工程文件，选用第3种。 利用Xcode的Breakpoint 断点加载Reveal Server 在Xcode中添加一个Symbolic Breakpoint.右击这个断点，编辑如下图: Action里面填写的内容如下:1expr (Class)NSClassFromString(@&quot;IBARevealLoader&quot;) == nil ? (void *)dlopen(&quot;/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/RevealServer.framework/RevealServer&quot;, 0x2) : ((void*)0) 右键当前断点,选择Move Breakpoint To → User。 Xcode 选择9.0系统 ,模拟器运行项目。 运行好项目后,Reveal自动显示，双击即可查看效果。 Reveal在真机中调试应用在真机中调试的安装方法，需要添加静态库到工程中，略微麻烦。 尝试操作了一遍，太麻烦了，卒。 Reveal在调试其它应用的安装方法在Reveal中调试其它应用，需要一部越狱的手机，没越狱的手机没办法调试。(本人没有，咩有尝试) 参考博客","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"LSUnusedResources -无用资源查找","slug":"LSUnusedResources -无用资源查找","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T09:24:02.000Z","comments":true,"path":"2019/04/23/LSUnusedResources -无用资源查找/","link":"","permalink":"https://bigporo.github.io/2019/04/23/LSUnusedResources -无用资源查找/","excerpt":"下载地址","text":"下载地址 核心步骤，简述如下： 查找：选定的目录下的所有资源文件。这一步与上述方案1区别不大，都是调用 find 命令查找指定后缀名的文件。 匹配：与上述方案不同，我不是对每个资源文件名都做一次全文搜索匹配，因为加入项目的资源太多，这里会导致性能快速下降。而我只是针对源码、Xib、Storyboard 和 plist 等文件，先全文搜索其中可能是引用了资源的字符串，然后用资源名和字符串做匹配。 使用方法 点击 Browse.. 选择一个文件夹； 点击 Search 开始搜索； 等待片刻即可看到结果。","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"文档生成工具-appledoc","slug":"文档生成工具-appledoc","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T09:31:51.000Z","comments":true,"path":"2019/04/23/文档生成工具-appledoc/","link":"","permalink":"https://bigporo.github.io/2019/04/23/文档生成工具-appledoc/","excerpt":"简介做项目的人多了，就需要文档了。但是就源代码来说，文档最好和源码在一起，这样更新起来更加方便和顺手。象 Java 语言本身就自带 javadoc 命令，可以从源码中抽取文档。今天抽空调研了一下 Objective-C 语言的类似工具。","text":"简介做项目的人多了，就需要文档了。但是就源代码来说，文档最好和源码在一起，这样更新起来更加方便和顺手。象 Java 语言本身就自带 javadoc 命令，可以从源码中抽取文档。今天抽空调研了一下 Objective-C 语言的类似工具。 appledoc是命令行工具，可帮助Objective-C开发人员从特殊格式的源代码注释中生成类似Apple的源代码文档。它旨在为输入提供尽可能可读的源代码注释，并使用注释以及周围的源代码，以HTML的形式生成视觉上吸引人的文档以及完全索引和可浏览的Xcode文档集。虽然有几种工具可以为Objective-C创建HTML文档，但是我所知道的所有工具都无法满足下面描述的最低目标。 appledoc的主要目标： 人类可读的源代码注释。 对对象和成员的简单交叉引用。 生成类似Apple的源代码HTML文档。 生成并安装完全索引和可浏览的Xcode文档集。 单一工具，用于驱动从源代码解析到文档集安装的生成。 轻松定制输出。 100％Objective-C实现，易于调试。 安装那么简单介绍一下如何安装 appledoc，安装非常简单，只需要 2 步： 123git clone git://github.com/tomaz/appledoc.gitcd appledocsudo sh install-appledoc.sh 安装成功:123** INSTALL SUCCEEDED **install: /tmp/Build/Intermediates.noindex/ArchiveIntermediates/appledoc/InstallationBuildProductsLocation/usr/local/bin/appledoc -&gt; /usr/local/bin//appledoc 另外还有Homebrew： 1brew install appledoc Homebrew默认不安装模板。 安装提示要保持最新，只需转到终端并进入appledoc目录，发出git pull并重新编译appledoc.xcodeproj。不要忘记覆盖已复制到$ PATH的appledoc可执行文件:) 如果您还想编译并运行AppledocTests（单元测试）目标，则需要在构建单元测试目标之前将Libraries＆Frameworks组中指示的所有框架复制到共享框架目录！构建appledoc工具本身不需要这样做。 使用命令行输入:1appledoc --no-create-docset --output ~/Desktop --project-name Runtime_Demo --project-company iDog --company-id com.iDog /Users/idog/Desktop/Object-C_Demo/Runtime_Demo 成功之后可以看到:1appledoc version: 2.2.1 (build 1334) 参数解释: –no-create-docset // 不生成docset类型，生成html –output ~/Desktop // 文档生成的位置 –project-name Runtime_Demo //工程的名字，其实这个可以随便取，至少取成工程的名字可以知道这个文档是哪个 –project-company // 公司的名称 –company-id com.ZQD // 公司的id ~/Desktop/JieLin6/JieLin6/Helpers/ //你要生成文档的注释类所在的文件目录，及工程目录 注释的标准支持如下三种:1231. /*! this a test . */2. /** this a comment. */3. /// this is a long comment. */ 经常使用的标签： 12345678@brief : 使用它来写一段你正在文档化的method, PRoperty, class, file, struct, 或enum的短描述信息。@discusstion: 用它来写一段详尽的描述。如果需要你可以添加换行。@param:通过它你可以描述一个 method 或 function的参数信息。你可以使用多个这种标签。@return: 用它来制定一个 method 或 function的返回值。@see: 用它来指明其他相关的 method 或 function。你可以使用多个这种标签。@sa:同上@code ： 使用这个标签，你可以在文档当中嵌入代码段。当在Help Inspector当中查看文档时，代码通过在一个特别的盒子中用一种不同的字体来展示。始终记住在写的代码结尾处使用@endcode标签。@remark : 在写文档时，用它来强调任何关于代码的特殊之处。 举例：12/*! @brief This property knows my name. */@property (nonatomic, strong) NSString *myName; 记录文件常用标签： 123456789101112131415161718192021222324252627@file: 使用这个标签来指出你正在记录一个文件（header 文件或不是）。如果你将使用Doxygen来输出文档，那么你最好在这个标签后面紧接着写上文件名字。它是一个top level 标签。@header: 跟上面的类似，但是是在 HeaderDoc中使用。当你不使用 Doxygen时，不要使用上面的标签。@author：用它来写下这个文件的创建者信息@copyright: 添加版权信息@version: 用它来写下这个文件的当前版本。如果在工程生命周期中版本信息有影响时这会很重要。再一次的，我只给出最常用的标签。自己查看说明文档了解更多标签信息。@class: 用它来指定一个class的注释文档块的开头。它是一个top level标签，在它后面应该给出class名字。@interface: 同上@protocol: 同上两个一样，只是针对protocols@superclass: 当前class的superclass@classdesign: 用这个标签来指出你为当前class使用的任何特殊设计模式（例如，你可以提到这个class是不是单例模式或者类似其它的模式）。@coclass: 与当前class合作的另外一个class的名字。@helps: 当前class帮助的class的名字。@helper: 帮助当前class的class名字。 参考文档 项目主页","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"获取ipa包以及图片资源","slug":"获取ipa包以及图片资源","date":"2019-04-23T09:17:43.000Z","updated":"2019-08-12T14:53:07.000Z","comments":true,"path":"2019/04/23/获取ipa包以及图片资源/","link":"","permalink":"https://bigporo.github.io/2019/04/23/获取ipa包以及图片资源/","excerpt":"iTunnes降级首先，是需要将电脑上的itunes删除，然后下载一个低版本的替换最新的，这个方法比较麻烦的是因为itunes是系统的软件，删除会有影响系统的风险而且默认是不能删除的。所以该方法不推荐使用。 可以去这里下载需要的itunes。","text":"iTunnes降级首先，是需要将电脑上的itunes删除，然后下载一个低版本的替换最新的，这个方法比较麻烦的是因为itunes是系统的软件，删除会有影响系统的风险而且默认是不能删除的。所以该方法不推荐使用。 可以去这里下载需要的itunes。 使用Apple Configurator 2 安装Apple Configurator 2在mac的App Store上面，可以搜索到免费的Apple Configurator 2直接点击安装就可以。 打开App Configurator 2 点击账户，用手机上的AppleID进行登录。 手机连接电脑，然后点击“添加”,点击应用下载 下载完成后，会有一个弹窗，不用点任何按键，直接到电脑上的如下地址去找到刚下好的应用程序安装包。 1~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/ 拷贝ipa包，重命名为.zip格式文件，解压就可以了。 如何获取里面的png图片资源图片资源一般都在Assets.car文件中，如何打开Assets.car。我使用的是iOS Images Extractor,在解压后的的文件夹中找到ipa后缀的文件，右击显示包内容，就可以看到Assets.car文件，直接拖进到工具里面就可以输出图片资源文件夹了。 下载链接","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"Charles 从入门到精通","slug":"Charles 从入门到精通","date":"2019-04-23T09:17:43.000Z","updated":"2019-08-12T14:57:32.000Z","comments":true,"path":"2019/04/23/Charles 从入门到精通/","link":"","permalink":"https://bigporo.github.io/2019/04/23/Charles 从入门到精通/","excerpt":"巧神原文 本文是在巧神原文的基础上，按照流程走一遍并记录。 简介Charles 是在 Mac 下常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。 Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。 Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。 Charles 主要的功能包括： 截取 Http 和 Https 网络封包。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟慢速网络。","text":"巧神原文 本文是在巧神原文的基础上，按照流程走一遍并记录。 简介Charles 是在 Mac 下常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。 Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。 Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。 Charles 主要的功能包括： 截取 Http 和 Https 网络封包。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟慢速网络。 安装 Charles下载地址 将 Charles 设置成系统代理之前提到，Charles 是通过将自己设置成代理服务器来完成封包截取的，所以使用 Charles 的第一步是将其设置成系统的代理服务器。 启动 Charles 后，第一次 Charles 会请求你给它设置系统代理的权限。你可以输入登录密码授予 Charles 该权限。你也可以忽略该请求，然后在需要将 Charles 设置成系统代理时，选择菜单中的 “Proxy” -&gt; “Mac OS X Proxy” 来将 Charles 设置成系统代理。如下所示： 之后，你就可以看到源源不断的网络请求出现在 Charles 的界面中。 注意：开启了VPN之后，会导致抓取不到请求，需要关闭VPN。 Charles 主界面介绍Charles 主要提供两种查看封包的视图，分别名为 “Structure” 和 “Sequence”。 Structure 视图将网络请求按访问的域名分类。 Sequence 视图将网络请求按访问的时间排序。 大家可以根据具体的需要在这两种视图之前来回切换。请求多了有些时候会看不过来，Charles 提供了一个简单的 Filter 功能，可以输入关键字来快速筛选出 URL 中带指定关键字的网络请求。 对于某一个具体的网络请求，你可以查看其详细的请求内容和响应内容。如果请求内容是 POST 的表单，Charles 会自动帮你将表单进行分项显示。如果响应内容是 JSON 格式的，那么 Charles 可以自动帮你将 JSON 内容格式化，方便你查看。如果响应内容是图片，那么 Charles 可以显示出图片的预览。 过滤网络请求通常情况下，我们需要对网络请求进行过滤，只监控向指定目录服务器上发送的请求。对于这种需求，以下几种办法： 方法一：在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：https://www.ifeixiu.com, 那么只需要在 Filter 栏中填入 ifeixiu 即可。 方法二：在 Charles 的菜单栏选择 “Proxy”-&gt;”Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图所示：通常情况下，我们使用方法一做一些临时性的封包过滤，使用方法二做一些经常性的封包过滤。 方法三：在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项，如下图所示： 截取 iPhone 上的网络封包Charles 通常用来截取本地上的网络封包，但是当我们需要时，我们也可以用来截取其它设备上的网络请求。下面我就以 iPhone 为例，讲解如何进行相应操作。 Charles 上的设置要截取 iPhone 上的网络请求，我们首先需要将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 “Proxy”-&gt;”Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。如下图所示: iPhone 上的设置首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”-&gt;”Local IP Address”，即可在弹出的对话框中看到 IP 地址，如下图所示： 在 iPhone 的 “ 设置 “-&gt;” 无线局域网 “ 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888。 设置好之后，我们打开 iPhone 上的任意需要网络通讯的程序，就可以看到 Charles 弹出 iPhone 请求连接的确认菜单（如下图所示），点击 “Allow” 即可完成设置。 截取 Https 通讯信息安装证书如果你需要截取分析 Https 协议相关的内容。那么需要安装 Charles 的 CA 证书。具体步骤如下。 首先我们需要在 Mac 电脑上安装证书。点击 Charles 的顶部菜单，选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate”，然后输入系统的帐号密码，即可在 KeyChain 看到添加好的证书。如下图所示：需要注意的是，即使是安装完证书之后，Charles 默认也并不截取 Https 网络通讯的信息，如果你想对截取某个网站上的所有 Https 网络请求，可以在该请求上右击，选择 SSL proxy，如下图所示： 截取移动设备中的 Https 通讯信息如果我们需要在 iOS 或 Android 机器上截取 Https 协议的通讯内容，还需要在手机上安装相应的证书。点击 Charles 的顶部菜单，选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate on a Mobile Device or Remote Browser”，然后就可以看到 Charles 弹出的简单的安装教程。如下图所示： 这样，对于该 Host 的所有 SSL 请求可以被截取到了。 按照我们之前说的教程，在设备上设置好 Charles 为代理后，在手机浏览器中访问地址：http://charlesproxy.com/getssl，即可打开证书安装的界面，安装完证书后，就可以截取手机上的 Https 通讯内容了。不过同样需要注意，默认情况下 Charles 并不做截取，你还需要在要截取的网络请求上右击，选择 SSL proxy 菜单项。 可能遇到的问题Charles乱码 3.10版本之前: 去http://www.charlesproxy.com/ssl.zip 下载 CA 证书文件，然后双击 .crt 文件，选择‘总是信任’按钮，在钥匙串访问中即可看到添加成功的证书。 4.02版本以后 先点proxy中的macOS Proxy ，如果进行了网络请求，但是Charles没有出现数据的话，把翻墙软件关了。 然后去钥匙串找到Charles的CA证书，双击修改如下。 关闭窗口就可以看到证书变成: 接下来点击proxy中的SSL Proxying Settings，出现如下图所示，然后点add 在Host里填 * 号 ，在Port里填443，然后点ok：模拟慢速网络在做移动开发的时候，我们常常需要模拟慢速网络或者高延迟的网络，以测试在移动网络下，应用的表现是否正常。Charles 对此需求提供了很好的支持。 在 Charles 的菜单上，选择 “Proxy”-&gt;”Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图所示： 如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 “Only for selected hosts” 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。 修改网络请求内容有些时候为了调试服务器的接口，我们需要反复尝试不同参数的网络请求。Charles 可以方便地提供网络请求的修改和重发功能。只需要在以往的网络请求上点击右键，选择 “Edit”，即可创建一个可编辑的网络请求。如下所示： 给服务器做压力测试我们可以使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力，方法如下。 我们在想打压的网络请求上（POST 或 GET 请求均可）右击，然后选择 「Repeat Advanced」菜单项，如下所示： 接着我们就可以在弹出的对话框中，选择打压的并发线程数以及打压次数，确定之后，即可开始打压。 悄悄说一句，一些写得很弱的投票网站，也可以用这个办法来快速投票。当然，我也可以用 Charles 的 Repeat 功能给一些诈骗的钓鱼网站喂了不少垃圾数据。 修改服务器返回内容有些时候我们想让服务器返回一些指定的内容，方便我们调试一些特殊情况。例如列表页面为空的情况，数据异常的情况，部分耗时的网络请求超时的情况等。如果没有 Charles，要服务器配合构造相应的数据显得会比较麻烦。这个时候，使用 Charles 相关的功能就可以满足我们的需求。 根据具体的需求，Charles 提供了 Map 功能、 Rewrite 功能以及 Breakpoints 功能，都可以达到修改服务器返回内容的目的。这三者在功能上的差异是： Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。 Rewrite 功能适合对网络请求进行一些正则替换。 Breakpoints 功能适合做一些临时性的修改。 Map 功能Charles 的 Map 功能分 Map Remote 和 Map Local 两种。顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。 在 Charles 的菜单中，选择 “Tools”-&gt;”Map Remote” 或 “Map Local” 即可进入到相应功能的设置页面。也可以选中一个请求，右击选择对应的操作。 对于 Map Remote 功能，我们需要分别填写网络重定向的源地址和目的地址，对于不需要限制的条件，可以留空。下图是一个示例，我将所有 dev.ifeixiu.com（测试服务器）的请求重定向到了 ifeixiu.com（线上服务器）。 对于 Map Local 功能，我们需要填写的重定向的源地址和本地的目标文件。对于有一些复杂的网络请求结果，我们可以先使用 Charles 提供的 “Save Response…” 功能，将请求结果保存到本地，然后稍加修改，成为我们的目标映射文件。 下图是一个示例，我将一个指定的网络请求通过 Map Local 功能映射到了本地的一个经过修改的文件中。 Map Local 在使用的时候，有一个潜在的问题，就是其返回的 Http Response Header 与正常的请求并不一样。这个时候如果客户端校验了 Http Response Header 中的部分内容，就会使得该功能失效。解决办法是同时使用 Map Local 以下面提到的 Rewrite 功能，将相关的 Http 头 Rewrite 成我们希望的内容。 Rewrite 功能Rewrite 功能功能适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。 Breakpoints 功能上面提供的 Rewrite 功能最适合做批量和长期的替换，但是很多时候，我们只是想临时修改一次网络请求结果，这个时候，使用 Rewrite 功能虽然也可以达到目的，但是过于麻烦，对于临时性的修改，我们最好使用 Breakpoints 功能。 Breakpoints 功能类似我们在 Xcode 中设置的断点一样，当指定的网络请求发生时，Charles 会截获该请求，这个时候，我们可以在 Charles 中临时修改网络请求的返回内容。 需要注意的是，使用 Breakpoints 功能将网络请求截获并修改过程中，整个网络请求的计时并不会暂停，所以长时间的暂停可能导致客户端的请求超时。 反向代理Charles 的反向代理功能允许我们将本地的端口映射到远程的另一个端口上。 设置外部代理，解决与翻墙软件的冲突Charles 的原理是把自己设置成系统的代理服务器，但是在中国，由于工作需要，我们常常需要使用 Google 搜索，所以大部分程序员都有自己的翻墙软件，而这些软件的基本原理，也是把自己设置成系统的代理服务器，来做到透明的翻墙。 为了使得两者能够和平共处，我们可以在 Charles 的 External Proxy Settings 中，设置翻墙的代理端口以及相关信息。同时，我们也要关闭相关翻墙软件的自动设置，使其不主动修改系统代理，避免 Charles 失效。 总结通过 Charles 软件，我们可以很方便地在日常开发中，截取和调试网络请求内容，分析封包协议以及模拟慢速网络。用好 Charles 可以极大的方便我们对于带有网络请求的 App 的开发和调试。","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"Runtime应用篇","slug":"Runtime应用篇","date":"2019-04-23T09:17:43.000Z","updated":"2019-08-12T14:42:46.000Z","comments":true,"path":"2019/04/23/Runtime应用篇/","link":"","permalink":"https://bigporo.github.io/2019/04/23/Runtime应用篇/","excerpt":"前言Runtime简直就是做大型框架的利器。它的应用场景非常多，下面就介绍一些常见的应用场景。 关联对象(Objective-C Associated Objects)给分类增加属性 方法魔法(Method Swizzling)方法添加和替换和KVO实现 消息转发(热更新)解决Bug(JSPatch) 实现NSCoding的自动归档和自动解档 实现字典和模型的自动转换(MJExtension)","text":"前言Runtime简直就是做大型框架的利器。它的应用场景非常多，下面就介绍一些常见的应用场景。 关联对象(Objective-C Associated Objects)给分类增加属性 方法魔法(Method Swizzling)方法添加和替换和KVO实现 消息转发(热更新)解决Bug(JSPatch) 实现NSCoding的自动归档和自动解档 实现字典和模型的自动转换(MJExtension) 关联对象(Objective-C Associated Objects)我们都是知道分类是不能自定义属性和变量的。如果在分类的声明中写@property 只能为其生成get 和 set 方法的声明，但无法生成成员变量，就是虽然点语法能调用出来，但程序执行后会crash。 下面通过关联对象实现给分类添加属性。 关联对象Runtime提供了下面几个接口： 123456//关联对象void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)//获取关联的对象id objc_getAssociatedObject(id object, const void *key)//移除关联的对象void objc_removeAssociatedObjects(id object) 参数解释 1234id object：被关联的对象const void *key：关联的key，要求唯一id value：关联的对象objc_AssociationPolicy policy：内存管理的策略 通过关联对象实现的属性的内存管理也是有ARC管理的，所以我们只需要给定适当的内存策略就行了，不需要操心对象的释放。 内存管理策略 内存策略 属性修饰 描述 OBJC_ASSOCIATION_ASSIGN @property (assign) 或 @property (unsafe_unretained) 指定一个关联对象的弱引用。 OBJC_ASSOCIATION_RETAIN_NONATOMIC @property (nonatomic, strong) 指定一个关联对象的强引用，不能被原子化使用。 OBJC_ASSOCIATION_COPY_NONATOMIC @property (nonatomic, copy) 指定一个关联对象的copy引用，不能被原子化使用 OBJC_ASSOCIATION_RETAIN @property (atomic, strong) 指定一个关联对象的强引用，能被原子化使用。 OBJC_ASSOCIATION_COPY @property (atomic, copy) 指定一个关联对象的copy引用，能被原子化使用。 下面实现一个UIView的Category添加自定义属性defaultColor。 1234567891011121314151617181920212223242526272829303132333435363738394041#import &quot;ViewController.h&quot;#import &quot;objc/runtime.h&quot;@interface UIView (DefaultColor)@property (nonatomic, strong) UIColor *defaultColor;@end@implementation UIView (DefaultColor)@dynamic defaultColor;static char kDefaultColorKey;- (void)setDefaultColor:(UIColor *)defaultColor &#123;objc_setAssociatedObject(self, &amp;kDefaultColorKey, defaultColor, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (id)defaultColor &#123;return objc_getAssociatedObject(self, &amp;kDefaultColorKey);&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.UIView *test = [UIView new];test.defaultColor = [UIColor blackColor];NSLog(@&quot;%@&quot;, test.defaultColor);&#125;@end 方法魔法(Method Swizzling)方法添加12//class_addMethod(Class _Nullable __unsafe_unretained cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)class_addMethod([self class], sel, (IMP)fooMethod, &quot;v@:&quot;); 参数解释 cls 被添加方法的类 name 添加的方法的名称的SEL imp 方法的实现。该函数必须至少要有两个参数，self,_cmd 类型编码 方法替换12345678// 获得某个类的类方法Method class_getClassMethod(Class cls , SEL name)// 获得某个类的实例对象方法Method class_getInstanceMethod(Class cls , SEL name)// 交换两个方法的实现void method_exchangeImplementations(Method m1 , Method m2) 示例如下:1234567891011121314151617181920212223242526272829303132333435@implementation ViewController+ (void)load &#123;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;Class class = [self class];SEL originalSelector = @selector(viewDidLoad);SEL swizzledSelector = @selector(jkviewDidLoad);Method originalMethod = class_getInstanceMethod(class,originalSelector);Method swizzledMethod = class_getInstanceMethod(class,swizzledSelector);//judge the method named swizzledMethod is already existed.BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));// if swizzledMethod is already existed.if (didAddMethod) &#123;class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));&#125;else &#123;method_exchangeImplementations(originalMethod, swizzledMethod);&#125;&#125;);&#125;- (void)jkviewDidLoad &#123;NSLog(@&quot;替换的方法&quot;);[self jkviewDidLoad];&#125;- (void)viewDidLoad &#123;NSLog(@&quot;自带的方法&quot;);[super viewDidLoad];&#125; 在 Objective-C 的运行时中，每个类有两个方法都会自动调用。+load 是在一个类被初始装载时调用，+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。 实现图解如下图。 从图中可以看出，我们通过swizzling特性，将selectorC的方法实现IMPc与selectorN的方法实现IMPn交换了，当我们调用selectorC，也就是给对象发送selectorC消息时，所查找到的对应的方法实现就是IMPn而不是IMPc了。 KVO实现质量博客解读 全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。在MVC大行其道的Cocoa中，KVO机制很适合实现model和controller类之间的通讯。 KVO的实现依赖于 Objective-C 强大的 Runtime，当观察某对象 A 时，KVO 机制动态创建一个对象A当前类的子类，并为这个新的子类重写了被观察属性 keyPath 的 setter 方法。setter 方法随后负责通知观察对象属性的改变状况。 Apple 使用了 isa-swizzling 来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为：NSKVONotifying_A的新类，该类继承自对象A的本类，且 KVO 为 NSKVONotifying_A 重写观察属性的 setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。 所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对 KVO 的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类，就会发现系统运行到注册 KVO 的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为 NSKVONotifying_A 的中间类，并指向这个中间类了。 子类setter方法剖析 KVO 的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangeValueForKey: ，在存取数值的前后分别调用 2 个方法：被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该keyPath 的属性值已经变更；之后， observeValueForKey:ofObject:change:context:也会被调用。且重写观察属性的setter 方法这种继承方式的注入是在运行时而不是编译时实现的。KVO 为子类的观察者属性重写调用存取方法的工作原理在代码中相当于： 12345- (void)setName:(NSString *)newName &#123; [self willChangeValueForKey:@&quot;name&quot;]; //KVO 在调用存取方法之前总调用 [super setValue:newName forKey:@&quot;name&quot;]; //调用父类的存取方法 [self didChangeValueForKey:@&quot;name&quot;]; //KVO 在调用存取方法之后总调用&#125; 示例如下： 123456789101112131415161718- (void)dealloc&#123;[self.person removeObserver:self forKeyPath:@&quot;name&quot;];&#125;- (void)viewDidLoad &#123;[super viewDidLoad];self.person = [Person new];[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:@&quot;传个值？&quot;];&#125;#pragma mark KVO- (void)KVO&#123;self.person.name = @&quot;new name&quot;;&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;NSLog(@&quot;%@对象的%@属性改变了：%@,传值:%@&quot;, object, keyPath, change,context);&#125; 输出如下 1234&lt;Person: 0x600000907280&gt;对象的name属性改变了：&#123;kind = 1;new = &quot;new name&quot;;&#125;,传值:传个值？ 消息转发(热更新)解决Bug(JSPatch) JSPatch 是一个 iOS 动态更新框架，只需在项目中引入极小的引擎，就可以使用 JavaScript 调用任何 Objective-C 原生接口，获得脚本语言的优势：为项目动态添加模块，或替换项目原生代码动态修复 bug。 消息转发分为三级，我们可以在每级实现替换功能，实现消息转发，从而不会造成崩溃。JSPatch不仅能够实现消息转发，还可以实现方法添加、替换能一系列功能。 获得一个类的所有成员变量用runtime提供的函数遍历Model自身所有属性。 12345678910111213unsigned int outCount = 0;Ivar *ivars = class_copyIvarList([Person class], &amp;outCount);// 遍历所有成员变量for (int i = 0; i &lt; outCount; i++) &#123;// 取出i位置对应的成员变量Ivar ivar = ivars[i];const char *name = ivar_getName(ivar);const char *type = ivar_getTypeEncoding(ivar);NSLog(@&quot;成员变量名：%s 成员变量类型：%s&quot;,name,type);&#125;// 注意释放内存！free(ivars); 实现NSCoding的自动归档和自动解档原理描述：用runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。 核心方法：在Model的基类中重写方法： 12345678910111213141516171819202122- (id)initWithCoder:(NSCoder *)aDecoder &#123;if (self = [super init]) &#123;unsigned int outCount;Ivar * ivars = class_copyIvarList([self class], &amp;outCount);for (int i = 0; i &lt; outCount; i ++) &#123;Ivar ivar = ivars[i];NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];[self setValue:[aDecoder decodeObjectForKey:key] forKey:key];&#125;&#125;return self;&#125;- (void)encodeWithCoder:(NSCoder *)aCoder &#123;unsigned int outCount;Ivar * ivars = class_copyIvarList([self class], &amp;outCount);for (int i = 0; i &lt; outCount; i ++) &#123;Ivar ivar = ivars[i];NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];[aCoder encodeObject:[self valueForKey:key] forKey:key];&#125;&#125; 实现字典和模型的自动转换(MJExtension)原理描述：用runtime提供的函数遍历Model自身所有属性，如果属性在json中有对应的值，则将其赋值。核心方法：在NSObject的分类中添加方法12345678910111213141516171819202122232425262728293031323334- (instancetype)initWithDict:(NSDictionary *)dict &#123;if (self = [self init]) &#123;//(1)获取类的属性及属性对应的类型NSMutableArray * keys = [NSMutableArray array];NSMutableArray * attributes = [NSMutableArray array];/** 例子* name = value3 attribute = T@&quot;NSString&quot;,C,N,V_value3* name = value4 attribute = T^i,N,V_value4*/unsigned int outCount;objc_property_t * properties = class_copyPropertyList([self class], &amp;outCount);for (int i = 0; i &lt; outCount; i ++) &#123;objc_property_t property = properties[i];//通过property_getName函数获得属性的名字NSString * propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding];[keys addObject:propertyName];//通过property_getAttributes函数可以获得属性的名字和@encode编码NSString * propertyAttribute = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding];[attributes addObject:propertyAttribute];&#125;//立即释放properties指向的内存free(properties);//(2)根据类型给属性赋值for (NSString * key in keys) &#123;if ([dict valueForKey:key] == nil) continue;[self setValue:[dict valueForKey:key] forKey:key];&#125;&#125;return self;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"}]},{"title":"cocoapods安装及使用","slug":"cocoapods安装及使用","date":"2019-04-23T09:17:43.000Z","updated":"2019-08-12T14:41:11.000Z","comments":true,"path":"2019/04/23/cocoapods安装及使用/","link":"","permalink":"https://bigporo.github.io/2019/04/23/cocoapods安装及使用/","excerpt":"参考文档 参考文档 CocoaPods 简介每种语言发展到一个阶段，就会出现相应的依赖管理工具，例如 Java 语言的 Maven，nodejs 的 npm。随着 iOS 开发者的增多，业界也出现了为 iOS 程序提供依赖管理的工具，它的名字叫做：CocoaPods。 CocoaPods项目的源码 在 Github 上管理。该项目开始于 2011 年 8 月 12 日，经过多年发展，现在已经成为 iOS 开发事实上的依赖管理标准工具。开发 iOS 项目不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。","text":"参考文档 参考文档 CocoaPods 简介每种语言发展到一个阶段，就会出现相应的依赖管理工具，例如 Java 语言的 Maven，nodejs 的 npm。随着 iOS 开发者的增多，业界也出现了为 iOS 程序提供依赖管理的工具，它的名字叫做：CocoaPods。 CocoaPods项目的源码 在 Github 上管理。该项目开始于 2011 年 8 月 12 日，经过多年发展，现在已经成为 iOS 开发事实上的依赖管理标准工具。开发 iOS 项目不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。 CocoaPods 的安装和使用介绍安装 升级 gem: 1sudo gem update --system 接下来输入系统密码就可以安装了，输入密码时不会显示的，输完回车就行了 另外，ruby 的软件源 https://rubygems.org 因为使用的是亚马逊的云服务，所以被墙了，需要更新一下 ruby 的源，使用如下代码将官方的 ruby 源替换成国内的源： 12gem sources --remove https://rubygems.org/gem sources --add https://gems.ruby-china.com/ 接下来查看下源路径是否更换了 1gem sources -l 如果是以下结果说明正确.123*** CURRENT SOURCES ***https://gems.ruby-china.com/ 这时候才正式开始安装CocoaPods1sudo gem install cocoapods 如果出现这个了,指的是你没有权限 输入这个1sudo gem install -n /usr/local/bin cocoapods 如果显示这个表示安装成功 安装本地库 1pod setup 执行以上命令后就是漫长的等待，当然,网络好的情况下会更快 123456Setting up CocoaPods master repo $ /usr/bin/git clone https://github.com/CocoaPods/Specs.git master --progress Cloning into &apos;master&apos;... remote: Counting objects: 1879515, done. remote: Compressing objects: 100% (321/321), done. Receiving objects: 21% (404525/1879515), 73.70 MiB | 22.00 KiB/ 要查看文件下载进度的可以另外打开一个终端窗口(快捷键:选中终端按下Command+N组合键)，输入以下两行命令回车执行 123cd ~/.cocoapodsdu -sh * 执行du -sh *之后会显示已下载的文件大小，可以多次执行来监看下载进度，如果之前还有文件大小，后来变成0了，可能是网络问题，下载已经中断了,需要结束命令并从新执行 pod setup 下载安装完成之后可执行下列命令检查是否可用（第一次使用可能要等一会）1pod search AFNetworking 结果是这样的就妥了(输入q回到终端控制界面) 使用 CocoaPods使用时需要新建一个名为 Podfile 的文件，以如下格式，将依赖的库名字依次列在文件中即可 1234platform :ios, &apos;7.0&apos;target &apos;demo&apos; dopod &apos;SDWebImage&apos;，end 然后你将编辑好的 Podfile 文件放到你的项目根目录中，执行如下命令即可： 12cd &quot;your project home&quot;pod install 现在，你的所有第三方库都已经下载完成并且设置好了编译参数和依赖，你只需要记住如下 2 点即可： 使用 CocoaPods 生成的 .xcworkspace 文件来打开工程，而不是以前的 .xcodeproj 文件。 每次更改了 Podfile 文件，你需要重新执行一次pod update命令。 可能会遇到的问题 当在终端输入,pod search AFNetworking可能会出现这种情况 这是因为之前pod search的时候生成了缓存文件search_index.json 1rm ~/Library/Caches/CocoaPods/search_index.json 来删除该文件然后再次输入pod search AFNetworking进行搜索这时会提示Creating search index for spec repo ‘master’.. 当运行pod 命令出现 1command not found 解决办法:1sudo gem install -n /usr/local/bin cocoapods 之后pod命令可以使用了 如果pod update / pod install 卡在：1Updating local specs repositories 等待即可，或者 可以使用 “pod install –verbose –no-repo-update” 进行下载，原因可能x被墙。 出现如下错误:12345678Cloning into &apos;master&apos;...remote: Enumerating objects: 395, done. remote: Counting objects: 100% (395/395), done. remote: Compressing objects: 100% (308/308), done. error: RPC failed; curl 56 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 60fatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 解决办法:1gem install rails 如下:1234Successfully installed rails-5.0.1Parsing documentation for rails-5.0.1Done installing documentation for rails after 0 seconds1 gem installed 然后继续:1pod setup 使用 CocoaPods 的镜像索引所有的项目的 Podspec 文件都托管在https://github.com/CocoaPods/Specs。第一次执行pod setup时，CocoaPods 会将这些podspec索引文件更新到本地的 ~/.cocoapods/目录下，这个索引文件比较大，有 80M 左右。所以第一次更新时非常慢。 一个叫 akinliu 的朋友在 gitcafe 和 oschina 上建立了 CocoaPods 索引库的镜像，因为 gitcafe 和 oschina 都是国内的服务器，所以在执行索引更新操作时，会快很多。如下操作可以将 CocoaPods 设置成使用 gitcafe 镜像：123pod repo remove masterpod repo add master https://gitcafe.com/akuandev/Specs.gitpod repo update 将以上代码中的 https://gitcafe.com/akuandev/Specs.git 替换成 http://git.oschina.net/akuandev/Specs.git 即可使用 oschina 上的镜像。 查找第三方库你如果不知道 cocoaPods 管理的库中，是否有你想要的库，那么你可以通过 pod search 命令进行查找，以下是我用 pod search json 查找到的所有可用的库： 123456789101112$ pod search json-&gt; AnyJSON (0.0.1) Encode / Decode JSON by any means possible. - Homepage: https://github.com/mattt/AnyJSON - Source: https://github.com/mattt/AnyJSON.git - Versions: 0.0.1 [master repo]-&gt; JSONKit (1.5pre) A Very High Performance Objective-C JSON Library. - Homepage: https://github.com/johnezang/JSONKit - Source: git://github.com/johnezang/JSONKit.git - Versions: 1.5pre, 1.4 [master repo]// ... 以下省略若干行 Podfile.lock当你执行pod install之后，除了 Podfile 外，CocoaPods 还会生成一个名为Podfile.lock的文件，Podfile.lock 应该加入到版本控制里面，不应该把这个文件加入到.gitignore中。因为Podfile.lock会锁定当前各依赖库的版本，之后如果多次执行pod install 不会更改版本，要pod update才会改Podfile.lock了。这样多人协作的时候，可以防止第三方库升级时造成大家各自的第三方库版本不一致。 CocoaPods 的这篇 官方文档 也在What is a Podfile.lock一节中介绍了Podfile.lock的作用，并且指出： This file should always be kept under version control. 为自己的项目创建 podspec 文件我们可以为自己的开源项目创建podspec文件，首先通过如下命令初始化一个podspec文件： 1pod spec create your_pod_spec_name 该命令执行之后，CocoaPods 会生成一个名为your_pod_spec_name.podspec的文件，然后我们修改其中的相关内容即可。 具体步骤可以参考这两篇博文中的相关内容： 创建 podspec 文件，给自己写的框架添加 CocoaPos 支持 创建podspec文件，为自己的项目添加pod支持 使用私有的 pods我们可以直接指定某一个依赖的podspec，这样就可以使用公司内部的私有库。该方案有利于使企业内部的公共项目支持 CocoaPods。如下是一个示例： 1pod &apos;MyCommon&apos;, :podspec =&gt; &apos;https://yuantiku.com/common/myCommon.podspec&apos; 不更新 podspecCocoaPods 在执行pod install和pod update时，会默认先更新一次podspec索引。使用–no-repo-update参数可以禁止其做索引更新操作。如下所示：12pod install --no-repo-updatepod update --no-repo-update 其他操作生成第三方库的帮助文档如果你想让 CococaPods 帮你生成第三方库的帮助文档，并集成到 Xcode 中，那么用 brew 安装 appledoc 即可：1brew install appledoc 关于 appledoc，唐巧在另一篇博客 《使用 Objective-C 的文档生成工具:appledoc》 中有专门介绍。它最大的优点是可以将帮助文档集成到 Xcode 中，这样你在敲代码的时候，按住 opt 键单击类名或方法名，就可以显示出相应的帮助文档。 原理&lt;巧神说的&gt;大概研究了一下 CocoaPods 的原理，它是将所有的依赖库都放到另一个名为 Pods 项目中，然后让主项目依赖 Pods 项目，这样，源码管理工作都从主项目移到了 Pods 项目中。发现的一些技术细节有： Pods 项目最终会编译成一个名为 libPods.a 的文件，主项目只需要依赖这个 .a 文件即可。 对于资源文件，CocoaPods 提供了一个名为 Pods-resources.sh 的 bash 脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。 CocoaPods 通过一个名为 Pods.xcconfig 的文件来在编译时设置所有的依赖和参数。","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"《iOS开发进阶》读书总结","slug":"《iOS开发进阶》读书总结","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T09:11:17.000Z","comments":true,"path":"2019/04/23/《iOS开发进阶》读书总结/","link":"","permalink":"https://bigporo.github.io/2019/04/23/《iOS开发进阶》读书总结/","excerpt":"iOS开发工具","text":"iOS开发工具 依赖包管理工具-CocoapPodshttp://note.youdao.com/noteshare?id=afbf57911d0ba85e6ae7073d6c8b2c83 网络封包分析工具-Charleshttp://note.youdao.com/noteshare?id=c758ee77fa20a7888e89d035dec8906a 界面调试工具-Revealhttp://note.youdao.com/noteshare?id=b06327cef4d357e2da55bd1cfe33cb7c 移动统计工具Flurry现在咱用友盟了 崩溃日志记录工具-Crashlytics现在用的是Bugtags App Store统计工具-App Annie现在的App Store Connect 做的还可以的。 Xcode 插件最新的Xcode 10 已经不支持这些花里胡哨(很实用)的东西了。 不过Apple将一些优秀的插件直接集成到Xcode里面了。比如: 快速添加注释1⌥ Option + ⌘ Command + / 该快捷键的前生是喵神的VVDocumenter-Xcode 其它工具介绍取色器基操 其它图形工具ImageOptimhttp://note.youdao.com/noteshare?id=60cd5fb3f8e7b20e6a4663946e52daa3 马克鳗主要是用来标注设计图的。官网 Dash是一款API文档查询及代码片段管理的工具。 蒲公英是一个应用的内测分发工具，使用频率还是蛮高的，具体的使用文档见官网。 命令行工具nomad工具主页：https://nomad-cli.com/ 不过现在好像faltlane更加好用。 xctool工具主页：https://github.com/facebook/xctool 参考博客 xctool是 facebook 开源的一个 iOS 编译和测试的工具。使用它而不是用 Xcode 的 UI 界面是因为它是一个纯命令行工具。比如：我们可以使用 xctool 在命令生下进行编译和单元测试，然后将测试结果集成到 Jenkins 中，这样就实现了自动化的持续集成。虽然苹果也在 OSX Server 上推出了自己的自动化集成工具 BOT，但其配置和使用上现在仍然不太方便。 appledoc是一个从源代码中抽取文档的工具工具主页：https://github.com/tomaz/appledoc 使用教程 iOS开发实践理解内存管理循环引用的监测大部分内容都是广为人知的，网上的资料也很多，这里着重说一下通过Xcoded的Instruments工具集来监测循环引用。 数组A和数组B构成了循环引用 12345678910- (void)viewDidLoad &#123;[super viewDidLoad];// 测试循环引用的监测NSMutableArray *arrA = [NSMutableArray new];NSMutableArray *arrB = [NSMutableArray new];[arrA addObject:arrB];[arrB addObject:arrA];&#125; Xcode的菜单栏 -&gt; Product -&gt; Profile 点击右上角开始监测 点击切换到”Leaks”,点击选中”Cycles &amp; Roots”就可以看到循环引用了，也可以很方便的找到源头。 Core Foundation对象的内存管理Core Foundation对象需要我们手动管理其内存 GCD书中也只是说了一些GCD的常用API，并不涉及底层源码和实现原理。 使用UIWindow可以参考这篇文章 动态下载系统提供的多种中文字体操作不难，可以参考这篇文章，书中的说明也很详细。 使用应用内支付可以参考这篇文章 基于UIWebView的混合编程现在基本都是WKWebView，但是基本原理相似。 安全性问题网络安全 安全的传输用户密码 主要是加密 防止通讯协议被轻易破解 使用二进制通讯协议或者自定义通讯协议 验证应用内支付的凭证本地文件和数据安全 程序文件的安全 将JavaScript源码进行混淆和加密。 本地数据安全 本地的重要数据需要加密或者保存到keychian中 源代码安全通过一些工具可以分析编译之后的二进制程序文件，比如IDA。这种情况比较无解，除非将一些关键的逻辑使用C来实现。 基于CoreText的排版引擎主要介绍如何基本CoreText自定义一个排版引擎。 实战技巧App Store与审核 撤销正在审核的应用 申请加急审核 测试设备数的限制 如何将应用下架 如何举报别的应用侵权开发技巧 大部分比较熟知，单独提几点： 查找技巧 Xcode的查找替换功能提供了Insert Pattern的方式，方便输入常见的查找规则。 代码片段管理 点击可以看到系统提供的一些代码片段，我们也可以自己自定义代码片段。 选中代码库，右击选择”Create Code Snippet“,就可以将其保存。如果有些地方想要替换掉，使用&lt;#被替换的内容#&gt;的格式，这样代码片段带使用后，焦点会自动移到此处。 自定义的代码片段保存在 ~/Library/Developer/Xcode/UserData/CodeSnippets/ 目录下，可以将其设置为Git仓库，然后将代码片段都放在Github上，方便管理。 iOS底层开发原理Objective-C对象模型isa指针 Objective-C是一门面向对象的语音，所有的对象都是一个类的实例，每一个对象都有一个isa指针，指向该对象的类。每一个类描述了它的实例的特点，包括成员变量的的列表，成员函数的列表等。 类也是一个对象，所以是另一个类的实例，这个类就是元类。元类保存了类方法列表，当一个类方法被调用的时候，元类会首先查找它自身是否有该方法的时候，没有的话就会向其父类查找方法，这样可以一直找到继承链的头。 元类也是对象，其isa指针指向根元类。根元类的isa指针指向自己，这样就形成了一个闭环。 类的成员变量 对象在内存中的排布可以看成一个结构体，该结构体的大小不能动态变化，所以无法再运行时动态的添加成员变量。 方法的定义列表是一个名为methodLists的指针的指针，通过修改该指针指向的指针的值，可以动态的为某个类增加成员方法，这也是分类的实现原理。 isa本身也是指针，我们可以动态的修改指针的值，达到替换对象整个行为的目的，不过用的较少。 对象模型的应用这一小节简单介绍了一些Runtime的应用，具体查看这篇笔记。 Tagged Pointer对象背景假设要存储一个NSNumber对象，其值是一个整数。正常情况下，如果这个整数只是一个NSInteger的普通变量，那么它所占用的内存是与CPU的位数有关，在32位CPU下占4个字节，在64位CPU下是占8个字节的。而指针类型的大小通常也是与CPU位数相关，一个指针所占用的内存在32位CPU下为4个字节，在64位CPU下也是8个字节。所以一个普通的iOS程序，如果没有Tagged Pointer对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但这种NSNumber、NSDate一类的对象所占用的内存会翻倍。 原理把指针指向的内容直接放在了指针变量的内存地址中，因为在 64 位环境下指针变量的大小达到了 8 位足以容纳一些长度较小的内容。于是使用了标签指针这种方式来优化数据的存储方式。从引用计数可以看出，这个是一个释放不掉的单例常量对象。在运行时根据实际情况创建。 Block对象模型巧哥的博客12345678struct Block_layout &#123;void *isa;int flags;int reserved;void (*invoke)(void *, ...);struct Block_descriptor *descriptor;/* Imported variables. */&#125;; 123456struct Block_descriptor &#123;unsigned long int reserved;unsigned long int size;void (*copy)(void *dst, void *src);void (*dispose)(void *);&#125;; 一个 block 实例实际上由 6 部分构成： isa 指针，所有对象都有该指针，用于实现对象相关的功能。 flags，用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用。 reserved，保留变量。 invoke，函数指针，指向具体的 block 实现的函数调用地址。 descriptor， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。 variables，capture 过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。","categories":[{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/categories/读书/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/tags/读书/"}]},{"title":"iOS各种设备信息获取总结","slug":"iOS各种设备信息获取总结","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T08:57:59.000Z","comments":true,"path":"2019/04/23/iOS各种设备信息获取总结/","link":"","permalink":"https://bigporo.github.io/2019/04/23/iOS各种设备信息获取总结/","excerpt":"为了统计用户信息、下发广告，服务器端往往需要手机用户设备及app的各种信息，下面讲述一下各种信息的获取方式：","text":"为了统计用户信息、下发广告，服务器端往往需要手机用户设备及app的各种信息，下面讲述一下各种信息的获取方式：直接上代码:1234567891011121314151617181920212223242526272829303132333435363738// 这个方法后面会列出来NSString *deviceName = [self getDeviceName];NSLog(@&quot;设备型号--&gt;%@&quot;, deviceName);NSString *iPhoneName = [UIDevice currentDevice].name;NSLog(@&quot;iPhone名称--&gt;%@&quot;, iPhoneName); NSString *appVerion = [[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleShortVersionString&quot;];NSLog(@&quot;app版本号--&gt;%@&quot;, appVerion);CGFloat batteryLevel = [[UIDevice currentDevice] batteryLevel];NSLog(@&quot;电池电量--&gt;%f&quot;, batteryLevel);NSString *localizedModel = [UIDevice currentDevice].localizedModel;NSLog(@&quot;localizedModel--&gt;%@&quot;, localizedModel);NSString *systemName = [UIDevice currentDevice].systemName;NSLog(@&quot;当前系统名称--&gt;%@&quot;, systemName);NSString *systemVersion = [UIDevice currentDevice].systemVersion;NSLog(@&quot;当前系统版本号--&gt;%@&quot;, systemVersion);struct utsname systemInfo;uname(&amp;systemInfo);NSString *device_model = [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];NSLog(@&quot;device_model--&gt;%@&quot;, device_model);// 这个方法后面会单独列出NSString *macAddress = [self getMacAddress];NSLog(@&quot;macAddress--&gt;%@&quot;, macAddress);// 这个方法后面会单独列出NSString *deviceIP = [self getDeviceIPAddresses];NSLog(@&quot;deviceIP--&gt;%@&quot;, deviceIP);// 设备上次重启的时间NSTimeInterval time = [[NSProcessInfo processInfo] systemUptime];NSDate *lastRestartDate = [[NSDate alloc] initWithTimeIntervalSinceNow:(0 - time)]; 广告位标识符在同一个设备上的所有App都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设的，用户可以在 设置|隐私|广告追踪里重置此id的值，或限制此id的使用，故此id有可能会取不到值，但好在Apple默认是允许追踪的，而且一般用户都不知道有这么个设置，所以基本上用来监测推广效果，是戳戳有余了。12NSString *idfa = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];NSLog(@&quot;广告位标识符idfa--&gt;%@&quot;, idfa); UUID是Universally Unique Identifier的缩写，中文意思是通用唯一识别码。它是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指 定。这样，每个人都可以建立不与其它人冲突的 UUID。在此情况下，就不需考虑数据库建立时的名称重复问题。苹果公司建议使用UUID为应用生成唯一标识字符串。 12NSString *uuid = [[[UIDevice currentDevice] identifierForVendor] UUIDString];NSLog(@&quot;唯一识别码uuid--&gt;%@&quot;, uuid); 获取设备型号123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 需要#import &quot;sys/utsname.h&quot;#warning 题主呕心沥血总结！！最全面！亲测！全网独此一份！！struct utsname systemInfo;uname(&amp;systemInfo);NSString *deviceString = [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];if ([deviceString isEqualToString:@&quot;iPhone3,1&quot;]) return @&quot;iPhone 4&quot;;if ([deviceString isEqualToString:@&quot;iPhone3,2&quot;]) return @&quot;iPhone 4&quot;;if ([deviceString isEqualToString:@&quot;iPhone3,3&quot;]) return @&quot;iPhone 4&quot;;if ([deviceString isEqualToString:@&quot;iPhone4,1&quot;]) return @&quot;iPhone 4S&quot;;if ([deviceString isEqualToString:@&quot;iPhone5,1&quot;]) return @&quot;iPhone 5&quot;;if ([deviceString isEqualToString:@&quot;iPhone5,2&quot;]) return @&quot;iPhone 5 (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPhone5,3&quot;]) return @&quot;iPhone 5c (GSM)&quot;;if ([deviceString isEqualToString:@&quot;iPhone5,4&quot;]) return @&quot;iPhone 5c (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPhone6,1&quot;]) return @&quot;iPhone 5s (GSM)&quot;;if ([deviceString isEqualToString:@&quot;iPhone6,2&quot;]) return @&quot;iPhone 5s (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPhone7,1&quot;]) return @&quot;iPhone 6 Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone7,2&quot;]) return @&quot;iPhone 6&quot;;if ([deviceString isEqualToString:@&quot;iPhone8,1&quot;]) return @&quot;iPhone 6s&quot;;if ([deviceString isEqualToString:@&quot;iPhone8,2&quot;]) return @&quot;iPhone 6s Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone8,4&quot;]) return @&quot;iPhone SE&quot;;// 日行两款手机型号均为日本独占，可能使用索尼FeliCa支付方案而不是苹果支付if ([deviceString isEqualToString:@&quot;iPhone9,1&quot;]) return @&quot;国行、日版、港行iPhone 7&quot;;if ([deviceString isEqualToString:@&quot;iPhone9,2&quot;]) return @&quot;港行、国行iPhone 7 Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone9,3&quot;]) return @&quot;美版、台版iPhone 7&quot;;if ([deviceString isEqualToString:@&quot;iPhone9,4&quot;]) return @&quot;美版、台版iPhone 7 Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,1&quot;]) return @&quot;国行(A1863)、日行(A1906)iPhone 8&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,4&quot;]) return @&quot;美版(Global/A1905)iPhone 8&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,2&quot;]) return @&quot;国行(A1864)、日行(A1898)iPhone 8 Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,5&quot;]) return @&quot;美版(Global/A1897)iPhone 8 Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,3&quot;]) return @&quot;国行(A1865)、日行(A1902)iPhone X&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,6&quot;]) return @&quot;美版(Global/A1901)iPhone X&quot;;if ([deviceString isEqualToString:@&quot;iPhone11,2&quot;]) return @&quot;iPhone XS&quot;;if ([deviceString isEqualToString:@&quot;iPhone11,4&quot;]) return @&quot;iPhone XS Max&quot;;if ([deviceString isEqualToString:@&quot;iPhone11,6&quot;]) return @&quot;iPhone XS Max&quot;;if ([deviceString isEqualToString:@&quot;iPhone11,8&quot;]) return @&quot;iPhone XR&quot;;if ([deviceString isEqualToString:@&quot;iPod1,1&quot;]) return @&quot;iPod Touch 1G&quot;;if ([deviceString isEqualToString:@&quot;iPod2,1&quot;]) return @&quot;iPod Touch 2G&quot;;if ([deviceString isEqualToString:@&quot;iPod3,1&quot;]) return @&quot;iPod Touch 3G&quot;;if ([deviceString isEqualToString:@&quot;iPod4,1&quot;]) return @&quot;iPod Touch 4G&quot;;if ([deviceString isEqualToString:@&quot;iPod5,1&quot;]) return @&quot;iPod Touch (5 Gen)&quot;;if ([deviceString isEqualToString:@&quot;iPad1,1&quot;]) return @&quot;iPad&quot;;if ([deviceString isEqualToString:@&quot;iPad1,2&quot;]) return @&quot;iPad 3G&quot;;if ([deviceString isEqualToString:@&quot;iPad2,1&quot;]) return @&quot;iPad 2 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad2,2&quot;]) return @&quot;iPad 2&quot;;if ([deviceString isEqualToString:@&quot;iPad2,3&quot;]) return @&quot;iPad 2 (CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPad2,4&quot;]) return @&quot;iPad 2&quot;;if ([deviceString isEqualToString:@&quot;iPad2,5&quot;]) return @&quot;iPad Mini (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad2,6&quot;]) return @&quot;iPad Mini&quot;;if ([deviceString isEqualToString:@&quot;iPad2,7&quot;]) return @&quot;iPad Mini (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPad3,1&quot;]) return @&quot;iPad 3 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad3,2&quot;]) return @&quot;iPad 3 (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPad3,3&quot;]) return @&quot;iPad 3&quot;;if ([deviceString isEqualToString:@&quot;iPad3,4&quot;]) return @&quot;iPad 4 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad3,5&quot;]) return @&quot;iPad 4&quot;;if ([deviceString isEqualToString:@&quot;iPad3,6&quot;]) return @&quot;iPad 4 (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,1&quot;]) return @&quot;iPad Air (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,2&quot;]) return @&quot;iPad Air (Cellular)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,4&quot;]) return @&quot;iPad Mini 2 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,5&quot;]) return @&quot;iPad Mini 2 (Cellular)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,6&quot;]) return @&quot;iPad Mini 2&quot;;if ([deviceString isEqualToString:@&quot;iPad4,7&quot;]) return @&quot;iPad Mini 3&quot;;if ([deviceString isEqualToString:@&quot;iPad4,8&quot;]) return @&quot;iPad Mini 3&quot;;if ([deviceString isEqualToString:@&quot;iPad4,9&quot;]) return @&quot;iPad Mini 3&quot;;if ([deviceString isEqualToString:@&quot;iPad5,1&quot;]) return @&quot;iPad Mini 4 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad5,2&quot;]) return @&quot;iPad Mini 4 (LTE)&quot;;if ([deviceString isEqualToString:@&quot;iPad5,3&quot;]) return @&quot;iPad Air 2&quot;;if ([deviceString isEqualToString:@&quot;iPad5,4&quot;]) return @&quot;iPad Air 2&quot;;if ([deviceString isEqualToString:@&quot;iPad6,3&quot;]) return @&quot;iPad Pro 9.7&quot;;if ([deviceString isEqualToString:@&quot;iPad6,4&quot;]) return @&quot;iPad Pro 9.7&quot;;if ([deviceString isEqualToString:@&quot;iPad6,7&quot;]) return @&quot;iPad Pro 12.9&quot;;if ([deviceString isEqualToString:@&quot;iPad6,8&quot;]) return @&quot;iPad Pro 12.9&quot;;if ([deviceString isEqualToString:@&quot;iPad6,11&quot;]) return @&quot;iPad 5 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad6,12&quot;]) return @&quot;iPad 5 (Cellular)&quot;;if ([deviceString isEqualToString:@&quot;iPad7,1&quot;]) return @&quot;iPad Pro 12.9 inch 2nd gen (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad7,2&quot;]) return @&quot;iPad Pro 12.9 inch 2nd gen (Cellular)&quot;;if ([deviceString isEqualToString:@&quot;iPad7,3&quot;]) return @&quot;iPad Pro 10.5 inch (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad7,4&quot;]) return @&quot;iPad Pro 10.5 inch (Cellular)&quot;;if ([deviceString isEqualToString:@&quot;iPad7,5&quot;]) return @&quot;iPad 6th generation&quot;;if ([deviceString isEqualToString:@&quot;iPad7,6&quot;]) return @&quot;iPad 6th generation&quot;;if ([deviceString isEqualToString:@&quot;iPad8,1&quot;]) return @&quot;iPad Pro (11-inch)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,2&quot;]) return @&quot;iPad Pro (11-inch)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,3&quot;]) return @&quot;iPad Pro (11-inch)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,4&quot;]) return @&quot;iPad Pro (11-inch)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,5&quot;]) return @&quot;iPad Pro (12.9-inch) (3rd generation)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,6&quot;]) return @&quot;iPad Pro (12.9-inch) (3rd generation)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,7&quot;]) return @&quot;iPad Pro (12.9-inch) (3rd generation)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,8&quot;]) return @&quot;iPad Pro (12.9-inch) (3rd generation)&quot;;if ([deviceString isEqualToString:@&quot;AppleTV2,1&quot;]) return @&quot;Apple TV 2&quot;;if ([deviceString isEqualToString:@&quot;AppleTV3,1&quot;]) return @&quot;Apple TV 3&quot;;if ([deviceString isEqualToString:@&quot;AppleTV3,2&quot;]) return @&quot;Apple TV 3&quot;;if ([deviceString isEqualToString:@&quot;AppleTV5,3&quot;]) return @&quot;Apple TV 4&quot;;if ([deviceString isEqualToString:@&quot;i386&quot;]) return @&quot;Simulator&quot;;if ([deviceString isEqualToString:@&quot;x86_64&quot;]) return @&quot;Simulator&quot;;return deviceString;&#125; 获取 iPhone 设备颜色/外壳颜色12345678910111213141516#warning 该方法是私有API，上线会被拒// 由于每款手机同一颜色具体色号不一样，如 iPhone 6和 iPhone SE粉色的两个具体色值是不一样的，因此在这里只能返回一个色号UIDevice *device = [UIDevice currentDevice];SEL selector = NSSelectorFromString(@&quot;deviceInfoForKey:&quot;);if (![device respondsToSelector:selector]) &#123;selector = NSSelectorFromString(@&quot;_deviceInfoForKey:&quot;);&#125;if ([device respondsToSelector:selector]) &#123;// 消除警告“performSelector may cause a leak because its selector is unknown”IMP imp = [device methodForSelector:selector];NSString * (*func)(id, SEL, NSString *) = (void *)imp;NSString *deviceColor = func(device, selector, @&quot;DeviceColor&quot;);NSString *deviceEnclosureColor = func(device, selector, @&quot;DeviceEnclosureColor&quot;);NSLog(@&quot;deviceColor --&gt; %@ \\n @&quot;deviceEnclosureColor --&gt; %@ &quot;, deviceColor, deviceEnclosureColor);&#125; mac 地址12345678910111213141516171819202122232425262728293031323334353637383940414243- (NSString *)getMacAddress &#123;int mib[6];size_t len;char *buf;unsigned char *ptr;struct if_msghdr *ifm;struct sockaddr_dl *sdl;mib[0] = CTL_NET;mib[1] = AF_ROUTE;mib[2] = 0;mib[3] = AF_LINK;mib[4] = NET_RT_IFLIST;if ((mib[5] = if_nametoindex(&quot;en0&quot;)) == 0) &#123;printf(&quot;Error: if_nametoindex error/n&quot;);return NULL;&#125;if (sysctl(mib, 6, NULL, &amp;len, NULL, 0) &lt; 0) &#123;printf(&quot;Error: sysctl, take 1/n&quot;);return NULL;&#125;if ((buf = malloc(len)) == NULL) &#123;printf(&quot;Could not allocate memory. error!/n&quot;);return NULL;&#125;if (sysctl(mib, 6, buf, &amp;len, NULL, 0) &lt; 0) &#123;printf(&quot;Error: sysctl, take 2&quot;);return NULL;&#125;ifm = (struct if_msghdr *)buf;sdl = (struct sockaddr_dl *)(ifm + 1);ptr = (unsigned char *)LLADDR(sdl);NSString *outstring = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x&quot;, *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)];free(buf);return [outstring uppercaseString];&#125; IP地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354- (NSString *)getDeviceIPAddresses &#123;int sockfd = socket(AF_INET, SOCK_DGRAM, 0);NSMutableArray *ips = [NSMutableArray array];int BUFFERSIZE = 4096;struct ifconf ifc;char buffer[BUFFERSIZE], *ptr, lastname[IFNAMSIZ], *cptr;struct ifreq *ifr, ifrcopy;ifc.ifc_len = BUFFERSIZE;ifc.ifc_buf = buffer;if (ioctl(sockfd, SIOCGIFCONF, &amp;ifc) &gt;= 0)&#123;for (ptr = buffer; ptr &lt; buffer + ifc.ifc_len; )&#123;ifr = (struct ifreq *)ptr;int len = sizeof(struct sockaddr);if (ifr-&gt;ifr_addr.sa_len &gt; len) &#123;len = ifr-&gt;ifr_addr.sa_len;&#125;ptr += sizeof(ifr-&gt;ifr_name) + len;if (ifr-&gt;ifr_addr.sa_family != AF_INET) continue;if ((cptr = (char *)strchr(ifr-&gt;ifr_name, &apos;:&apos;)) != NULL) *cptr = 0;if (strncmp(lastname, ifr-&gt;ifr_name, IFNAMSIZ) == 0) continue;memcpy(lastname, ifr-&gt;ifr_name, IFNAMSIZ);ifrcopy = *ifr;ioctl(sockfd, SIOCGIFFLAGS, &amp;ifrcopy);if ((ifrcopy.ifr_flags &amp; IFF_UP) == 0) continue;NSString *ip = [NSString stringWithFormat:@&quot;%s&quot;, inet_ntoa(((struct sockaddr_in *)&amp;ifr-&gt;ifr_addr)-&gt;sin_addr)];[ips addObject:ip];&#125;&#125;close(sockfd);NSString *deviceIP = @&quot;&quot;;for (int i=0; i &lt; ips.count; i++) &#123;if (ips.count &gt; 0) &#123;deviceIP = [NSString stringWithFormat:@&quot;%@&quot;,ips.lastObject];&#125;&#125;return deviceIP;&#125; CPU12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// CPU总数目- (NSUInteger)getCPUCount &#123;return [NSProcessInfo processInfo].activeProcessorCount;&#125;// 已使用的CPU比例- (float)getCPUUsage &#123;float cpu = 0;NSArray *cpus = [self getPerCPUUsage];if (cpus.count == 0) return -1;for (NSNumber *n in cpus) &#123;cpu += n.floatValue;&#125;return cpu;&#125;// 获取每个cpu的使用比例- (NSArray *)getPerCPUUsage &#123;processor_info_array_t _cpuInfo, _prevCPUInfo = nil;mach_msg_type_number_t _numCPUInfo, _numPrevCPUInfo = 0;unsigned _numCPUs;NSLock *_cpuUsageLock;int _mib[2U] = &#123; CTL_HW, HW_NCPU &#125;;size_t _sizeOfNumCPUs = sizeof(_numCPUs);int _status = sysctl(_mib, 2U, &amp;_numCPUs, &amp;_sizeOfNumCPUs, NULL, 0U);if (_status)_numCPUs = 1;_cpuUsageLock = [[NSLock alloc] init];natural_t _numCPUsU = 0U;kern_return_t err = host_processor_info(mach_host_self(), PROCESSOR_CPU_LOAD_INFO, &amp;_numCPUsU, &amp;_cpuInfo, &amp;_numCPUInfo);if (err == KERN_SUCCESS) &#123;[_cpuUsageLock lock];NSMutableArray *cpus = [NSMutableArray new];for (unsigned i = 0U; i &lt; _numCPUs; ++i) &#123;Float32 _inUse, _total;if (_prevCPUInfo) &#123;_inUse = ((_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER])+ (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM])+ (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE]));_total = _inUse + (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE]);&#125; else &#123;_inUse = _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER] + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM] + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE];_total = _inUse + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE];&#125;[cpus addObject:@(_inUse / _total)];&#125;[_cpuUsageLock unlock];if (_prevCPUInfo) &#123;size_t prevCpuInfoSize = sizeof(integer_t) * _numPrevCPUInfo;vm_deallocate(mach_task_self(), (vm_address_t)_prevCPUInfo, prevCpuInfoSize);&#125;return cpus;&#125; else &#123;return nil;&#125;&#125; Disk磁盘空间123456789101112131415161718192021222324252627// 获取磁盘总空间- (int64_t)getTotalDiskSpace &#123;NSError *error = nil;NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&amp;error];if (error) return -1;int64_t space = [[attrs objectForKey:NSFileSystemSize] longLongValue];if (space &lt; 0) space = -1;return space;&#125;// 获取未使用的磁盘空间- (int64_t)getFreeDiskSpace &#123;NSError *error = nil;NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&amp;error];if (error) return -1;int64_t space = [[attrs objectForKey:NSFileSystemFreeSize] longLongValue];if (space &lt; 0) space = -1;return space;&#125;// 获取已使用的磁盘空间- (int64_t)getUsedDiskSpace &#123;int64_t totalDisk = [self getTotalDiskSpace];int64_t freeDisk = [self getFreeDiskSpace];if (totalDisk &lt; 0 || freeDisk &lt; 0) return -1;int64_t usedDisk = totalDisk - freeDisk;if (usedDisk &lt; 0) usedDisk = -1;return usedDisk;&#125; Memory内存相关数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 系统总内存空间- (int64_t)getTotalMemory &#123;int64_t totalMemory = [[NSProcessInfo processInfo] physicalMemory];if (totalMemory &lt; -1) totalMemory = -1;return totalMemory;&#125;// 活跃的内存,正在使用或者很短时间内被使用过- (int64_t)getActiveMemory &#123;mach_port_t host_port = mach_host_self();mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);vm_size_t page_size;vm_statistics_data_t vm_stat;kern_return_t kern;kern = host_page_size(host_port, &amp;page_size);if (kern != KERN_SUCCESS) return -1;kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);if (kern != KERN_SUCCESS) return -1;return vm_stat.active_count * page_size;&#125;// 最近使用过,但是目前处于不活跃状态的内存- (int64_t)getInActiveMemory &#123;mach_port_t host_port = mach_host_self();mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);vm_size_t page_size;vm_statistics_data_t vm_stat;kern_return_t kern;kern = host_page_size(host_port, &amp;page_size);if (kern != KERN_SUCCESS) return -1;kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);if (kern != KERN_SUCCESS) return -1;return vm_stat.inactive_count * page_size;&#125;// 空闲的内存空间- (int64_t)getFreeMemory &#123;mach_port_t host_port = mach_host_self();mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);vm_size_t page_size;vm_statistics_data_t vm_stat;kern_return_t kern;kern = host_page_size(host_port, &amp;page_size);if (kern != KERN_SUCCESS) return -1;kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);if (kern != KERN_SUCCESS) return -1;return vm_stat.free_count * page_size;&#125;// 已使用的内存空间- (int64_t)getUsedMemory &#123;mach_port_t host_port = mach_host_self();mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);vm_size_t page_size;vm_statistics_data_t vm_stat;kern_return_t kern;kern = host_page_size(host_port, &amp;page_size);if (kern != KERN_SUCCESS) return -1;kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);if (kern != KERN_SUCCESS) return -1;return page_size * (vm_stat.active_count + vm_stat.inactive_count + vm_stat.wire_count);&#125;// 用来存放内核和数据结构的内存,framework、用户级别的应用无法分配- (int64_t)getWiredMemory &#123;mach_port_t host_port = mach_host_self();mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);vm_size_t page_size;vm_statistics_data_t vm_stat;kern_return_t kern;kern = host_page_size(host_port, &amp;page_size);if (kern != KERN_SUCCESS) return -1;kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);if (kern != KERN_SUCCESS) return -1;return vm_stat.wire_count * page_size;&#125;// 可释放的内存空间：内存吃紧自动释放，针对大对象存放所需的大块内存空间- (int64_t)getPurgableMemory &#123;mach_port_t host_port = mach_host_self();mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);vm_size_t page_size;vm_statistics_data_t vm_stat;kern_return_t kern;kern = host_page_size(host_port, &amp;page_size);if (kern != KERN_SUCCESS) return -1;kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);if (kern != KERN_SUCCESS) return -1;return vm_stat.purgeable_count * page_size;&#125; 作者：si1ence链接：https://www.jianshu.com/p/b23016bb97af來源：简书","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"}]},{"title":"RunLoop详解","slug":"RunLoop详解","date":"2019-04-23T09:17:43.000Z","updated":"2019-08-12T15:02:51.000Z","comments":true,"path":"2019/04/23/RunLoop详解/","link":"","permalink":"https://bigporo.github.io/2019/04/23/RunLoop详解/","excerpt":"RunLoop 详解RunLoop的概念一般来讲，一个线程一次只能执行一个任务，在执行完一个任务之后线程就退出了。通过RunLoop,我们可以让一个线程可以随时处理任务而不退出。","text":"RunLoop 详解RunLoop的概念一般来讲，一个线程一次只能执行一个任务，在执行完一个任务之后线程就退出了。通过RunLoop,我们可以让一个线程可以随时处理任务而不退出。 通常的代码逻辑是这样的：1234567function loop()&#123;do &#123;var message = get_next_message();process_message(message);&#125; while (message != quit);&#125; 这种模型通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。 所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。 OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 RunLoop与线程之间的关系CFRunLoop 是基于 pthread 来管理的。 线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。RunLoop是可以嵌套的。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。 1234567891011121314151617181920212223242526272829303132333435363738/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;/// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock;/// 获取一个 pthread 对应的 RunLoop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;OSSpinLockLock(&amp;loopsLock);if (!loopsDic) &#123;// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。loopsDic = CFDictionaryCreateMutable();CFRunLoopRef mainLoop = _CFRunLoopCreate();CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);&#125;/// 直接从 Dictionary 里获取。CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));if (!loop) &#123;/// 取不到时，创建一个loop = _CFRunLoopCreate();CFDictionarySetValue(loopsDic, thread, loop);/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。_CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);&#125;OSSpinLockUnLock(&amp;loopsLock);return loop;&#125;CFRunLoopRef CFRunLoopGetMain() &#123;return _CFRunLoopGet(pthread_main_thread_np());&#125;CFRunLoopRef CFRunLoopGetCurrent() &#123;return _CFRunLoopGet(pthread_self());&#125; RunLoop提供的接口1#include &lt;CoreFoundation/CFRunLoop.h&gt; 在 CoreFoundation 里面关于 RunLoop 有5个类: CFRunLoopRef CFRunLoopModeRef CFRunLoopSourceRef CFRunLoopTimerRef CFRunLoopObserverRef 其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。 他们的关系如下: 一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 CFRunLoopSourceRef是事件产生的地方。Source有两个版本：Source0 和 Source1。 Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。 处理APP内部事件、APP自己负责管理(触发)，如UIEvent等 Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。 由RunLoop和内核管理，Mach Port 驱动，如CFMachPort,CFMessagePort CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入LoopkCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 TimerkCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 SourcekCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 上面的 Source/Timer/Observer 被统称为mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 RunLoop的ModeCFRunLoopMode 和 CFRunLoop 的结构大致如下： 12345678910111213141516struct __CFRunLoopMode &#123;CFStringRef _name; // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;CFMutableSetRef _sources0; // SetCFMutableSetRef _sources1; // SetCFMutableArrayRef _observers; // ArrayCFMutableArrayRef _timers; // Array...&#125;;struct __CFRunLoop &#123;CFMutableSetRef _commonModes; // SetCFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;CFRunLoopModeRef _currentMode; // Current Runloop ModeCFMutableSetRef _modes; // Set...&#125;; 这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。 应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为“Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。 有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop自动更新到所有具有”Common”属性的 Mode 里去。 CFRunLoop对外暴露的管理 Mode 接口只有下面2个: 12CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);CFRunLoopRunInMode(CFStringRef modeName, ...); Mode 暴露的管理 mode item 的接口有下面几个：123456CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); 你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。 苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。还有一个私有的Mode是UIInitializationRunLoopMode, 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。 同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。 RunLoop内部逻辑RunLoop 内部的逻辑大致如下: 其内部代码整理如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/// 用DefaultMode启动void CFRunLoopRun(void) &#123;CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);&#125;/// 用指定的Mode启动，允许设置RunLoop超时时间int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&#125;/// RunLoop的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;/// 首先根据modeName找到对应modeCFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);/// 如果mode里没有source/timer/observer, 直接返回。if (__CFRunLoopModeIsEmpty(currentMode)) return;/// 1. 通知 Observers: RunLoop 即将进入 loop。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);/// 内部函数，进入loop__CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;Boolean sourceHandledThisLoop = NO;int retVal = 0;do &#123;/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);/// 执行被加入的block__CFRunLoopDoBlocks(runloop, currentMode);/// 4. RunLoop 触发 Source0 (非port) 回调。sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);/// 执行被加入的block__CFRunLoopDoBlocks(runloop, currentMode);/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。if (__Source0DidDispatchPortLastTime) &#123;Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)if (hasMsg) goto handle_msg;&#125;/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。if (!sourceHandledThisLoop) &#123;__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);&#125;/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。/// • 一个基于 port 的Source 的事件。/// • 一个 Timer 到时间了/// • RunLoop 自身的超时时间到了/// • 被其他什么调用者手动唤醒__CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg&#125;/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);/// 收到消息，处理消息。handle_msg:/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。if (msg_is_timer) &#123;__CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())&#125; /// 9.2 如果有dispatch到main_queue的block，执行block。else if (msg_is_dispatch) &#123;__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);&#125; /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件else &#123;CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);if (sourceHandledThisLoop) &#123;mach_msg(reply, MACH_SEND_MSG, reply);&#125;&#125;/// 执行加入到Loop的block__CFRunLoopDoBlocks(runloop, currentMode);if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;/// 进入loop时参数说处理完事件就返回。retVal = kCFRunLoopRunHandledSource;&#125; else if (timeout) &#123;/// 超出传入参数标记的超时时间了retVal = kCFRunLoopRunTimedOut;&#125; else if (__CFRunLoopIsStopped(runloop)) &#123;/// 被外部调用者强制停止了retVal = kCFRunLoopRunStopped;&#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;/// source/timer/observer一个都没有了retVal = kCFRunLoopRunFinished;&#125;/// 如果没超时，mode里没空，loop也没被停止，那继续loop。&#125; while (retVal == 0);&#125;/// 10. 通知 Observers: RunLoop 即将退出。__CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&#125; 可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 RunLoop底层实现RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。 为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图： 苹果用 RunLoop 实现的功能首先我们可以看一下 App 启动后 RunLoop 的状态： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CFRunLoop &#123;current mode = kCFRunLoopDefaultModecommon modes = &#123;UITrackingRunLoopModekCFRunLoopDefaultMode&#125;common mode items = &#123;// source0 (manual)CFRunLoopSource &#123;order =-1, &#123;callout = _UIApplicationHandleEventQueue&#125;&#125;CFRunLoopSource &#123;order =-1, &#123;callout = PurpleEventSignalCallback &#125;&#125;CFRunLoopSource &#123;order = 0, &#123;callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;// source1 (mach port)CFRunLoopSource &#123;order = 0, &#123;port = 17923&#125;&#125;CFRunLoopSource &#123;order = 0, &#123;port = 12039&#125;&#125;CFRunLoopSource &#123;order = 0, &#123;port = 16647&#125;&#125;CFRunLoopSource &#123;order =-1, &#123;callout = PurpleEventCallback&#125;&#125;CFRunLoopSource &#123;order = 0, &#123;port = 2407,callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;CFRunLoopSource &#123;order = 0, &#123;port = 1c03,callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;CFRunLoopSource &#123;order = 0, &#123;port = 1b03,callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;CFRunLoopSource &#123;order = 1, &#123;port = 1903,callout = __IOMIGMachPortPortCallback&#125;&#125;// OvserverCFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entrycallout = _wrapRunLoopWithAutoreleasePoolHandler&#125;CFRunLoopObserver &#123;order = 0, activities = 0x20, // BeforeWaitingcallout = _UIGestureRecognizerUpdateObserver&#125;CFRunLoopObserver &#123;order = 1999000, activities = 0xa0, // BeforeWaiting | Exitcallout = _afterCACommitHandler&#125;CFRunLoopObserver &#123;order = 2000000, activities = 0xa0, // BeforeWaiting | Exitcallout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exitcallout = _wrapRunLoopWithAutoreleasePoolHandler&#125;// TimerCFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0,next fire date = 453098071 (-4421.76019 @ 96223387169499),callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;&#125;,modes ＝ &#123;CFRunLoopMode &#123;sources0 = &#123; /* same as &apos;common mode items&apos; */ &#125;,sources1 = &#123; /* same as &apos;common mode items&apos; */ &#125;,observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,timers = &#123; /* same as &apos;common mode items&apos; */ &#125;,&#125;,CFRunLoopMode &#123;sources0 = &#123; /* same as &apos;common mode items&apos; */ &#125;,sources1 = &#123; /* same as &apos;common mode items&apos; */ &#125;,observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,timers = &#123; /* same as &apos;common mode items&apos; */ &#125;,&#125;,CFRunLoopMode &#123;sources0 = &#123;CFRunLoopSource &#123;order = 0, &#123;callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;&#125;,sources1 = (null),observers = &#123;CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000,callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;)&#125;,timers = (null),&#125;,CFRunLoopMode &#123;sources0 = &#123;CFRunLoopSource &#123;order = -1, &#123;callout = PurpleEventSignalCallback&#125;&#125;&#125;,sources1 = &#123;CFRunLoopSource &#123;order = -1, &#123;callout = PurpleEventCallback&#125;&#125;&#125;,observers = (null),timers = (null),&#125;,CFRunLoopMode &#123;sources0 = (null),sources1 = (null),observers = (null),timers = (null),&#125;&#125;&#125; 可以看到，系统默认注册了5个Mode: kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。 UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。 GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。 kCFRunLoopCommonModes: 这是一个占位的Mode,带有Common标记的字符串，没有实际作用。 AutoreleasePoolApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 小结：AutoreleasePool是在RunLoop即将开始的时候创建，是在RunLoop即将休眠时候释放。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 事件响应苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 手势识别当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 PerformSelecter当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 关于GCD实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。 当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。 定时器NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop， 关于网络请求iOS 中，关于网络请求的接口自下至上有如下几层: 1234CFSocketCFNetwork -&gt;ASIHttpRequestNSURLConnection -&gt;AFNetworkingNSURLSession -&gt;AFNetworking2, Alamofire CFSocket 是最底层的接口，只负责 socket 通信。 CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。 NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。 NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。 下面主要介绍下 NSURLConnection 的工作过程。 通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。 当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。 NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。 RunLoop 的实际应用举例AFNetworkingAFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop： 123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;@autoreleasepool &#123;[[NSThread currentThread] setName:@&quot;AFNetworking&quot;];NSRunLoop *runLoop = [NSRunLoop currentRunLoop];[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];[runLoop run];&#125;&#125;+ (NSThread *)networkRequestThread &#123;static NSThread *_networkRequestThread = nil;static dispatch_once_t oncePredicate;dispatch_once(&amp;oncePredicate, ^&#123;_networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];[_networkRequestThread start];&#125;);return _networkRequestThread;&#125; RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。 12345678910- (void)start &#123;[self.lock lock];if ([self isCancelled]) &#123;[self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];&#125; else if ([self isReady]) &#123;self.state = AFOperationExecutingState;[self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];&#125;[self.lock unlock];&#125; 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。 AsyncDisplayKitAsyncDisplayKit是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下： UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。 排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。 其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。 为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。 ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。 TableView中实现平滑滚动延迟加载图片利用CFRunLoopMode的特性，可以将图片的加载放到NSDefaultRunLoopMode的mode里，这样在滚动UITrackingRunLoopMode这个mode时不会被加载而影响到。 12345UIImage *downloadedImage = ...;[self.avatarImageView performSelector:@selector(setImage:)withObject:downloadedImageafterDelay:0inModes:@[NSDefaultRunLoopMode]]; ibireme：深入理解RunLoop iOS线下分享《RunLoop》by 孙源@sunnyxx","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"}]},{"title":"《Effective Objective-C 2.0》读书总结","slug":"《Effective Objective-C 2.0》读书总结","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T09:12:31.000Z","comments":true,"path":"2019/04/23/《Effective Objective-C 2.0》读书总结/","link":"","permalink":"https://bigporo.github.io/2019/04/23/《Effective Objective-C 2.0》读书总结/","excerpt":"Objective-C了解 Objective-C 语言的起源Objective-C 语言使用”消息结构”而非”函数调用”.Objective-C 语言由 SmallTalk演化而来,后者是消息类型语言的鼻祖.编译器甚至不关心接收消息对象的何种类型.接收消息的对象问题也要在运行时处理,其过程叫做”动态绑定”. Objective-C为 C 语言添加了面向对象特性,是其超类. Objective-C 使用动态绑定的消息结构,也就是说,在运行时才会检查对象类型.接收一条消息后,究竟应执行何种代码,有运行期环境而非编译器决定.理解 C 语言的核心有助于写好 Objective-C 程序.尤其是掌握内存模型与指针.","text":"Objective-C了解 Objective-C 语言的起源Objective-C 语言使用”消息结构”而非”函数调用”.Objective-C 语言由 SmallTalk演化而来,后者是消息类型语言的鼻祖.编译器甚至不关心接收消息对象的何种类型.接收消息的对象问题也要在运行时处理,其过程叫做”动态绑定”. Objective-C为 C 语言添加了面向对象特性,是其超类. Objective-C 使用动态绑定的消息结构,也就是说,在运行时才会检查对象类型.接收一条消息后,究竟应执行何种代码,有运行期环境而非编译器决定.理解 C 语言的核心有助于写好 Objective-C 程序.尤其是掌握内存模型与指针. 在类的头文件中尽量少引用其他头文件Objective-C 语言编写类的标准行为:以类名做文件名,分别闯将两个文件,有文件后缀用. h,实现文件后缀用. m. 在开发中有时候我们会在. h 文件中引入很多用不到的内容,这当然会增加编译时间.除非有必要,否则不要引入头文件,一般来说,某个类的头文件中使用向前声明来体积别的类,并在实现文件中引入哪些类的头文件,这样做可以尽量降低类之间的耦合.有时无法使用向前声明,比如要声明某个类遵循意向协议,这种情况下,尽量把 “该类遵循某协议”的这条声明移至 class=continuation 分类中,如果不行的话,就把协议单独存放在一个头文件中,然后将其引入. 多用字面量语法,少用与之等价的方法12NSArray *arr = [NSArray arrayWithObjects:@&quot;num1&quot;,@&quot;num2&quot;,@&quot;num3&quot;, nil];NSArray *arr = @[@&quot;num1&quot;,@&quot;num2&quot;,@&quot;num3”]; 字面量语法创建字符串,数组,数值,字典.与创建此类对象的常规方法相比,这么做更加简明扼要，并且更加安全。 注意事项: 除了字符串以外,所创建的类必须属于 Foundation 框架才行,如果自定义了这些类的子类,则无法用字面量语法创建其对象. 创建的数组或字典时,若值有 nil, 则会抛出异常.因此,务必确保值中不含 nil。 多用类型常量,少用# deine 预处理指令不要用预处理指令定义常量,这样定义出来的常量不含类型信息,编译器只会在编译前根据执行查找与替换操作,即使有人重新定义了常量值,编译器也不会产生井道信息,这将导致应用程序常量值不一致. 1static NSString *const PersonConstant = @&quot;PersonConstantStr” ; 但是我个人认为其实,还是#define用的多, 开发避免不了使用 pch文件, 同时#define还可以定义方法，这个是类型常量无法做到的。 如果有强迫症的同学,定义常量就想使用 staitc,extren,const 这些关键字.那我建议新建一个专门存放这些常量的类,然后在 pch 中导入这个类. static 修饰符意味着该变量仅在定义此变量的单元中可见 extern 全局变量 用枚举表示状态,选项,状态码应该用枚举来表示状态机的状态,传递给方法的选项以及状态码等值,给这些值起个易懂的名字。 如果把传递的给某个方法的选项表示为枚举类型，而多个类型又可同时使用，那么就将各选项值定义为2的幂，通过按位或操作将其结合起来。 123456enum PersonEnum&#123;PersonEnumNum1,PersonEnumNum2,PersonEnumNum3,&#125;;typedef enum PersonEnum PersonState; 对象、消息、运行时理解属性这一概念属性是 Objective-C 的一项特性,用于封存对象中的数据.属性特质:原子性 读写权限 内存管理语义: assign 这是方法只会执行针对纯量类型(CGFloat,NSInteger)的简单赋值操作 strong 此特质表明该属性定义一种拥有关系,为这种属性设置新值时,这只方法会先保存新值,并释放旧值 weak 此特质表明属性定义了一种”非拥有关系”,为这种属性设置新值是,设置方法既不保留新值,也不释放旧值.此特质同 assign 类似,然而在属性所指对象遭到摧毁时,属性值会清空 unsafe_unretainde 此特质与 assign 相同,它适用于对象类型,该特质表达一种”非拥有关系”,当目标对象遭到摧毁时,属性不会自动清空,因为它是不安全的,这一点与 weak 的区别 copy 此特质所表达的所属关系与 strong 类似,然而设置方法并不保留新值,而是将其拷贝,多用于 NSString. 在对象内部尽量直接访问实例变量直接访问实例变量的速度比较快,因为不经过 Objective-C 方法派发,编译器所生成的代码会直接访问保存催下实例量的那块内存。直接访问实例变量时,不会调用设置方法,这就绕过了相关属性所定义的内存管理语义。 读取实例变量的时候采用直接访问的的形式，设置实例变量的时候通过属性来做。 注意： 直接访问访问实例变量，不会触发KVO。 懒加载时，必须通过属性来读取数据。 理解”对象等同性”这一概念根据等同性来比较对象是一个非常有用的功能,不过,按照 == 操作符比较出来的结果未必是我们想要的,因为该操作比较的事两个指针本身,而不是其所指的对象，应该使用 NSObject 协议中的声明的”isEqual”方法来判断两个对象的等同性,一般来说两个类型不同的对象总是不相等的.直接比较字符串的时候 isEqual 比 isEqualToString慢,因为前者还要执行额外步骤. NSObjec中有两个判断等同性的关键方法:12- (BOOL) isEqual:(id)object;- (NSUInteger)hash; 以”类族模式”隐藏实现细节“类族”是一种很有用的模式,可以隐藏抽象基类背后实现的细节. 这是一种”工厂模式”.比如iOS 用户界面框架 UIKit 中就有一个名为 UIButton 的类.想创建按钮,需要调用下面这个类方法。1+ (UIButton*)buttonWithType:(UIButtonType)type; 在既有类中使用关联对象存放自定义数据有时需要在对象中存放相关信息,这是我们通常会从对象所属的类中继承一个子类,然后改用这个子类对象.然而并非所有情况下都这么做,有时候类的实例可能是由某种机制所创建的,而开发者无法令这种机制创建出自己所写的实例. Objective-C 中有一项强大的特性可以解决问题,这就是关联对象。 123456//关联对象void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)//获取关联的对象id objc_getAssociatedObject(id object, const void *key)//移除关联的对象void objc_removeAssociatedObjects(id object) 理解objc_msgSend的作用用Objetive-C的术语来说，这叫做“消息传递”。这里说的是运行时。 理解消息转发机制当对象接收到无法解读的消息后，就会启动消息转发机制，程序员可经此过程告诉对象应该图和处理未知消息。这里说的是运行时。 动态方法解析 1234567891011+ (BOOL)resolveClassMethod:(SEL)sel&#123;/**动态消息转发if (sel == @selector(foo:)) &#123;class_addMethod([self class], sel, (IMP)fooMethod, &quot;v@:&quot;);&#125;return [super resolveInstanceMethod:sel];*/return YES; // 进入下一步转发&#125; 备用接收者 123456789101112- (id)forwardingTargetForSelector:(SEL)aSelector&#123;/**备用接收者if (aSelector == @selector(foo)) &#123;return [Person new]; // 返回一个Person实例作为备用接收者&#125;return [super forwardingTargetForSelector:aSelector];*/return nil; // 进入下一步转发&#125; 完整的消息转发 12345678910111213141516171819- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;if (aSelector == @selector(foo)) &#123;return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];//签名，进入forwardInvocation&#125;return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;SEL sel = anInvocation.selector;Person *person = [Person new];if ([person respondsToSelector:sel]) &#123;[anInvocation invokeWithTarget:person]; // 直接调用 person 的 foo 方法&#125;else&#123;[self doesNotRecognizeSelector:sel];&#125;&#125; 用方法调配技术调试黑盒方法运行期间，可以向类中新增或替换选择子所对应的方法实现。使用另一份实现来替换原有的方法实现，这道工序叫做方法调配，开发者常用此技术想原有实现中添加新功能。一般来说，只有调试程序的时候才需要运行期修改方法实现，这种做法不易滥用。这里说的是方法交换。 理解类对象的用意每个Objective-C对象实例都是指向某块内存数据的指针，如果把对象所需的内存分配到栈上编译器就会报错. 每个对象结构体的首个成员是Class类的变量，该变量定义了对象所属的类，通常称为isa指针。 12345678910111213typedef struct objc_class *classstruct objc_class&#123;Class isa;Class super_class;const char* name;long version;long info;long instance_size;struct objc_ivar_list *ivars;struct objc_method_list *ivars;struct objc_cache *cache;struct objc_protocol_list protocols;&#125; 此结构体存放类的元数据，例如类的实例实现了几个方法，具备多少个实例变量等信息。此结构体的首个变量也是isa指针，这说明Class本身亦为Objctive-C对象。结构体里还有个变量叫做super_class,它定义本类的超类，类对象所属的类型（isa指针所指向的类型）是另外一个类，叫做元类，用来标书类本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法，每个类仅有一个类对象，每个类对象仅有一个与之相关的元类。（元数据，就是这个类的数据）。 isKindOfClass：能够判断对象是否为某类或其派生类的实例 isMemberOfClass: 能够判断出对象是否为某个特定类的实例 接口设计用前缀避免命名空间冲突Objective-C没有其他语言那种内置的命名空间，所以需要避免命名冲突，否则会直接报错。 提供全能初始化方法即可以为对象提供必要信息以便其完成能完成工作的初始化方法。 注意：如果子类的全能初始化方法与父类的不一致，就应该覆写父类的全能初始化方法。有时我们不想覆写，这时我们可以覆写父类的全能初始化方法并在里面抛出异常。 实现description方法调试程序时经常需要打印并查看对象信息。description 很实用。 debugDescription 方法是开发者在调试器中以命令打印对象时候才调用。12345678910111213141516171819Person.h#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@property(nonatomic,assign)int age;@property(nonatomic ,copy)NSString* name;@endPerson.m#import &quot;Person.h&quot;@implementation Person- (NSString *)description&#123;return [NSString stringWithFormat:@&quot;name %@ , age %d&quot;, self.name, self.age];&#125;- (NSString *)debugDescription&#123;return [NSString stringWithFormat:@&quot;name %@ , age %d&quot;, self.name, self.age];&#125;@end 尽量使用不可变对象通过readonly将属性修饰为不可变，如果想修改封装在对象内部的数据，可以在对象的内部将readonly属性重新声明为readwrite。 注意:readonly修饰的属性，仍然可以使用KVC来修改。 使用清晰而协调的全名方式没啥好说的 为私有方法名加前缀不要单用一个下划线给私有方法做前缀，这个是苹果爸爸用的。 理解Objective-C错误模型NSError的用法更加灵活，因此经由此对象，我们可以把导致错误的原因汇报给调用者。 NSError domain(错误范围，其类型为字符串)错误发生的范围，也就是产生错误的根源，通常用一个特有的全局变量来定义，比方说 “处理URL子系统”从URL的解析获取数据时如果出错了，那么就会使用NSURLErrorDomain来表示错误范围 Error code(错误码，其类型为整数)独有的错误代码，用以指明在某个范围内具体发生了何种错误。某个特性范围内可能会发生一系列相关错误，这些错误情况通常采用enum来定义。例如，当HTTP请求出错时，可能会把HTTP状态码设为错误码 User info(用户信息，其类型为字典)有关错误的额外信息，其中或许包含一段“本地化的描述”或许还含有导致错误发生的另外一个错误，经由此种信息，可将相关错误串成一条“错误链” 123456789101112@try &#123;NSString *str = @&quot;wotaxiwa&quot;;NSString *strErr = [str substringFromIndex:100];NSLog(@&quot;%@&quot;,str);&#125; @catch (NSException *exception) &#123;NSLog(@&quot;ERROR: %@&quot;,exception);&#125; @finally &#123;NSLog(@&quot;%s&quot;,__func__);&#125;如果出现exception，异常后面的代码将不会继续执行 理解NSCopying协议 copy方法实际上是调用 -(id)copyWithZone:(NSZone*)zone; 实现copy操作， 如果想对自己的类支持拷贝并且做额外操作，那就要实现NSCopying协议此的方法。为何出现NSZone呢，以前开发程序时，会据此把内存分成不用的区，而对象会创建在某个区。 现在不用了，每个程序只有一个区：“默认区”，所以不用担心zone参数。copy方法由NSObject实现，该方法只是以默认区为参数调用。 mutableCopy方法实际上是调用 -(id)mutableCopyWithZone:(NSZone*)zone; 实现mutableCopy操作 协议与分类通过委托与数据协议进行对象间通信这一条说的就是delegate(代理设计模式)。但是并没有说delegate的循环引用的问题,在使用代理声明一个 @property的时候，记得用weak。 将类的实现代码分散到便于管理的数个分类之中 使用分类机制把类的实现代码划分成易于管理的小块 将应该视为“私有”的方法归入名为Private的分类中，以隐藏细节。 勿在分类中声明属性正常的分类是不可以声明属性的，但是从技术上说，分类里可以用runtime声明属性。 1234567891011#import &lt;objc.runtime.h&gt;static const char *kFriendsPropertyKey = “kFriendsPropertyKey”;@implementation EOCPerson(Friendship)-(NSArray*)friends&#123;return objc_getAssociatedObject(self,kFriendsPropertyKey);&#125;-(void)setFriends:(NSArray*)friends&#123;objc_setAssociateObject(self.kFriendsPropertyKey,friends,OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 这样做可行，但是不太理想，要把相似的代码写很多遍。而且容易出现Bug，可以使用class-continuation实现分类添加属性。 使用class-continuation分类隐藏实现细节class-continuation分类和普通的分类不同，它必须在其所接续的那个类的实现文件里。其重要之处在于，这是唯一能声明实例变量的分类，而且此分类没有特定的实现文件，其中的方法应该定义在类的主实现文件里。与其他分类不同，“class-continuation分类”没有名字，比如，有个类叫做EOCPerson，其“class-continuation分类”写法如下： 12345678910111213141516171819@interface EOCPerson()@end#import &quot;ViewController.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];&#125;- (void)didReceiveMemoryWarning &#123;[super didReceiveMemoryWarning];&#125;@end 没错它就是 class-continuation分类，在此代码之间可以添加属性，修改属性。 12@interface ViewController ()@end 使用class-continuation分类的好处 可以向类中新增实例变量。 如果类中的主接口声明为只读，可以再类内部修改此属性。 把私有方法的原型文件生命在”class-continuation分类”里面。 想使类遵循的协议不为人知，可以用“class-continuation分类”中声明。 通过协议提供匿名对象就说下面这句话1@property (nonatomic,weak)id&lt;PersonDelegate&gt; pd; 内存管理理解引用计数理解引用计数，方便于了解iOS的内存管理。不过现在都是ARC的时代了。 引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当保存计数降为0，对象就被销毁了。 在对象生命期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。 以ARC简化引用计数使用ARC要计数，引用计数实际上还是要执行的，只不过保留与释放操作现在由ARC自动为你添加。由于ARC会自动执行retain、release、autorelease等操作，所以直接在ARC下调用这些内存管理方法是非法的。 ARC管理对象生命周期的的办法基本就是：在合适的位置插入“保留”和“释放”操作。 ARC在调用这些方法时，并不用过普通的Objective-C消息派发机制，而是直接调用其底层C语言版本，这样做性能更好，直接调用底层函数节省很多CPU周期。 虽然有了ARC之后无需担心内存管理问题，但是CoreFoundation对象不归ARC管理，开发者必须适时调用CFRetain/CFRelease。 在dealloc方法中只释放引用并解除监听 当一个对象销毁的时候会调用dealloc方法，但是当开销较大或系统内稀缺资源则不再此列，像是文件描述、套接字、大块内存等都属于这种资源，通常对于开销较大的资源实现一个方法，当程序用完资源对象后，就调用此方法。这样一来，资源对象的生命期就变得明确了。 执行异步任务的方法不应该在dealloc里面调用；只能在正常状态下调用的那些方法也不应该调用，因为此时对象已经处于正在回收的状态了。 编写“异常安全代码”时留意内存管理问题 在使用@try 的时也要注意，在捕获到异常的时候@try{}中的语句执行到异常代码的那一行后不在执行，然后把异常抛给@catch。当然@finally是一定要执行的。 在默认情况下，ARC不生成安全处理异常所需的清理代码。开启编译器标志后，可以生成这种代码，不过会导致应用程序变大，而且会降低运行效率。 以弱引用避免保留环 unsafe_unretained 语义同assign等价。然而assign通常用于int、float、结构体等。unsafe_unretained多用于对象类型。 weak 与 unsafe_unretained 作用相同，然而只要系统把属性回收，属性值为nil。推荐使用weak，毕竟是ARC时代的产物，而且用的人也很多。 以“自动释放池块”降低内存峰值自动释放池排布在栈中，对象收到autorelease消息后，系统将其放入最顶端的池里。12345678910111213141516@autoreleasepool &#123;&lt;#statements#&gt;&#125;for (int i = 0; i &lt; 1000000; i++) &#123;@autoreleasepool &#123;NSNumber *num = [NSNumber numberWithInt:i];NSString *str = [NSString stringWithFormat:@&quot;%d &quot;, i];[NSString stringWithFormat:@&quot;%@%@&quot;, num, str];if(lagerNum-1 == i)&#123;NSLog(@&quot;end&quot;);&#125;&#125;&#125; 用“僵尸对象”调试内存管理问题在左上角标题栏找到项目单击后选择 Edit scheme 勾选图中检测僵尸对象。 开启后，系统在回收对象的时候，可以不真的将其回收，而是转成僵尸对象。 系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使该对象变成僵尸对象。僵尸类能响应所有的方法，响应方式为：打印一条包含消息内容及其接受者的消息，然后终止应用程序。 不要使用retainCount 任何给定时间点上的“绝对保留计数”都无法反应对象生命周期的全貌。 ARC的时代，调用该方法会直接报错。 块与大中枢派发理解”块“这一概念这里其实就是在说block，复习一下block的语法：返回值类型（block名称)(参数) 需要注意的是定义block时候，其所占内存区域是分配在栈中的，块只在定义它的那个范围内有效。 block所使用的整个内存区域，在编译期已经完全确定，因此，全局block可以生命在全局内存里，而不需要在每次用到的时候于栈中创建，另外，全局block的拷贝是个空操作，因为全局block绝不可能为系统所回收，这种block实际上相当于单例。 可以调用 copy 方法将块从栈拷贝到堆，拷贝之后的块就可以在定义它的范围之外使用了。而且，拷贝到堆以后，块就变成带引用计数的对象了，后续的copy操作不会真的执行，只是递增引用计数。 为常用的块类型创建typedef就是给block起个别名12typedef &lt;#returnType#&gt;(^&lt;#name#&gt;)(&lt;#arguments#&gt;);@property (nonatomic,copy)name nm_blk; 用handler块降低代码分散程度说的就是block的回调。只不过是把block放在方法中去使用,使代码更加紧致。 12345678910111213141516171819202122// Person.h#import &lt;Foundation/Foundation.h&gt;typedef void(^Blk)(NSString *name,int age);@interface Person : NSObject-(void)handler:(Blk)blk;@end// Person.m#import &quot;Person.h@implementation Person-(void)handler:(Blk)blk&#123;if(blk)&#123;blk(@&quot;zhangsan&quot; ,28);&#125;&#125;@end// 使用Person *per =[Person new];[per handler:^(NSString *name, int age) &#123;NSLog(@&quot;%@ %d&quot;,name, age);&#125;]; 用块引用其所属对象时不要出现保留环注意用weak，不要出现循环引用。 多用派发队列，少用同步锁派发队列可用来表述同步语义，这种做法比使用@synchronize块或NSLock对象更简单将同步与异步派发结合起来，可以实现与普通枷锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程。 使用同步队列及栅栏块，可以令同步行为更加高效（不常用）。 多用GCD，少用performSelector系列方法这个没啥可说的 掌握GCD及操作队列的适用时机这个没啥可说的 解决多线程与任务管理问题时，派发队列并非唯一方案 操作队列提供了一套高层的Objective-C API 能实现纯GCD所具备的绝大部分功能，而且还完成一些更为复杂的操作，那些操作弱改用GCD来实现，则需另外编写代码。 使用NSOperation对线程管理 通过Dispatch Group机制，根据系统资源状况来执行任务这个没啥可说的一系列任务可归入一个dispatch group之中。开发者可以在这组任务执行完毕时获得通知通过dispatch group，可以在并发式派发队列里同时执行多项任务。此时GCD会根据系统西苑状况来调度这些并发执行的任务。开发者若自己来实现此功能。则需要便携大量代码。 使用dispatch_once来执行秩序运行一次的线程安全代码1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;&lt;#code to be executed once#&gt;&#125;); 不用使用dispatch_get_current_queue这个没啥可说的。iOS系统6.0版本起，已经正式弃用此函数了。 系统框架熟悉系统框架打开Xcode command + shift + 0 选择性的了解一些 Foundation、UIKit也可以看看这篇博客 http://www.jianshu.com/p/58bc11c800e4 多用块枚举，少用for循环因为枚举遍历的时候用的多线程（GCD并发执行），所以效率更快些。我觉得其实用什么都行。 123NSArray *arr = @[@&quot;b&quot;,@&quot;c&quot;,@&quot;s&quot;];[arr enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;&#125;]; 对自定义其内存管理语义的collection使用无缝桥接123NSArray *anNSArray = @[@1,@3,@5,@8];CFArrayRef acFArray = (__bridge CFArrayRef)anNSArray;NSLog(@&quot;%@&quot;,acFArray); 通过无缝桥接技术，可以在Foundation框架中Objective-C对象与CoreFoundation框架中的C语言数据结构之间来回转换。 在CoreFoundation层面穿件collection时，可以指定许多回调函数，这些函数表示此collection应如何处理其元素，然后可运用无缝桥接技术，将其转换成具备特殊内存管理语义的Objective-C collection。 __bridge:ARC仍然具备这个OC对象的所有权 bridgeretained:ARC将交出对象的所有权 构建缓存时选用NSCache而非NSDictionary NSCache胜过NSDictionary之处在于，当系统资源耗尽时，它能自动删减缓存。 NSCache线程安全 精简Initialize与load的实现代码类初始化的时候一定会调用两个方法 12345678+(void)load&#123;&#125;+ (void)initialize&#123;if (self == [&lt;#ClassName#&gt; class]) &#123;&lt;#statements#&gt;&#125;&#125; load方法只会调用一次，不管该类的头文件有没有被使用，该类都会被系统自动调用，而且只调用一次。 当然了，如果不重写这个方法的话，我们是不知道这个方法有没有被调用的。如果分类也重写了load方法，先调用类里的，在调用分类。 load方法执行时，运行期系统处于“脆弱状态”，在执行子类的load方法之前，必定会先执行所以超类的load方法，而如果代码还依赖了其他的库，那么其他库的相关类的load方法一定会先执行，但是执行的顺序不好判断，所以在load方法中使用其他类是不安全的。 整个程序在执行load方法时都会阻塞。 initialize 和load类似，不过在类被初始化的时候才会被调用（init之前）。需要注意的是，&lt;#ClassName#&gt;如果有子类继承的时候要判断类名。 两个方法的实现都应该精简些，这有助于保持应用程序的响应能力。 别忘了NSTimer会保留其目标对象1234567891011121314151617181920212223242526272829303132333435363738394041// Person.h#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@property (nonatomic,strong)NSTimer *timer;-(void)start;-(void)stop;@end// Person.m#import &quot;Person.h&quot;@implementation Person-(void)start&#123;self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(run) userInfo:nil repeats:YES];&#125;-(void)run&#123;NSLog(@&quot;%s&quot;,__func__);&#125;-(void)dealloc&#123;NSLog(@&quot;%s&quot;,__func__);&#125;-(void)stop&#123;[self.timer invalidate];&#125;@end调用@property (nonatomic,strong)Person *person;self.person = [Person new];[self.person start];-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;[self.person stop];&#125; 好，那么问题来了，是不是没有调用dealloc方法，没有调用dealloc方法就说明Person对象并没有被销毁，为什么没有被销毁因为在控制器强引用了self.person，[self.person start]强引用了 self.timer; self.timer 的target指向了self（self.person）所以循环引用了。 怎么解决。 NSTimer销毁的时候，把Person对象为nil即可。 1234-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;[self.person stop];self.person = nil;&#125;","categories":[{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/categories/读书/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/tags/读书/"}]},{"title":"Runtime原理篇","slug":"Runtime原理篇","date":"2019-04-23T09:17:43.000Z","updated":"2019-08-12T15:03:11.000Z","comments":true,"path":"2019/04/23/Runtime原理篇/","link":"","permalink":"https://bigporo.github.io/2019/04/23/Runtime原理篇/","excerpt":"Runtime介绍 Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。 Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。了解 Runtime ，要先了解它的核心 - 消息传递 （Messaging）","text":"Runtime介绍 Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。 Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。了解 Runtime ，要先了解它的核心 - 消息传递 （Messaging） Runtime其实有两个版本: “modern” 和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统，只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中。而 macOS 较老的32位程序仍采用 Objective-C 1 中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。 Runtime 基本是用 C 和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在这里下到苹果维护的开源代码。苹果和GNU各自维护一个开源的 runtime 版本，这两个版本之间都在努力的保持一致。平时的业务中主要是使用官方Api，解决我们框架性的需求。高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但是OC并不能直接编译为汇编语言，而是要先转写为纯C语言再进行编译和汇编的操作，从OC到C语言的过渡就是由runtime来实现的。然而我们使用OC进行面向对象开发，而C语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。 Runtime消息传递一个对象的方法像这样[obj foo]，编译器转成消息发送objc_msgSend(obj, foo)，Runtime时执行的流程是这样的： 首先，通过obj的isa指针找到它的 class ; 在 class 的 method list 找 foo ; 如果 class 中没到 foo，继续往它的 superclass 中找 ; 一旦找到 foo 这个函数，就去执行它的实现IMP 。 但这种实现有个问题，效率低。但一个class 往往只有 20% 的函数会被经常调用，可能占总调用次数的 80% 。每个消息都需要遍历一次objc_method_list 并不合理。如果把经常被调用的函数缓存下来，那可以大大提高函数查询的效率。这也就是objc_class 中另一个重要成员objc_cache 做的事情 - 再找到foo 之后，把foo 的method_name 作为key ，method_imp作为value 给存起来。当再次收到foo 消息的时候，可以直接在cache 里找到，避免去遍历objc_method_list。从前面的源代码可以看到objc_cache是存在objc_class 结构体中的。objec_msgSend的方法定义如下： 1OBJC_EXPORT id objc_msgSend(id self, SEL op, ...) 那消息传递是怎么实现的呢？我们看看对象(object)，类(class)，方法(method)这几个的结构体： 1234567891011121314151617181920212223242526272829303132333435//对象struct objc_object &#123;Class isa OBJC_ISA_AVAILABILITY;&#125;;//类struct objc_class &#123;Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__Class super_class OBJC2_UNAVAILABLE;const char *name OBJC2_UNAVAILABLE;long version OBJC2_UNAVAILABLE;long info OBJC2_UNAVAILABLE;long instance_size OBJC2_UNAVAILABLE;struct objc_ivar_list *ivars OBJC2_UNAVAILABLE;struct objc_method_list **methodLists OBJC2_UNAVAILABLE;struct objc_cache *cache OBJC2_UNAVAILABLE;struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;//方法列表struct objc_method_list &#123;struct objc_method_list *obsolete OBJC2_UNAVAILABLE;int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__int space OBJC2_UNAVAILABLE;#endif/* variable length structure */struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;//方法struct objc_method &#123;SEL method_name OBJC2_UNAVAILABLE;char *method_types OBJC2_UNAVAILABLE;IMP method_imp OBJC2_UNAVAILABLE;&#125; 系统首先找到消息的接收对象，然后通过对象的isa找到它的类。 在它的类中查找method_list，是否有selector方法。 没有则查找父类的method_list。 找到对应的method，执行它的IMP。 转发IMP的return值。 消息传递用到的一些概念类对象(objc_class)Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。类对象(Class)是由程序员定义并在运行时由编译器创建的，它没有自己的实例变量，这里需要注意的是类的成员变量和实例方法列表是属于实例对象的，但其存储于类对象当中的。 1typedef struct objc_class *Class; 查看objc/runtime.h中objc_class结构体的定义如下： 12345678910111213141516struct objc_class &#123;Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__Class _Nullable super_class OBJC2_UNAVAILABLE;const char * _Nonnull name OBJC2_UNAVAILABLE;long version OBJC2_UNAVAILABLE;long info OBJC2_UNAVAILABLE;long instance_size OBJC2_UNAVAILABLE;struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE;struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE;struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE;struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; struct objc_class结构体定义了很多变量，通过命名不难发现，结构体里保存了指向父类的指针、类的名字、版本、实例大小、实例变量列表、方法列表、缓存、遵守的协议列表等，一个类包含的信息也不就正是这些吗？没错，类对象就是一个结构体struct objc_class，这个结构体存放的数据称为元数据(metadata)，该结构体的第一个成员变量也是isa指针，这就说明了Class本身其实也是一个对象，因此我们称之为类对象，类对象在编译期产生用于创建实例对象，是单例。 参数解析 isa指针是和Class同类型的objc_class结构指针，类对象的指针指向其所属的类，即元类。元类中存储着类对象的类方法，当访问某个类的类方法时会通过该isa指针从元类中寻找方法对应的函数指针。 super_class指针指向该类所继承的父类对象，如果该类已经是最顶层的根类(如NSObject或NSProxy), 则 super_class为NULL。 cache：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，但提高了调用的效率。 version：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。 protocols：当然可以看出这一个objc_protocol_list的指针。关于objc_protocol_list的结构体构成后面会讲。 获取类名 1const char * class_getName ( Class cls ); 动态创建类 12345678// 创建一个新类和元类Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes ); //如果创建的是root class，则superclass为Nil。extraBytes通常为0// 销毁一个类及其相关联的类void objc_disposeClassPair ( Class cls ); //在运行中还存在或存在子类实例，就不能够调用这个。// 在应用中注册由objc_allocateClassPair创建的类void objc_registerClassPair ( Class cls ); //创建了新类后，然后使用class_addMethod，class_addIvar函数为新类添加方法，实例变量和属性后再调用这个来注册类，再之后就能够用了。 实例(objc_object)实例对象是我们对类对象alloc或者new操作时所创建的，在这个过程中会拷贝实例所属的类的成员变量，但并不拷贝类定义的方法。调用实例方法时，系统会根据实例的isa指针去类的方法列表及父类的方法列表中寻找与消息对应的selector指向的方法。1234567/// Represents an instance of a class.struct objc_object &#123;Class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id; 另外我们常见的id类型，它是一个objc_object结构类型的指针。该类型的对象可以转换为任何一种对象，类似于C语言中void *指针类型的作用。其定义如下所示: 123/// A pointer to an instance of a class.typedef struct objc_object *id;#endif 对对象的类操作 123456// 返回给定对象的类名const char * object_getClassName ( id obj );// 返回对象的类Class object_getClass ( id obj );// 设置对象的类Class object_setClass ( id obj, Class cls ); 获取对象的类定义 12345678910111213// 获取已注册的类定义的列表int objc_getClassList ( Class *buffer, int bufferCount );// 创建并返回一个指向所有已注册类的指针列表Class * objc_copyClassList ( unsigned int *outCount );// 返回指定类的类定义Class objc_lookUpClass ( const char *name );Class objc_getClass ( const char *name );Class objc_getRequiredClass ( const char *name );// 返回指定类的元类Class objc_getMetaClass ( const char *name ); 动态创建对象 12345678// 创建类实例id class_createInstance ( Class cls, size_t extraBytes ); //会在heap里给类分配内存。这个方法和+alloc方法类似。// 在指定位置创建类实例id objc_constructInstance ( Class cls, void *bytes ); // 销毁类实例void * objc_destructInstance ( id obj ); //不会释放移除任何相关引用 元类(Meta Class)类对象中的元数据存储的都是如何创建一个实例的相关信息，那么类对象和类方法应该从哪里创建呢？就是从isa指针指向的结构体创建，类对象的isa指针指向的我们称之为元类(metaclass)，元类中保存了创建类对象以及类方法所需的所有信息，因此整个结构应该如下图所示: 通过上图我们可以看出整个体系构成了一个自闭环，struct objc_object结构体实例它的isa指针指向类对象，类对象的isa指针指向了元类，super_class指针指向了父类的类对象，而元类的super_class指针指向了父类的元类，那元类的isa指针又指向了自己。元类(Meta Class)是一个类对象的类。 操作函数 1234567// 获取类的父类Class class_getSuperclass ( Class cls );// 判断给定的Class是否是一个meta classBOOL class_isMetaClass ( Class cls );// 获取实例大小size_t class_getInstanceSize ( Class cls ); 属性(property)在Objective-C中，属性(property)和成员变量是不同的。那么，属性的本质是什么？它和成员变量之间有什么区别？简单来说属性是添加了存取方法的成员变量，也就是:1@property = ivar + getter + setter; 因此，我们每定义一个@property都会添加对应的ivar, getter和setter到类结构体objc_class中。具体来说，系统会在objc_ivar_list中添加一个成员变量的描述，然后在methodLists中分别添加setter和getter方法的描述。下面的objc_property_t是声明的属性的类型，是一个指向objc_property结构体的指针。 用法举例 123456789101112131415//遍历获取所有属性Property- (void) getAllProperty &#123;unsigned int propertyCount = 0;objc_property_t *propertyList = class_copyPropertyList([Person class], &amp;propertyCount);for (unsigned int i = 0; i &lt; propertyCount; i++ ) &#123;objc_property_t *thisProperty = propertyList[i];const char* propertyName = property_getName(*thisProperty);NSLog(@&quot;Person拥有的属性为: &apos;%s&apos;&quot;, propertyName);&#125;/** objc_property_t:/// An opaque type that represents an Objective-C declared property.typedef struct objc_property *objc_property_t;&#125; 另外，关于属性有一个objc_property_attribute_t结构体列表，objc_property_attribute_t结构体包含name和value，定义如下:1234typedef struct &#123;const char * _Nonnull name; /**&lt; The name of the attribute */const char * _Nonnull value; /**&lt; The value of the attribute (usually empty) */&#125; objc_property_attribute_t; 常用的属性如下： 属性类型 name值：T value：变化 编码类型 name值：C(copy) &amp;(strong) W(weak)空(assign) 等 value：无 非/原子性 name值：空(atomic) N(Nonatomic) value：无 变量名称 name值：V value：变化1234567891011@interface person : NSObjec&#123; NSString *_name; &#125; int main()&#123; objc_property_attribute_t nonatomic = &#123;&quot;N&quot;, &quot;&quot;&#125;; objc_property_attribute_t strong = &#123;&quot;&amp;&quot;, &quot;&quot;&#125;; objc_property_attribute_t type = &#123;&quot;T&quot;, &quot;@\\&quot;NSString\\&quot;&quot;&#125;; objc_property_attribute_t ivar = &#123;&quot;V&quot;, &quot;_name&quot;&#125;; objc_property_attribute_t attributes[] = &#123;nonatomic, strong, type, ivar&#125;; BOOL result = class_addProperty([person class], &quot;name&quot;, attributes, 4); &#125; 操作函数 12345678// 获取属性名const char * property_getName ( objc_property_t property );// 获取属性特性描述字符串const char * property_getAttributes ( objc_property_t property );// 获取属性中指定的特性char * property_copyAttributeValue ( objc_property_t property, const char *attributeName );// 获取属性的特性列表objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, unsigned int *outCount ); 成员变量(objc_ivar)Ivar: 实例变量类型，是一个指向objc_ivar结构体的指针 12/// An opaque type that represents an instance variable.typedef struct objc_ivar *Ivar; objc_ivar结构体的组成如下： 12345678- struct objc_ivar &#123;char * _Nullable ivar_name OBJC2_UNAVAILABLE;char * _Nullable ivar_type OBJC2_UNAVAILABLE;int ivar_offset OBJC2_UNAVAILABLE;#ifdef __LP64__int space OBJC2_UNAVAILABLE;#endif&#125; 这里我们注意第三个成员 ivar_offset。它表示基地址偏移字节。 操作函数 12345678910111213141516171819//成员变量操作函数// 修改类实例的实例变量的值Ivar object_setInstanceVariable ( id obj, const char *name, void *value );// 获取对象实例变量的值Ivar object_getInstanceVariable ( id obj, const char *name, void **outValue );// 返回指向给定对象分配的任何额外字节的指针void * object_getIndexedIvars ( id obj );// 返回对象中实例变量的值id object_getIvar ( id obj, Ivar ivar );// 设置对象中实例变量的值void object_setIvar ( id obj, Ivar ivar, id value );// 获取类成员变量的信息Ivar class_getClassVariable ( Class cls, const char *name );// 添加成员变量BOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types ); //这个只能够向在runtime时创建的类添加成员变量// 获取整个成员变量列表Ivar * class_copyIvarList ( Class cls, unsigned int *outCount ); //必须使用free()来释放这个数组. 成员变量列表(objc_ivar_list)在objc_class中，所有的成员变量、属性的信息是放在链表ivars中的。ivars是一个数组，数组中每个元素是指向Ivar(变量信息)的指针。 12345678struct objc_ivar_list &#123;int ivar_count OBJC2_UNAVAILABLE;#ifdef __LP64__int space OBJC2_UNAVAILABLE;#endif/* variable length structure */struct objc_ivar ivar_list[1] OBJC2_UNAVAILABLE;&#125; 例子，获取所有成员变量 123456789101112//遍历获取Person类所有的成员变量IvarList- (void) getAllIvarList &#123;unsigned int methodCount = 0;Ivar * ivars = class_copyIvarList([Person class], &amp;methodCount);for (unsigned int i = 0; i &lt; methodCount; i ++) &#123;Ivar ivar = ivars[i];const char * name = ivar_getName(ivar);const char * type = ivar_getTypeEncoding(ivar);NSLog(@&quot;Person拥有的成员变量的类型为%s，名字为 %s &quot;,type, name);&#125;free(ivars);&#125; Method(objc_method)objc_method 存储了方法名，方法类型和方法实现： 1234567891011runtime.h/// An opaque type that represents a method in a class definition.代表类定义中一个方法的不透明类型typedef struct objc_method *Method;struct objc_method &#123;SEL method_name;OBJC2_UNAVAILABLE;char *method_types; OBJC2_UNAVAILABLE;IMP method_imp; OBJC2_UNAVAILABLE;&#125; Method和我们平时理解的函数是一致的，就是表示能够独立完成一个功能的一段代码，比如： 1234- (void)logName&#123;NSLog(@&quot;name&quot;);&#125; 我们来看下objc_method这个结构体的内容： SEL method_name 方法名 char *method_types 方法类型，存储方法的参数类型和返回值类型 IMP method_imp 指向了方法的实现，本质是一个函数指针 简言之，Method = SEL + IMP + method_types，相当于在SEL和IMP之间建立了一个映射。 在这个结构体中，我们已经看到了SEL和IMP，说明SEL和IMP其实都是Method的属性。 操作函数 1234567891011121314151617181920212223242526// 调用指定方法的实现，返回的是方法实现时的返回，参数receiver不能为空，这个比method_getImplementation和method_getName快id method_invoke ( id receiver, Method m, ... );// 调用返回一个数据结构的方法的实现void method_invoke_stret ( id receiver, Method m, ... );// 获取方法名，希望获得方法明的C字符串，使用sel_getName(method_getName(method))SEL method_getName ( Method m );// 返回方法的实现IMP method_getImplementation ( Method m );// 获取描述方法参数和返回值类型的字符串const char * method_getTypeEncoding ( Method m );// 获取方法的返回值类型的字符串char * method_copyReturnType ( Method m );// 获取方法的指定位置参数的类型字符串char * method_copyArgumentType ( Method m, unsigned int index );// 通过引用返回方法的返回值类型字符串void method_getReturnType ( Method m, char *dst, size_t dst_len );// 返回方法的参数的个数unsigned int method_getNumberOfArguments ( Method m );// 通过引用返回方法指定位置参数的类型字符串void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );// 返回指定方法的方法描述结构体struct objc_method_description * method_getDescription ( Method m );// 设置方法的实现IMP method_setImplementation ( Method m, IMP imp );// 交换两个方法的实现void method_exchangeImplementations ( Method m1, Method m2 ); 方法列表(objc_method_list)方法调用是通过查询对象的isa指针所指向归属类中的methodLists来完成。 12345678910struct objc_method_list &#123;struct objc_method_list * _Nullable obsolete OBJC2_UNAVAILABLE;int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__int space OBJC2_UNAVAILABLE;#endif/* variable length structure */struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125; 操作函数 123456789101112131415161718192021// 添加方法BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types ); //和成员变量不同的是可以为类动态添加方法。如果有同名会返回NO，修改的话需要使用method_setImplementation// 获取实例方法Method class_getInstanceMethod ( Class cls, SEL name );// 获取类方法Method class_getClassMethod ( Class cls, SEL name );// 获取所有方法的数组Method * class_copyMethodList ( Class cls, unsigned int *outCount );// 替代方法的实现IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );// 返回方法的具体实现IMP class_getMethodImplementation ( Class cls, SEL name );IMP class_getMethodImplementation_stret ( Class cls, SEL name );// 类实例是否响应指定的selectorBOOL class_respondsToSelector ( Class cls, SEL sel ); SEL(objc_selector)123Objc.h/// An opaque type that represents a method selector.代表一个方法的不透明类型typedef struct objc_selector *SEL; objc_msgSend函数第二个参数类型为SEL，它是selector在Objective-C中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:1@property SEL selector; 可以看到selector是SEL的一个实例。 1A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded. 其实selector就是个映射到方法的C字符串，你可以用 Objective-C 编译器命令@selector()或者 Runtime 系统的sel_registerName函数来获得一个 SEL 类型的方法选择器。 selector既然是一个string，我觉得应该是类似className+method的组合，命名规则有两条： 同一个类，selector不能重复 不同的类，selector可以重复 这也带来了一个弊端，我们在写C代码的时候，经常会用到函数重载，就是函数名相同，参数不同，但是这在Objective-C中是行不通的，因为selector只记了method的name，没有参数，所以没法区分不同的method。 操作函数 12345678// 返回给定选择器指定的方法的名称const char * sel_getName ( SEL sel );// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器SEL sel_registerName ( const char *str );// 在Objective-C Runtime系统中注册一个方法SEL sel_getUid ( const char *str );// 比较两个选择器BOOL sel_isEqual ( SEL lhs, SEL rhs ); IMP123/// A pointer to the function of a method implementation. 指向一个方法实现的指针typedef id (*IMP)(id, SEL, ...); #endif 就是指向最终实现程序的内存地址的指针。 在iOS的Runtime中，Method通过selector和IMP两个属性，实现了快速查询方法及实现，相对提高了性能，又保持了灵活性。 类缓存(objc_cache)当Objective-C运行时通过跟踪它的isa指针检查对象时，它可以找到一个实现许多方法的对象。然而，你可能只调用它们的一小部分，并且每次查找时，搜索所有选择器的类分派表没有意义。所以类实现一个缓存，每当你搜索一个类分派表，并找到相应的选择器，它把它放入它的缓存。所以当objc_msgSend查找一个类的选择器，它首先搜索类缓存。这是基于这样的理论：如果你在类上调用一个消息，你可能以后再次调用该消息。 为了加速消息分发， 系统会对方法和对应的地址进行缓存，就放在上述的objc_cache，所以在实际运行中，大部分常用的方法都是会被缓存起来的，Runtime系统实际上非常快，接近直接执行内存地址的程序速度。 Category(objc_category)Category是表示一个指向分类的结构体的指针，其定义如下： 12345678struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods;struct protocol_list_t *protocols;struct property_list_t *instanceProperties;&#125;; name：是指 class_name 而不是 category_name。 cls：要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对 应到对应的类对象。 instanceMethods：category中所有给类添加的实例方法的列表。 classMethods：category中所有添加的类方法的列表。 protocols：category实现的所有协议的列表。 instanceProperties：表示Category里所有的properties，这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，不过这个和一般的实例变量是不一样的。 从上面的category_t的结构体中可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，不可以添加成员变量。 Runtime消息转发前文介绍了进行一次发送消息会在相关的类对象中搜索方法列表，如果找不到则会沿着继承树向上一直搜索知道继承树根部（通常为NSObject），如果还是找不到并且消息转发都失败了就回执行doesNotRecognizeSelector:方法报unrecognized selector错。那么消息转发到底是什么呢？接下来将会逐一介绍最后的三次机会。 动态方法解析 备用接收者 完整消息转发 动态方法解析首先，Objective-C运行时会调用 +resolveInstanceMethod:或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数并返回YES， 那运行时系统就会重新启动一次消息发送的过程。 实现一个动态方法解析的例子如下： 123456789101112131415161718- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.//执行foo函数[self performSelector:@selector(foo:)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;if (sel == @selector(foo:)) &#123;//如果是执行foo函数，就动态解析，指定新的IMPclass_addMethod([self class], sel, (IMP)fooMethod, &quot;v@:&quot;);return YES;&#125;return [super resolveInstanceMethod:sel];&#125;void fooMethod(id obj, SEL _cmd) &#123;NSLog(@&quot;Doing foo&quot;);//新的foo函数&#125; 打印结果：2018-04-01 12:23:35.952670+0800 ocram[87546:23235469] Doing foo 可以看到虽然没有实现foo:这个函数，但是我们通过class_addMethod动态添加fooMethod函数，并执行fooMethod这个函数的IMP。从打印结果看，成功实现了。如果resolve方法返回 NO ，运行时就会移到下一步：forwardingTargetForSelector。 备用接收者如果目标对象实现了-forwardingTargetForSelector:，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。 实现一个备用接收者的例子如下：1234567891011121314151617181920212223242526272829303132333435363738394041#import &quot;ViewController.h&quot;#import &quot;objc/runtime.h&quot;@interface Person: NSObject@end@implementation Person- (void)foo &#123;NSLog(@&quot;Doing foo&quot;);//Person的foo函数&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.//执行foo函数[self performSelector:@selector(foo)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;return YES;//返回YES，进入下一步转发&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123;if (aSelector == @selector(foo)) &#123;return [Person new];//返回Person对象，让Person对象接收这个消息&#125;return [super forwardingTargetForSelector:aSelector];&#125;@end 打印结果：2018-04-01 12:45:04.757929+0800 ocram[88023:23260346] Doing foo 可以看到我们通过forwardingTargetForSelector把当前ViewController的方法转发给了Person去执行了。打印结果也证明我们成功实现了转发。 完整消息转发如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil ，Runtime则会发出 -doesNotRecognizeSelector: 消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation 对象并发送 -forwardInvocation:消息给目标对象。 实现一个完整转发的例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#import &quot;ViewController.h&quot;#import &quot;objc/runtime.h&quot;@interface Person: NSObject@end@implementation Person- (void)foo &#123;NSLog(@&quot;Doing foo&quot;);//Person的foo函数&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.//执行foo函数[self performSelector:@selector(foo)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;return YES;//返回YES，进入下一步转发&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123;return nil;//返回nil，进入下一步转发&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;foo&quot;]) &#123;return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];//签名，进入forwardInvocation&#125;return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;SEL sel = anInvocation.selector;Person *p = [Person new];if([p respondsToSelector:sel]) &#123;[anInvocation invokeWithTarget:p];&#125;else &#123;[self doesNotRecognizeSelector:sel];&#125;&#125;@end 打印结果：2018-04-01 13:00:45.423385+0800 ocram[88353:23279961] Doing foo 从打印结果来看，我们实现了完整的转发。通过签名，Runtime生成了一个对象anInvocation，发送给了forwardInvocation，我们在forwardInvocation方法里面让Person对象去执行了foo函数。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"}]},{"title":"《计算机网络（第七版）》读书总结","slug":"《计算机网络（第七版）》读书总结","date":"2019-04-23T09:17:43.000Z","updated":"2019-05-16T07:53:02.000Z","comments":true,"path":"2019/04/23/《计算机网络（第七版）》读书总结/","link":"","permalink":"https://bigporo.github.io/2019/04/23/《计算机网络（第七版）》读书总结/","excerpt":"主要是摘录书中的重要概念。 概述 计算机网络(可简称为网络)把许多计算机连接在一起，而互连网则把许多网络连接在一起，是网络的网络。","text":"主要是摘录书中的重要概念。 概述 计算机网络(可简称为网络)把许多计算机连接在一起，而互连网则把许多网络连接在一起，是网络的网络。 以小写字母i开始的 internet(互连网)是通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议(即通信规则)可以是任意的。 以大写字母I开始的 Internet(互联网)是专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，并采用TCP/IP协议族作为通信规则，且其前身是美国的 ARPANET。 Internet的推荐译名是“因特网”，但很少被使用。 互联网现在采用存储转发的分组交换技术，以及三层ISP结构。 互联网按工作方式可划分为边缘部分与核心部分。主机在网络的边缘部分，其作用是进行信息处理。路由器在网络的核心部分，其作用是按存储转发方式进行分组交换。 计算机通信是计算机中的进程(即运行着的程序)之间的通信。计算机网络采用的通信方式是客户一服务器方式和对等连接方式(P2P方式)客户和服务器都是指通信中所涉及的应用进程。 客户是服务请求方，服务器是服务提供方。按作用范围的不同，计算机网络分为广域网WAN、城域网MAN、局域网LAN和个人区域网PAN。 计算机网络最常用的性能指标是:速率、带宽、吞吐量、时延(发送时延、传播延、处理时延、排队时延)、时延带宽积、往返时间和信道(或网络)利用率 网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构。 五层协议的体系结构由应用层、运输层、网络层(或网际层)、数据链路层和物理层组成。运输层最重要的协议是TCP和UDP协议，而网络层最重要的协议是IP协议。 物理层 物理层的主要任务就是确定与传输媒体的接口有关的一些特性，如机械特性、电气特性、功能特性和过程特性。 一个数据通信系统可划分为三大部分，即源系统、传输系统和目的系统。源系统包括源点(或源站、信源)和发送器，目的系统包括接收器和终点(或目的站，或信宿)。 通信的目的是传送消息。如话音、文字、图像、视频等都是消息。数据是运送消息的实体。信号则是数据的电气或电磁的表现。 根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号(或连续信号)和数字信号(或离散信号)。代表数字信号不同离散数值的基本波形称为码元。根据双方信息交互的方式，通信可以划分为单向通信(或单工通信)、双向交替通信(或半双工通信)和双向同时通信(或全双工通信)。 来自信源的信号叫做基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅、调频和调相。还有更复杂的调制方法，如正交振幅调制。 要提高数据在信道上的传输速率，可以使用更好的传输媒体，或使用先进的调制技型传输媒体(无线或红外或大气激光)。但数据传输速率不可能被任意地提高。 传输媒体可分为两大类，即导引型传输媒体(双绞线、同轴电缆或光纤)和非导引型传输媒体(无线或红外或大气激光)。 常用的信道复用技术有频分复用、时分复用、统计时分复用、码分复用和波分复用（光的频分复用）。 最初在数字传输系统中使用的传输标准是脉冲编码调制PCM。现在高速的数字传输系统使用同步光纤网 SONET(美国标准)或同步数字系列SDH(国际标准)。 用户到互联网的宽带接入方法有非对称数字用户线ADSL(用数字技术对现有的模拟电话用户线进行改造)、光纤同轴混合网HFC(在有线电视网的基础上开发的)和FTTx(即光纤到户)。 为了有效地利用光纤资源，在光纤干线和用户之间广泛使用无源光网络PON。无源光网络无须配备电源，其长期运营成本和管理成本都很低。最流行的无源光网经是以太网无源光网络EPON和吉比特无源光网络GPON。 数据链路层 链路是从一个结点到相部结点的一段物理线路，数据链路则是在链路的基础上增加了一些必要的硬件(如网络适配器)和软件(如协议的实现)。 数据链路层使用的信道主要有点对点信道和广播信道两种。数据链路层传送的协议数据单元是帧。数据链路层的三个基本问题则是:封装成帧、透明传输和差错检测。 循环冗余检验CRC是一种检错方法，而检验序列FCS是添加在数据后面的冗余码。 点对点协议PPP是数据链路层使用最多的一种协议，它的特点是:简单；只检测差错，而不是纠正差错:不使用序号，也不进行流量控制:可同时支持多种网络层协议。 PPPOE是为宽带上网的主机使用的链路层协议。 局域网的优点是:具有广播功能，从一个站点可很方便地访问全网:便于系统的扩展和逐渐演变；提高了系统的可靠性、可用性和生存性。 共享通信媒体资源的方法有二:一是静态划分信道(各种复用技术)，二是动态媒体接入控制，又称为多点接入(随机接入或受控接入)。 IEE802委员会曾把局域网的数据链路层拆成两个子层，即逻辑链路控制(LC)子层(与传输媒体无关)和媒体接入控制MAC)子层(与传输媒体有关)。但现在LC子层已成为历史。 计算机与处界局域网的通信要通过通信适配器(或网络适配器)，它又称为网络接口卡或网卡，主要功能是进行数据串行传输和并行传输的转换。计算机的硬件地址就在适配器ROM中。 以太网采用无连接的工作方式，对发送的数据不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢弃，其他什么也不做。 以太网采用的协议是具有冲突检测的載波监听多点接入 CSMA/CD。协议的要点是:发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。因此，每一个站在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。以太网上各站点都平等地争用以太网信道。 传统的总线以太网基本上都是使用集线器的双绞线以太网。这种以太网在物理上是星形网，但在逻辑上则是总线形网。集线器工作在物理层，它的每个接口仅仅简单地转发比特不进行碰撞检测。 以太网的硬件地址，即MAC地址事实上就是适配器地址或适配器标识符，与主机所在的地点无关。源地址和目的地址都是48位长。 以太网的适配器有过滤功能，它只接收单播帧、广播帧或多播帧。 使用集线器可以在物理层扩展以太网(扩展后的以太网仍然是一个网络)。 交换式集线器常称为以太网交換机或第二层交换机(工作在数据链路它就是个多接口的网桥），而每个接口都直接与某台单主机或另一个集线器相连，且工作在全双工方式。 以太网交换机其实就是个多接口的网桥，能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，无碰撞地传输数据。 高速以太网有100Mits的快速以太网、吉比特以太网和10 Gbit/s的10吉比特以太网。最近还发展到100吉比特以太网。在宽带接入技术中，也常使用高速以太网进行接入。 网络层 TCP/IP体系中的网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组可能出错、丢失、重复和失序。进程之间通信的可靠性由运输层负责。 IP网是虚拟的，因为从网络层上看，IP网就是一个统一的、抽象的网络(实际上是异构的)。IP层抽象的互联网屏蔽了下层网络很复杂的细节，使我们能够使用统一的、抽象的IP地址处理主机之间的通信问题。 在互联网上的交付有两种:在本网络上的直接交付(不经过路由器)和到其他网络的间接交付(经过至少一个路由器，但最后一次一定是直接交付)。 一个IP地址在整个互联网范围内是唯一的。分类的IP地址包括A类、B类和C类地址(单播地址)，以及D类地址(多播地址)。E类地址未使用。 分类的IP地址由网络号字段(指明网络)和主机号字段(指明主机)组成。网络号字段最前面的类别位指明IP地址的类别。 IP地址是一种分等级的地址结构。IP地址管理机构在分配IP地址时只分配网络号，而主机号则由得到该网络号的单位自行分配。路由器仅根据目的主机所连接的网络号来转发分组。 IP地址标志一台主机(或路由器)和一条链路的接口。多归属主机同时连接到两个或更多的网络上。这样的主机同时具有两个或更多的IP地址，其网络号必须不同的。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有2个不同的IP地址。 按照互联网的观点，用转发器或网桥连接起来的若干个局域网仍为一个网络。所分配到网络号的网络(不管是范围很小的局域网，还是可能覆盖很大地理范围的域网)都是平等的。 物理地址(即硬件地址)是数据链路层和物理层使用的地址，而P地址是网络和以上各层使用的地址，是一种逻辑地址(用软件实现的)，在数据路层看不见数据报的IP地址。 IP数据报分为首部和数据两部分。首部的前一部分是固定长度，共20字节，是所有IP数据报必须具有的(源地址、目的地址、总长度等重要字段部在定首部中)。一些长度可变的可选字段放在固定首部的后面。 IP首部中的生存时间字段给出了IP数据报在互联网中所能经过的最大路由器数，可防止IP数据报在互联网中无限制地兜圈子。 地址解析协议ARP把IP地址解析为硬件地址，它解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。ARP的高速缓存可以大大减少网络上的通信量。 在互联网中，我们无法仅根据硬件地址寻找到在某个网络上的某台主机。因此，从IP地址到硬件地址的解析是非常必要的。 无分类域间路由选择CIDR是解決目前IP地址紧缺的一个好方法。CIDR记法把IP地址后面加上斜线”/“，然后写上前缀所占的位数。前(或网络前级)用来指 明网络，前缀后面的部分是后缀，用来指明主机。CIDR把前绶都相同的连续的IP地址组成一个“CIDR地址块”。IP地址的分配都以CIDR地址块为单位。 CIDR的32位地址掩码(或子网掩码)由一串1和一串0组成，而1的个数就是前缀的长度。只要把IP地址和地址掩码逐位进行“逻辑与(AND)”运算，就很容易得出网络地址A类地址的默认地址掩码是25500。B类地址的默认地址码是255250.0。C类地址的默认地址掩码是255.2552550. 路由聚合(把许多前缀相同的地址用一个来代替)有利于减少路由表中的项目，减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。 “转发”和“路由选择”有区别。“转发”是单个路由器的动作。“路由选择”是许 多由置共同鼓作的过程，这些路由器相立交换信息，目的是生成路由表，再从路由表导出转发表。若采用自适应路由选择算法，则当网络拓扑变化时，路由表和转发表都能够自动更新。在许多情况下，可以不考虑转发表和路由表的区别，而都使用路由表这一名词。 自治系统(AS)就是在单一的技术管理下的一组路由器。一个自治系统对其他它自治系统表现出的是一个单一的和一致的路由选择策略。 路由选择协议有两大类:内部网关协议(或自治系统内部的路由选择协议)，如RIP和OSP；外部网关协议(或自治系统之间的路由选择协议)，如BGP-4。 RIP是分布式的基于距离向量的路由选择协议，只适用于小型互联网。RIP按固定的时间间隔与相邻路由器交换信息。交换的信息是自己当前的路由表，即到达本自治系统中所有网络的(最短)距离，以及到每个网络应经过的下一跳路由器。 OSPF是分布式的链路状态协议，适用于大型互联网。OSPF只在链路状态发生 化时，才向本自治系统中的所有路由器，用洪泛法发送与本路由器相邻的所有路由器的链路状态信息。“链路状态”指明本路由器都和哪些路由器相邻，以及该链路的“度量”。“度量”可表示费用、距离、时延、带宽等，可统称为“代价”。所有的路由器最终都能建立一个全网的拓扑结构图。 BGP4是不同AS的路由器之间交换路由信息的协议，是一种路径向量路由选择协议。BGP力求寻找一条能够到达目的网络(可达)且比较好的路由(不兜圈子)，而并非要寻找一条最佳路由。 网际控制报文协议ICMP是IP层的协议。ICMP报文作为IP数据报的数据，加上首部后组成IP数据报发送出去。使用ICMP并非为了实现可靠传输。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP报文的种类有两种，即ICMP差错报告报文和ICMP询问报文。 ICMP的一个重要应用就是分组网间探测PING，用来测试两台主机之间的连通性。PING使用了ICMP回送请求与回送回答报文。 要解决IP地址耗尽的问题，最根本的办法就是采用具有更大地址空间的新版本的IP协议，即IPv6。 IPV6所带来的主要变化是:(1)更大的地址空间(采用128位的地址):(2)灵活的首部格式:(3)改进的选项:(4)支持即插即用:(5)支持资源的预分配:(6)IPv6的首部改为8字节对齐。 IPv6数据报在基本首部的后面允许有零个或多个扩展首部，再后面是数据。所有的扩展首部和数据合起来叫做数据报的有效载荷或净负荷。 IPv6数据报的目的地址可以是以下三种基本类型地址之一:单播、多播和任播。 IPv6的地址使用冒号十六进制记法。 向IPV6过渡只能采用逐步演进的办法，必须使新安装的IPv6系统能够向后兼容向IPw6过渡可以使用双协议栈或使用隧道技术。 与单播相比，在一对多的通信中，IP多播可大大节约网络资源。IP多播使用D类IP地址。IP多播需要使用网际组管理协议IGMP和多播路由选择协议。 虚拟专用网VPN利用公用的互联网作为本机构各专用网之间的通信载体。VPN内部使用互联网的专用地址。ー个VPN至少要有一个路由器具有合法的全球IP地址，这样オ能和本系统的另ー个VPN通过互联网进行通信。所有通过互联网传送的数据都必须加密。 使用网络地址转换NAT技术，可以在专用网络内部使用专用IP地址，而仅在连接到互联网的路由器使用全球P地址。这样就大大节约了宝贵的IP地址。 MPLS的特点:(1)支持面向连接的服务质量；(2)支持流量工程，平衡网络负载:(3)有效地支持虚拟专用网VPN。 MPLS在入口结点给每一个IP数据报打上固定长度的“标记”，然后根据标记在第二层(链路层)用硬件进行转发(在标记交换路由器中进行标记对换)，因而转发速率大大加快。 运输层 运输层提供应用进程间的逻辑通信，也就是说，运输层之间的通信并不是真正在两 个运输层之间直接传送数据。运输层向应用层屏蔽了下面网络的细节(如网络拓扑、所采用的路由选择协议等)，它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。 网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。 运输层有两个主要的协议:TCP和UDP。它们都有复用和分用，以及检错的功能。当运输层采用面向连接的TCP协议时，尽管下面的网络是不可靠的(只提供尽最大努力服务)，但这种逻辑通信信道就相当于一条全双工通信的可靠信道。当运输层采用无连接的UDP协议时，这种逻辑通信信道仍然是一条不可靠信道。 运输层用一个16位端口号来标志一个端口。端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。 两台计算机中的进程要互相通信，不仅要知道对方的IP地址(为了找到对方的计算机)，而且还要知道对方的端口号(为了找到对方计算机中的应用进程)。 运输层的端口号分为服务器端使用的端口号(0~1023指派给熟知端口，1024~49151是登记端口号)和客户端暫时使用的端口号(49152~65535)。 UDP的主要特点是:(1)无连接:(2)尽最大努力交付:(3)面向报文；(4)无拥塞控制:(5)支持一对对多、多对一和多对多的交互通信；(6)首部开销小(只有四个字段:源端口、目的端口、长度、检验和) TCP的主要特点是:(1)面向连接；(2)每一条TCP连接只能是点对点的(一对一):(3)提供可靠交付的服务:(4)提供全双工通信:(5)面向字节流。 TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点。这样的端点就叫做套接字( socket)或插口。套接字用(IP地址:端口号)来表示。 停止等待协议能够在不可靠的传输网络上实现可靠的通信。每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。分组需要进行编号。 超时重传是指只要超过了一段时间仍然没有收到确认，就重传前面发送过的分组(认为刚オ发送的分组丢失了)。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。 连续ARQ协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都己正确收到了。 TCP报文段首部的前20个字节是固定的，后面有4N字节是根据需要而增加的选项(N是整数)。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号。 TCP首部中的确认号是期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则表明:到序号N-1为止的所有数据都已正确收到。 TCP首部中的窗口字段指出了现在允许对方发送的数据量。窗口值是经常在动态变化着的。 TCP使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到了确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动(没有收到新的确认)和前移(收到了新的确认) 发送窗口前沿通常是不断向前移动的。 流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做拥塞。拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。 流量控制是一个端到端的问题，是接收端抑制发送端发送数据的速率，以便使接收端来得及接收。拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 为了进行拥塞控制、TCP的发送方要推持一个拥塞窗口cwnd的状态变量。拥塞窗口的大小取決于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。 TCP的拥塞控制采用了四种算法，即慢开始、拥塞避免、快重传和快恢复。在网终层，也可以使路由器采用适当的分组丢弃策略(如主动队列管理AQM)，以减少网络拥塞的发生 运输连接有三个阶段，即:连接建立、数据传送和连接释放。 主动发起TCP连接建立的应用进程叫做客户，而被动等待连接建立的应用进程做眼务器。TCP的连接建立采用三报文握手机制。服务器要确认客户的连接请求，然后客户要对服务器的确认进行确认。 TCP的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发送连接释放的通知，待对方确认后就进入半关闭状态。当另一方也没有数据再发送时，则发送链接释放通知，对方确认后就完全关闭了TCP连接接释放的通知。 应用层 应用层协议是为了解决某一类应用问题，而问题的解决又是通过位于多个应用进程之间的通信和协同工作来完成的。应用层规定了应用进程在通信时所遵循的协议。 应用层的许多协议都是基于客户服务器方式的。客户是服务请求方，服务器是服务提供方。 域名系统DNS是互联网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址。DNS是一个联机分布式数据库系统，并采用客户服务器方式。 域名到IP地址的解析是由分布在互联网上的许多域名服务器程序(即域名服务器)共同完成的。 互联网采用层次树状结构的命名方法，任何一台连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。域名中的点和点分十进制IP地址中的点没有关系。 域名服务器分为根域名服务器、顶级域名服务器、权限域名服务器和本地域名服务器。 文件传送协议FTP使用TCP可靠的运输服务。FTP使用客户服务器方式。一个FTP服务器进程可同时为多个客户进程提供服务。在进行文件传输时，FTP 的客户和服务器之间要建立两个并行的TCP连接:控制连接和数据连接。实际用于传输文件的是数据连接。 万维网www是一个大规模的、联机式的信息储藏所，可以非常方便地从互联网上的一个站点链接到另一个站点。 万维网的客户程序向互联网中的服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。 在客户程序上显示出的万维网文档称为页面。 万维网使用统资源定位符URL来标志万维网上的各种文档，并使每一个文档在整个互联网的范围内具有唯一的标识符URL。 万维网客户程序与服务器程序之间进行交互所使用的协议是超文本传送协议HTTP。HTTP使用TCP连接进行可靠的传送。但HTTP协议本身是无连接、无状态的。HTTP/1.1 协议使用了持续连接(分为非流水线方式和流水线方式)。 万维网使用超文本标记语言HTML来显示各种万维网页面。 万维网静态文档是指在文档创作完毕后就存放在万维网服务器中，在被用户浏览的才由应用程序动态创建的。过程中，内容不会改变。动态文档是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建的。 活动文档技术可以使浏览器屏幕连续更新。活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。 在万维网中用来进行搜索的工具叫做搜索引擎。搜索引擎大体上可划分为全文检索搜索引擎和分类目录搜索引擎两大类。 电子邮件是互联网上使用最多的和最受用户欢迎的一种应用。电子邮件把邮件发到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自 送己使用的邮件服务器进行读取，相当于“电子信箱”。 这个电子邮件系统有三个主要组成构件即用户代理、邮件服务器，以及邮件协议(包括邮件发送协议，如SMTP，和邮件读取协议，如PPOP3和IMAP)。用户代理和邮件服务器都要运行这些协议。 电子邮件的用户代理就是用户与电子邮件系统的接口，它向用户提供一个很友好的视窗界面来发送和接收邮件。 从用户代理把邮件传送到邮件服务器，一级在邮件服务器之间的传送，都要使用SMTP协议。但用户代理从邮件服务器读取邮件时，则要使用POP3（或IMAP）协议。 基于万维网的电子邮件使用户能够利用浏览器收发电子邮件。用户浏 浏览器和邮件服务器之间的邮件传送使用HTTP协议，而在邮 件服务器之间邮件的传送仍然使用SMTP协议。 简单网络管理协议SNMP由三部分组成，即(1)SNMP本身，负责读取和改变各代理中的对象名及其状态数值: (2)管理信息结构SMI，定义命名对象和定义对象类型(包括范围和长度)的通用规则，以及把对象和对象的值进行编码的基本编码规则BER； (3) 管理信息库MIB，在被管理的实体中创建了命名对象，并规定了其类型。 系统调用接口是应用进程的控制权和操作系统的控制权进行转换的一个接口，又称为应用编程接口API。API 就是应用程序和操作系统之间的接口。 套接字是应用进程和运输层协议之间的接口，是应用进程为了获得网络通信服务而与操作系统进行交互时使用的一种机制。 目前P2P工作方式下的文件共享在互联网流量中已占据最大的份额，比万维网应用所占的比例大得多。 BT是很流行的种P2P应用。BT采用“是稀有的优先”的技术，可以尽早把取稀有的文件块收集到。此外，凡有当前以最高数据率向某个对等方传送文件块的相邻对等方，该对等方就优先把所请求的文件块传送给这些相邻对等方。这样做的结果是，这些对等方相互之间都能够以令人满意的速率交换文件块。 当对等方的数量很大时，采用P2P方式下载大文件，要比传统的客户-服务器方式快得多。 在P2P应用中，广泛使用的索引和查找技术是分布式散列表DHT。 网络安全 计算机网络上的通信面临的威胁可分为两大类， 即被动攻击(如截获)和主动攻击 (如中断、算改、伪造)。主动攻击的类型有更改报文流、拒绝服务、伪造初始 化、恶意程序(病毒、蠕虫、木马、逻辑炸弹、后门入侵、流氓软件)等。 计算机网络安全主要有以下一些内容:保密性、安全协议的设计和访问控制。 密码编码学是密码体制的设计学，而密码分析学则是在未知密钥的情况下从密文推演出明文或密钥的技术。密码编码学与密码分析学合起来即为密码学。 如果不论截取者获得了多少密文，都无法唯一地确定出对应的明文，则这一密码体制称为无条件安全的(或理论上是不可破的)。在无任何限制的条件下，目前几乎所有实用的密码体制均是可破的。如果一个密码体制中的密码不能在一定时间内被可以使用的计算资源破译，则这密码体制称为在计算上是安全的。 对称密钥密码体制是加密密钥与解密密钥相同的密码体制(如数据加密标准DES和高级加密标准AES)。这种加密的保密性仅取决于对密钥的保密，而算法是公开的。 公钥密码体制(又称为公开密钥密码体制)使用不同的加密密钥与解密密钥。加密算法和解密算法也都是公开的。加密密钥(即公钥)是向公众公开的，而解密密钥(即私钥或秘钥)则是需要保密的。 目前最著名的公钥密码体制是RSA体制，它是基于数论中的大数分解问题的体制。任何加密方法的安全性取决于密钥的长度，以及攻破密文所需的计算量，而不是简单地取决于加密的体制(公钥密码体制或传统加密体制)。 数字签名必须保证能够实现以三点功能(1)报文鉴别，即接收者能够核实发送者对报文的签名(2)报文的完整性，即接收者确信所收到的数据完全和发送者发送的完全一样而没有被篡改过；(3)不可否认，即发送者事后不能抵赖对报文的签名。 鉴别是要验证通信的对方的确是自己所要通信的对象，而不是其他的冒充者。鉴别与授权是不同的概念。 密钥管理包括:密钥的产生、分配、注入、验证和使用。密钥分配(或密钥分发)是密钥管理中最大的问题。密钥必须通过最安全的通路进行分配。目前常用的密钥分配方式是设立密钥分配中心KDC。 认证中心CA是一个值得信赖的机构，用来将公钥与其对应的实体(人或机器)进行绑定。每个实体都有CA发来的证书，里面有公钥及其拥有者的标识信息(人名或IP地址)。此证书被CA进行了数字签名。任何用户都可从可信的地方获得认证中心CA的公钥。 在网络层可使用IPsec协议族，IPsec包括鉴别首部协议AH和封装安全有效载荷协议ESP。AH协议提供源点鉴别和数据完整性，但不能保密。而ESP协议提供源点鉴别、数据完整性和保密。IPsec 支持IPv4和IPV6。在IPv6中，AH和ESP都是扩展首部的一部分。IPsee 数据报的工作方式有运输方式和隧道方式两种。 运输层的安全协议有SSL (安全套接字层)和TLS (运输层安全)。SSL最新的版本是SSL 3.0， 它是保护万维网HTTP通信量所公认的事实上的标准。SSL不仅被所有常用的浏览器和万维网服务器所支持，而且也是TLS的基础。 PGP是一个完整的电子邮件安全软件包，包括加密、鉴别、电子签名和压缩等技术。PGP并没有使用什么新的概念，它只是把现有的一些加密算法(如RSA公钥加密算法或MDS报文摘要算法)综合在一起而已。 防火墙是种特殊编程的路由器，安装在一个网点和网络的其余部分之间，目的是实施访问控制策略。防火墙里面的网络称为“可信的网络”，而把防火墙外面的网络称为“不可信的网络”。防火墙的功能有两个:一个是阻止(主要的)，另一个是允许。 防火墙技术分为:网络级防火墙，用来防止整个网络出现外来非法的入侵(属于这类的有分组过滤和授权服务器)；应用级防火墙，用来进行访问控制(用应用网关或代理服务器来区分各种应用)。 入侵检测系统IDS是在入侵已经开始，但还没有造成危害或在造成更大危害前，及时检测到入侵，以便尽快阻止入侵，把危害降低到最小。 网络上的音视频服务 多媒体信息有两个重要特点:(1)多媒体信息的信息量往往很大1(2)在传输多媒体数据时，对时延和时延抖动均有较高的要求。在互联网上传输多媒体数据时，我们都是指含有“边传输、边播放”的特点。 由多媒体信息构成的分组在发送时是等时的。这些分组在到达接收端时就变成为非等时的。当接收端存中的分组数达到一定的数量后，再以恒定速率按顺序将这些分组进行还原播放。这样就产生了播放时延，同时也可以在很大程度上消除时延的抖动。 在传送时延敏感的实时数据时，传输时延和时延抖动都必须受到限。通常宁可丢失少量分组，也不要接收太晚到达的分组。 目前互联网提供的音频视频服务有三种类型:(1)流式存储音频视频，用户通过互联网边下载、边播放。(2)流式实况音/视频，其特点是在发送方边录例、边发送，在接收时也是要求能够述续播放。(3)交互式音频视频，如互联网电话或互联网电视会议。 流媒体( streaming media)就是流式音频/视频，其特点是边下载、边播放，但不能存储在硬盘上成为用户的文件。 媒体服务器(或称为流式服务器)可以更好地支持流式音频和视频的传送。TCP能够保证流式音频/视频文件的播放质量，但开始播放的时间要比请求播放的时间滞后一些(必须先在缓存中存储一定数量的分组)。对于实时流式音频视频文件的传送则应当选用UDP。 实时流式协议RTSP是为了给流式过程增加更多功能而设计的协议。RTSP本身并不传送数据，而仅仅是使媒体放器能够控制多媒体流的传送。RTSP又称为“互联网录像机遥控协议” 。 狭义的IP电话是指在IP网络上打电话。广义的IP电话则不仅是电话通信，而且还可以在IP网络上进行交互式多媒体实时通信(包括话音、视像等),甚至还包括即时传信IM(如QQ和ssyp等)。 IP电话的通话质量主要由两个因素决定:(1)通话双方端到端的时延和时延抖动；(2)话音分组的丢失率。但这两个因素都是不确定的，而是取决于当时网络上的通信量。 实时运输协议RTP为实时应用提供端到端的运输，但不提供任何服务质量的保证。需要发送的多媒体数据块(音频/视频)经过压缩编码处理后，先送给RTP封装成为RTP分组，装入运输层的UDP用户数据报后，再向下递交给IP层。可以把RTP看成是在UDP之上的一个运输层子层的协议。 实时运输控制协议RTCP是与RTP配合使用的协议。RTCP协议的主要功能是:服务质量的监视与反馈，媒体间的同步，以及多播组中成员的标志。RTCP分组也使用UDP来传送，但RTCP并不对音频视频分组进行封装。 现在IP电话有两套信令标准。一套是ITU-T定义的H323协议，另一套是ETF提出的会话发起协议SIP。 H323不是一个单独的协议而是一组协议。H323包括系统和构件的描述、呼叫模型的描述、呼叫信令过程、控制报文、复用、话音编解码器、视像编解码器，以及数据协议等。H323标准的四个构件是:(1)H323终端:(2)网关；(3)网间(4)多点控制单元MCU . 会话发起协议SIP只涉及到P电话所需的信令和有关服务质量的间题。SIP使用文本方式的客户服务器协议。SP系统只有两种构件，即用户代理(包括用户代理客户和用户代理服务器)和网络服务器(包括代理服务器和重定向服务器)。SIP的地址十分灵活，它可以是电话号码，也可以是电子邮件地址、IP地址或其他类型的地址。 服务质量QoS是服务性能的总效果，此效果决定了一个用户对服务的满意程度。因此，有服务质量的服务就是能够满足用户的应用需求的服务。或者说，可提供致的、可预计的数据交付服务。 服务质量可用若干基本的性能指标来描述，包括可用性、差错率、响应时间、吞吐量、分组丢失率、连接建立时间、故障检测和改正时间等。服务提供者可向其用户保证某一种等级的服务质量。 为了使互联网具有一定的服务质量，可采取以下一些措施:(1)分类，如区分服务；(2)管制；(3)调度；(4)呼叫接纳；(5)加权公平排队等。 综合服务 Intserv可对单个的应用会话提供服务质量的保证，它定义了两类服务，即有保证的服务和受控负載的服务。Intserv共有以下四个组成部分，即(1)资源预留协议RSVP；(2)接纳控制；(3)分类器；(4)调度器。 区分服务 Diffserv在路由器中增加区分服务的功能，把IP协议中原有的服务类型字段重新定义为区分服务DS，利用DS字段的不同数值提供不同等级的服务质量。Diffserv将所有的复杂性放在DS域的边界结点中，而使DS域内部路由器工作得尽可能地简单。Diffserv定义了在转发分组时体现服务水平的每跳行为PHB，包括EF和AF，即迅速转发PHB和确保转发PHB。 无线网络和移动网络 无线局域网可分为两大类。第一类是有固定基础设施的，第二类是无固定基础设施的 无线局域网的标准是IE的802.11系列。使用802.11系列协议的局域网又称为Wi-Fi。 802.11无线以太网标准使用星形拓扑，其中心叫做接入点AP，它就是基本服务集内的基站。 应当弄清几种不同的接入:固定接入、移动接入、便携接入和游牧接入。 802.11无线以太网在MAC层使用CSMA/CA协议。不能使用CSMA/CD的原因是:在无线局域网中，并非所有的站点都能够听见对方(例如，当有障碍物出现在站点之间时)，因此无法实现碰撞检测。使用 CSMA/CA协议是为了尽量减小碰撞发生的概率。 802.11无线局域网在使用 CSMA/CA的同时，还使用停止等待协议。 8021标准规定，所有的站在完成发送后，必须再等待一段帧间间隔时间才能发送下一帧。帧间间隔的长短取决于该站要发送的帧的优先级。 在802.11无线局域网的MAC帧首部中有一个持续期字段，用来填入在本帧结束后还要占用信道多少时间(以微秒为单位)。 802.11标准允许要发送数据的站对信道进行预约，即在发送数据帧之前先发送RTS帧请求发送。在收到响应允许发送的CTS帧后，就可发送数据帧。 802.1的MAC帧共有三种类型，即控制帧、数据帧和管理帧。需要注意的是，地址字段，即源地址、目的地址和AP地址。MAC帧有四个地址字段。在有固定基础设施的无线局域网中，只使用其中的三个 几种无线网络简介:无线个人区域网(蓝牙系统、 Zigbee和超高速WPAN)。无线城域网 WIMAX。 当计算机移动到外地时，移动IP技术允许该计算机仍然保留其原来的IP地址。移动IP使用了一些新概念，如永久地址、归属地址、归属网络、被访网络或外地网络、归属代理、外地代理、转交地址、同址转交地址等。 移动IP使用了几种协议，如移动站到外地代理的协议，外地代理到归属代理的登记协议，归属代理数据报封装协议，外地代理拆封协议等。 移动IP的路由选择有间接路由选择和直接路由选择，后者需要使用通信者代理和锚外地代理。 蜂窝移动通信网中对移动用户的路由选择需要弄清一些概念:归属位置寄存器HLR和来访用户位置寄存器VLR，移动站漫游号码MSRN，归属网络交换中心，归属MSC，锚MSC，被访网络的MSC。","categories":[{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/categories/读书/"}],"tags":[{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/tags/读书/"},{"name":"基本功","slug":"基本功","permalink":"https://bigporo.github.io/tags/基本功/"}]}]}