{"meta":{"title":"iDog的精神时光屋","subtitle":null,"description":"一个记录工作和生活的小地方。","author":"iDog","url":"https://bigporo.github.io","root":"/"},"pages":[{"title":"","date":"2019-04-19T08:35:22.380Z","updated":"2019-04-19T08:35:22.380Z","comments":true,"path":"404.html","permalink":"https://bigporo.github.io/404.html","excerpt":"","text":"var QZONE = window.QZONE || {}; function imagezoom(imgobj, box_w, box_h) { var src_w = imgobj.width; var src_h = imgobj.height; var r1 = src_w / src_h, r2 = box_w / box_h; var dst_w, dst_h; if (r1 > r2) { dst_w = box_w; dst_h = Math.round(dst_w / src_w * src_h); } else { if (r1 < r2) { dst_h = box_h; dst_w = Math.round(dst_h / src_h * src_w); } else { dst_w = box_w; dst_h = box_h; } } imgobj.style.marginLeft = (box_w - dst_w) / 2 + \"px\"; imgobj.style.marginTop = (box_h - dst_h) / 2 + \"px\"; imgobj.style.width = dst_w + \"px\"; imgobj.style.height = dst_h + \"px\"; imgobj.style.opacity = 1; } (function(_w, _d) { var ha = _d.head || _d.getElementsByTagName(\"head\")[0]; var $scope = {}; var current; var tmnow; var chId; var homePageUrl, homePageName; var scs = document.getElementsByTagName(\"script\"); if (location.href.indexOf(\"fm.qq.com\") > -1 || location.href.indexOf(\"fm.qzone.qq.com\") > -1) { homePageName = \"\\u8fd4\\u56de\\u4f01\\u9e45FM\"; homePageUrl = \"http://fm.qq.com\"; } else { if (location.href.indexOf(\"qzone.qq.com\") > -1) { homePageName = \"\\u8fd4\\u56de\\u6211\\u7684\\u7a7a\\u95f4\"; homePageUrl = \"http://qzone.qq.com\"; } else { homePageName = \"\\u8fd4\\u56de\\u817e\\u8baf\\u7f51\"; homePageUrl = \"http://www.qq.com\"; } } for (var i = 0;i < scs.length;i++) { if (scs[i].src.indexOf(\"404/search_children.js\") > -1) { if (scs[i].getAttribute(\"homePageUrl\")) { homePageUrl = scs[i].getAttribute(\"homePageUrl\"); } if (scs[i].getAttribute(\"homePageName\")) { homePageName = scs[i].getAttribute(\"homePageName\"); } break; } } $scope.rettext = homePageName; $scope.retlink = homePageUrl; function getData(srcUrl, callback) { var sc = _d.createElement(\"script\"); function orc() { if (sc.readyState === \"loaded\") { setTimeout(function() { callback && callback(); }, 0); } } if (sc.addEventListener) { if (callback) { sc.addEventListener(\"load\", callback, false); } } else { sc.attachEvent(\"onreadystatechange\", orc); } ha && ha.appendChild(sc); sc.src = srcUrl; } function resolveData(d) { var tid, len, ddata = [], tdata; if (\"object\" == typeof d && (d.data && (len = d.data.length))) { for (var i = 0;i < len;i++) { var expire = d.data[i].expire; d.data[i]._id = new Date * Math.random() * Math.random() * 1E7; if (expire && tmnow * 1E3 < Date.parse(expire.replace(/\\s[\\s\\S]*$/, \"\").replace(/\\-/g, \"/\"))) { var _c = d.data[i].city, _p = d.data[i].province; if (_c && city) { if ((\"_\" + _c + \"_\").indexOf(\"_\" + city + \"_\") > -1) { ddata.push(d.data[i]); continue; } } if (_p && province) { if ((\"_\" + _p + \"_\").indexOf(\"_\" + province + \"_\") > -1) { ddata.push(d.data[i]); } } } } tid = Math.floor(Math.random() * (ddata.length || len)); tdata = (ddata.length ? ddata : d.data)[chId = tid]; if (_w.foundjsondata) { tdata.ta = tdata.sex.indexOf(\"\\u5973\") > -1 ? \"\\u5979\" : \"\\u4ed6\"; tdata.name = \"\\u201c7\\u00b718\\u7279\\u5927\\u62d0\\u5356\\u5a74\\u513f\\u6848\\u201d\\u544a\\u7834\\uff0c\\u88ab\\u89e3\\u6551\\u768415\\u540d\\u5b69\\u5b50\\u4e2d\\uff0c2\\u4eba\\u7531\\u4eb2\\u751f\\u7236\\u6bcd\\u9886\\u56de\\uff0c\\u4ecd\\u670913\\u540d\\u5b69\\u5b50\\u672a\\u627e\\u5230\\u4eb2\\u751f\\u7236\\u6bcd\\uff0c\\u88ab\\u5b89\\u7f6e\\u5728\\u60e0\\u5dde\\u5e02\\u793e\\u4f1a\\u798f\\u5229\\u9662\\uff0c\" + tdata.ta + \"\\u662f\\u5176\\u4e2d\\u4e4b\\u4e00\\u3002\"; tdata.url = tdata.url.replace(/#p=(\\d{1,2})/, function(a, n) { return \"#p=\" + (+n + 1); }); return format(tmpl2, tdata); } if (!tdata.ext1) { tdata.ext1 = \"\\u4f46\\u6211\\u4eec\\u53ef\\u4ee5\\u4e00\\u8d77\\u5bfb\\u627e\\u5931\\u8e2a\\u5b9d\\u8d1d\"; } return tdata; } } function setTopData(tdata) { current = tdata; $scope.topname = tdata.name; $scope.topgender = tdata.sex; $scope.topbirth = tdata.birth_time; $scope.toplostdate = tdata.lost_time; $scope.toplostplace = tdata.lost_place; $scope.toplostdesc = tdata.child_feature; $scope.toplink = tdata.url; $scope.topimg = tdata.child_pic; $scope.topid = tdata._id; document.body.innerHTML = template(\"body\", $scope); } function init(data) { tmnow = data.tm_now * 1E3; var tdata = resolveData(jsondata); $scope.whichin = 0; jsondata.data.splice(chId, 1); $scope.otherdata = [tdata].concat(jsondata.data.slice(0, 5)); setTopData(tdata); } var timeout; window._Callback = function(d) { clearTimeout(timeout); init(d); }; timeout = setTimeout(function() { _Callback({tm_now:(new Date).getTime() / 1E3}); }, 2E3); _w.share = function(target) { var summary = [\"\\u80cc\\u666f\\uff1a\", current.name, \"\\uff0c\\u6027\\u522b\\uff1a\", current.sex, \"\\uff0c\\u51fa\\u751f\\u65f6\\u95f4\\uff1a\", current.birth_time, \"\\uff0c\\u5931\\u8e2a\\u65f6\\u95f4\\uff1a\", current.lost_time, \"\\uff0c\\u7279\\u5f81\\u63cf\\u8ff0\\uff1a\", current.child_feature].join(\"\"); if (summary) { summary = \"#\\u5bfb\\u627e\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d#\" + summary; } var stitle = \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8be6\\u60c5\"; var desc = \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\"; var encode = encodeURIComponent; var opts = {\"surl\":\"http://qzone.qq.com/gy/404/\" + current.id + \"/lostchild.html\", \"site\":\"QQ\\u7a7a\\u95f4\", \"summary\":summary || \"#\\u5b9d\\u8d1d\\u56de\\u5bb6#\\u817e\\u8baf\\u5fd7\\u613f\\u8005\\u7528\\u6280\\u672f\\u70b9\\u4eae\\u516c\\u76ca\\uff0c\\u8ba9\\u6211\\u4eec\\u4e00\\u8d77\\u5bfb\\u627e\\u8d70\\u5931\\u7684\\u513f\\u7ae5\\u5427\\uff01\", \"stitle\":stitle, \"pics\":current.child_pic, \"desc\":desc, \"origin_url\":current.url}; var surl = opts.surl || \"http://www.qq.com/404/\", summary = opts.summary || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u7684\\u5185\\u5bb9\", stitle = opts.stitle || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u7684\\u6807\\u9898\", pics = opts.pics || \"http://qzonestyle.gtimg.cn/qzone_v6/act/img/20120422_qzone_7_years/pop_up/icon-pop-seven-years.png\", site = opts.site || \"\\u8fd9\\u4e2a\\u662f\\u5206\\u4eab\\u94fe\\u63a5\\u7684\\u6587\\u5b57\", desc = opts.desc || \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\", origin_url = opts.origin_url || \"http://www.qq.com/404/\"; var shareList = {weibo:{method:function(evt) { var w = \"http://v.t.qq.com/share/share.php\", q = [\"?site=\", encode(surl + \"#via=share_t_weib\"), \"&title=\", encode(summary), \"&pic=\", encode(pics), \"&url=\", encode(surl)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"weibo\", \"width=700, height=680, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, location=yes, resizable=no, status=no\"); }}, qzone:{method:function(evt) { var buff = [], ps = {url:surl + \"#via=404-qzoneshare\", desc:desc || \"\\u5931\\u8e2a\\u7684\\u5b9d\\u8d1d\\u8981\\u56de\\u5bb6\\uff0c\\u5feb\\u6765\\u53c2\\u4e0e\\u7231\\u5fc3\\u7684\\u4f20\\u9012\\u5427\\uff01\", summary:summary, title:stitle, pics:pics, site:site}; for (var k in ps) { buff.push(k + \"=\" + encode(ps[k] || \"\")); } var w = \"http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?\" + buff.join(\"&\"), q = [\"#via=share_t_qzone\", \"&title=\", encode(summary), \"&pic=\", encode(pics), \"&url=\", encode(surl)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"qzone\", \"width=700, height=680, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, location=yes, resizable=no, status=no\"); }}, sina:{method:function() { var w = \"http://v.t.sina.com.cn/share/share.php\", q = [\"?url=\", encode(surl + \"#via=share_x_weib\"), \"&title=\", encode(summary), \"&source=\", \"&sourceUrl=\", surl, \"&content=utf-8\", \"&pic=\", encode(pics)].join(\"\"), p = [w, q].join(\"\"); openit(p, \"sina\", \"toolbar=0,status=0,resizable=1,width=440,height=430\"); }}, kaixin:{method:function() { var n = \"http://www.kaixin001.com/repaste/bshare.php?rurl=\" + encode(surl + \"#via=share_kaixin\") + \"&rcontent=&rtitle=\" + encode(summary); openit(n, \"kaixin\", \"toolbar=0,status=0,resizable=1,width=600,height=360\"); }}, renren:{method:function() { var n = \"http://www.connect.renren.com/share/sharer?title=\" + encode(summary) + \"&url=\" + encode(surl + \"#via=share_renren\"), p = window.open(n, \"rr\", \"toolbar=0,status=0,resizable=1,width=510,height=300\"); if (p) { p.focus(); } }}, weixin:{method:function() { var n = \"http://qzone.qq.com/gy/404/page/qrcode.html?url=\" + encode(origin_url + \"#via=share_weixin\"), p = window.open(n, \"rr\", \"toolbar=0,status=0,resizable=1,width=620,height=430\"); if (p) { p.focus(); } }}}; var openit = function(u, n, p) { function o() { var z; if (!(z = window.open(u, n, p))) { location.href = u; } else { z.focus(); } } o(); }; shareList[target] && shareList[target].method(); }; _w.toThis = function(id) { for (var i = 0;i < $scope.otherdata.length;i++) { if ($scope.otherdata[i]._id == id) { setTopData($scope.otherdata[i]); break; } } return false; }; var meta = document.createElement(\"meta\"); meta.name = \"viewport\"; meta.content = \"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"; ha.appendChild(meta); (function registerStyle() { var link = document.createElement(\"link\"); link.rel = \"stylesheet\"; link.type = \"text/css\"; link.href = \"https://qzone.qq.com/gy/404/style/404style.css\"; ha.appendChild(link); })(); (function initStat() { var qqDomainNameRE = /\\.qq\\.com$/i, qzoneDomainNameRE = /\\bqzone\\.qq\\.com$/i, qzsDomainNameRE = /\\bqzonestyle\\.gtimg\\.cn$/i; function cb() { var url = location.host; var src = \"\"; if (qzoneDomainNameRE.test(url)) { src = \"new404.qzone\"; } else { if (qqDomainNameRE.test(url)) { src = \"new404.qq\"; } else { if (qzsDomainNameRE.test(url)) { src = \"new404.qzonestyle\"; } else { src = url.replace(\".\", \"_\"); } } } _w.TCISD && (_w.TCISD.pv && _w.TCISD.pv(\"hat.qzone.qq.com\", \"/gy/lostchild/\" + src)); } getData(\"https://qzonestyle.gtimg.cn/ac/qzfl/stat.js\", cb); })(); })(window, document); !function() { function a(a, b) { return(/string|function/.test(typeof b) ? h : g)(a, b); } function b(a, c) { return \"string\" != typeof a && (c = typeof a, \"number\" === c ? a += \"\" : a = \"function\" === c ? b(a.call(a)) : \"\"), a; } function c(a) { return l[a]; } function d(a) { return b(a).replace(/&(?![\\w#]+;)|[\"']/g, c); } function e(a, b) { if (m(a)) { for (var c = 0, d = a.length;d > c;c++) { b.call(a, a[c], c, a); } } else { for (c in a) { b.call(a, a[c], c); } } } function f(a, b) { var c = /(\\/)[^/]+\\1\\.\\.\\1/, d = (\"./\" + a).replace(/[^/]+$/, \"\"), e = d + b; for (e = e.replace(/\\/\\.\\//g, \"/\");e.match(c);) { e = e.replace(c, \"/\"); } return e; } function g(b, c) { var d = a.get(b) || i({filename:b, name:\"Render Error\", message:\"Template not found\"}); return c ? d(c) : d; } function h(a, b) { if (\"string\" == typeof b) { var c = b; b = function() { return new k(c); }; } var d = j[a] = function(c) { try { return new b(c, a) + \"\"; } catch (d) { return i(d)(); } }; return d.prototype = b.prototype = n, d.toString = function() { return b + \"\"; }, d; } function i(a) { var b = \"{Template Error}\", c = a.stack || \"\"; if (c) { c = c.split(\"\\n\").slice(0, 2).join(\"\\n\"); } else { for (var d in a) { c += \"\\n\" + a[d] + \"\\n\\n\"; } } return function() { return \"object\" == typeof console && console.error(b + \"\\n\\n\" + c), b; }; } var j = a.cache = {}, k = this.String, l = {\"\":\"&#62;\", '\"':\"&#34;\", \"'\":\"&#39;\", \"&\":\"&#38;\"}, m = Array.isArray || function(a) { return \"[object Array]\" === {}.toString.call(a); }, n = a.utils = {$helpers:{}, $include:function(a, b, c) { return a = f(c, a), g(a, b); }, $string:b, $escape:d, $each:e}, o = a.helpers = n.$helpers; a.get = function(a) { return j[a.replace(/^\\.\\//, \"\")]; }, a.helper = function(a, b) { o[a] = b; }, \"function\" == typeof define ? define(function() { return a; }) : \"undefined\" != typeof exports ? module.exports = a : this.template = a, a(\"body\", function(a) { var b = this, c = (b.$helpers, b.$escape), d = a.retlink, e = a.rettext, f = a.topid, g = a.topimg, h = a.topname, i = a.topgender, j = a.topbirth, l = a.toplostdate, m = a.toplostplace, n = a.toplostdesc, o = a.toplink, p = b.$each, q = a.otherdata, r = (a.otheritem, a.index, \"\"); return r += ' 404\\uff0c\\u60a8\\u8bbf\\u95ee\\u7684\\u9875\\u9762\\u627e\\u4e0d\\u56de\\u6765\\u4e86\\uff0c\\u4f46\\u6211\\u4eec\\u53ef\\u4ee5\\u4e00\\u8d77\\u5e2e\\u4ed6\\u4eec\\u56de\\u5bb6\\uff01 ', r += c(e), r += ' ', r += c(h), r += '(', r += c(i), r += ') \\u51fa\\u751f\\u65e5\\u671f\\uff1a', r += c(j), r += ' \\u5931\\u8e2a\\u65f6\\u95f4\\uff1a', r += c(l), r += ' \\u5931\\u8e2a\\u5730\\u70b9\\uff1a', r += c(m), r += ' \\u5931\\u8e2a\\u4eba\\u7279\\u5f81\\u63cf\\u8ff0\\uff1a', r += c(n), r += ' \\u67e5\\u770b\\u8be6\\u60c5 \\u5206\\u4eab \\u817e\\u8baf\\u5fae\\u535a QQ\\u7a7a\\u95f4 \\u65b0\\u6d6a\\u5fae\\u535a \\u5fae\\u4fe1 ', p(q, function(a) { r += ' '; }), r += \" \", new k(r); }); }(); L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"debug\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/hijiki.model.json\"},\"display\":{\"position\":\"right\",\"width\":150,\"height\":300},\"mobile\":{\"show\":true},\"react\":{\"opacity\":0.7},\"log\":false});"},{"title":"关于我","date":"2019-04-19T08:40:39.000Z","updated":"2019-04-24T15:15:12.939Z","comments":true,"path":"about/index.html","permalink":"https://bigporo.github.io/about/index.html","excerpt":"","text":"17年毕业于铜院，目前就职于安徽飞修科技，一个菜鸡iOS开发，没事也写写小程序。 喜观山海，喜食烟火。 年轻无为，卖码为生。"},{"title":"分类","date":"2019-04-22T01:59:17.000Z","updated":"2019-04-23T16:27:49.760Z","comments":true,"path":"categories/index.html","permalink":"https://bigporo.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-22T01:58:24.000Z","updated":"2019-04-23T16:18:38.800Z","comments":true,"path":"tags/index.html","permalink":"https://bigporo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"怎么应对各种富文本表现需求？","slug":"怎么应对各种富文本表现需求？","date":"2019-05-17T02:23:12.000Z","updated":"2019-05-17T03:06:02.080Z","comments":true,"path":"2019/05/17/怎么应对各种富文本表现需求？/","link":"","permalink":"https://bigporo.github.io/2019/05/17/怎么应对各种富文本表现需求？/","excerpt":"前言在iOS的日常开发中，会经常使用到富文本。 简单来说，富文本就是一段有属性的字符串，可以包含不同字体、不同字号、不同背景、不同颜色、不同字间距的文字，还可以设置段落、图文混排等属性。 正常在使用富文本的时候，有如下方式：HTML、TextKit、YYKit。一般在长列表的场景下，我们使用性能更高、内存占用更少的TextKit、YYKit。","text":"前言在iOS的日常开发中，会经常使用到富文本。 简单来说，富文本就是一段有属性的字符串，可以包含不同字体、不同字号、不同背景、不同颜色、不同字间距的文字，还可以设置段落、图文混排等属性。 正常在使用富文本的时候，有如下方式：HTML、TextKit、YYKit。一般在长列表的场景下，我们使用性能更高、内存占用更少的TextKit、YYKit。 WebView加载HTML这个是个常规操作 1[self.wbView loadHTMLString:articleString baseURL:nil]; 与loadRequest方法相比，loadHTMLString可以直接读取HTML代码，省去了网络请求的时间，展示速度很快。 不过HTML里面的图片资源还是需要通过网络获取的，如果能够在展示之前就缓存下图片，无需等待，就能够快速的展示了。 如何缓存HTML里面的图片在Cocoa层使用NSURLProtocol可以拦截所有HTTP请求，所有可以利用NSURLProtocol来缓存文章中的图片。 推荐戴铭的这个Web页面预加载库STMURLCache来预缓存HTML里面的图片。具体的使用方法都在仓库里面。 YYText集成十分简单，cocoapods就可以。下面看下如何使用:1234567891011121314151617181920NSMutableAttributedString *text = [NSMutableAttributedString new];UIFont *font = [UIFont systemFontOfSize:16];NSMutableAttributedString *attachment = nil; // 嵌入 UIImageUIImage *image = [UIImage imageNamed:@&quot;dribbble64_imageio&quot;];attachment = [NSMutableAttributedString yy_attachmentStringWithContent:image contentMode:UIViewContentModeCenter attachmentSize:image.size alignToFont:font alignment:YYTextVerticalAlignmentCenter];[text appendAttributedString: attachment]; // 嵌入 UIViewUISwitch *switcher = [UISwitch new];[switcher sizeToFit];attachment = [NSMutableAttributedString yy_attachmentStringWithContent:switcher contentMode:UIViewContentModeBottom attachmentSize:switcher.size alignToFont:font alignment:YYTextVerticalAlignmentCenter];[text appendAttributedString: attachment]; // 嵌入 CALayerCASharpLayer *layer = [CASharpLayer layer];layer.path = ...attachment = [NSMutableAttributedString yy_attachmentStringWithContent:layer contentMode:UIViewContentModeBottom attachmentSize:switcher.size alignToFont:font alignment:YYTextVerticalAlignmentCenter];[text appendAttributedString: attachment]; 最后对比代码可以看到，原始代码描述富文本跟HTML比，既啰嗦又复杂。HTML代码更已读、更容易维护，所以除了长列表外，都建议使用HTML来描述富文本。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"}]},{"title":"数据结构","slug":"iOS数据结构","date":"2019-05-16T07:01:52.000Z","updated":"2019-05-16T09:06:46.934Z","comments":true,"path":"2019/05/16/iOS数据结构/","link":"","permalink":"https://bigporo.github.io/2019/05/16/iOS数据结构/","excerpt":"数据结构常见的数据结构一般有如下几个：字符串、数组、链表、树、栈、队列。下面分别说明。 字符串 字符串是由若干字符组成的序列，使用频率很高，为了优化，很多语言都对字符串做了特殊的规定。 在C/C++中，每个字符串都以’\\0’结尾，这样我们就可以很容易的找到字符串的尾部。所以每个字符串都有一个额外字符的开销。稍不留神就会造成字符串的越界。 为了节省内存，C/C++把常量字符串放到单独的一个内存区域。当几个指针赋值给相同的常量字符串时，它们实际上会指向相同的内存地址。但用常量内存初始化数组，情况却有所不同。","text":"数据结构常见的数据结构一般有如下几个：字符串、数组、链表、树、栈、队列。下面分别说明。 字符串 字符串是由若干字符组成的序列，使用频率很高，为了优化，很多语言都对字符串做了特殊的规定。 在C/C++中，每个字符串都以’\\0’结尾，这样我们就可以很容易的找到字符串的尾部。所以每个字符串都有一个额外字符的开销。稍不留神就会造成字符串的越界。 为了节省内存，C/C++把常量字符串放到单独的一个内存区域。当几个指针赋值给相同的常量字符串时，它们实际上会指向相同的内存地址。但用常量内存初始化数组，情况却有所不同。 数组 数组占据一段连续的内存并按照顺序储存数据。 在创建数组时，首先需要指定数组的容量大小，然后根据大小分配内存。因此数组的空间效率不是很高。 数组是有序的，在I/O操作时可以根据下标进行索引，所以时间效率很高。 动态数组：C++的STL中的vector。我们先为数组开辟较小的空间，然后往数组中添加数据。当数据的数目超过数组的容量时，我们再重新分配一块更大的空间（STL的vector每次扩充容量时，新的容量都是前一次的两倍），把之前的数据复制到新的数组中，再把之前的内存释放，这样就能减少内存的浪费。 链表 由若干个指针将若干个节点链接成链状结构，是一种动态的数据结构。 创建链表时无需知道链表的长度。当插入一个新的节点时，直接为其分配内存，然后调整指针的指向，保证新的节点被链接上。这样就没有闲置的内存，空间效率比较高。 链表在进行循环遍历时效率不高，但是插入和删除时优势明显。 链表的几个类型单向链表单向链表是最简单的链表形式。我们将链表中最基本的数据称为节点(node)，每一个节点包含了数据块和指向下一个节点的指针。 双向链表双向链表就是有两个方向的链表。同单向链表不同，在双向链表中每一个节点不仅存储指向下一个节点的指针，而且存储指向前一个节点的指针。通过这种方式，能够通过在O(1)时间内通过目的节点直接找到前驱节点，但是同时会增加大量的指针存储空间。 循环链表循环链表与双向链表相似，不同的地方在于：在链表的尾部增加一个指向头结点的指针，头结点也增加一个指向尾节点的指针，以及第一个节点指向头节点的指针，从而更方便索引链表元素。 树 除了根结点之外每个结点只有一个父结点，根结点没有父结点；除了叶结点之外所有结点都有一个或多个子结点，叶结点没有子结点。父结点和子结点之间用指针链接。 二叉树是树的一种特殊结构，在二叉树中每个结点最多只能有两个子结点。在二叉树中最重要的操作莫过于遍历，即按照某一顺序访问树中的所有结点。 遍历二叉树：前序遍历、后序遍历、中序遍历。 栈和队列 栈的特点是后进先出，即最后被压入（push）栈的元素会第一个被弹出（pop）。 队列的特点是先进先出，即第一个进入队列的元素将会第一个出来。","categories":[{"name":"基本功","slug":"基本功","permalink":"https://bigporo.github.io/categories/基本功/"}],"tags":[{"name":"基本功","slug":"基本功","permalink":"https://bigporo.github.io/tags/基本功/"}]},{"title":"《剑指Offer》读书总结","slug":"《剑指Offer》读书总结","date":"2019-04-25T02:42:13.000Z","updated":"2019-05-16T03:46:50.738Z","comments":true,"path":"2019/04/25/《剑指Offer》读书总结/","link":"","permalink":"https://bigporo.github.io/2019/04/25/《剑指Offer》读书总结/","excerpt":"面试的三个环节行为面试 主要是暖场，需要快速调节以进入面试状态。 项目经验 项目背景：项目的规模，开发的软件的功能，目标用户等。 任务：详细介绍自己的的任务，注意区分“参与”和“负责”。 具体工作：介绍完成任务所做的工作，可以具体到结构、框架、技术细节等。 贡献：详细介绍在任务中的贡献，最好可以数字化。","text":"面试的三个环节行为面试 主要是暖场，需要快速调节以进入面试状态。 项目经验 项目背景：项目的规模，开发的软件的功能，目标用户等。 任务：详细介绍自己的的任务，注意区分“参与”和“负责”。 具体工作：介绍完成任务所做的工作，可以具体到结构、框架、技术细节等。 贡献：详细介绍在任务中的贡献，最好可以数字化。 可能会问的问题 在该项目中遇到的最大的问题是什么？ 从这个项目中学到了什么？ 什么时候会和其他成员有怎样的冲突？怎么解决的？ 为什么跳槽需要避免以下原因： 老板太苛刻 同事难相处 加班太频繁 工资太低(即使是实际原因也不建议说) 常规回答： 现在的工作做的太久，没有激情了，希望有一份更有挑战性的工作。 现在的工作的方向和自己预想的有偏差。 技术面试这块是重头戏，对面试的结果会有决定性的影响。一般会关注如下几个方面： 基础知识扎实全面，包括编程语言、数据结构、算法等。 能写出高质量的代码。 能思路清晰的分析和解决复杂问题。 能从时间、空间复杂度两个方面优化算法的效率。 具备优秀的沟通能力、学习能力、发散思维等能力。 应聘者提问环节 不要问与自己入职之后的工作无关的问题。 不要问薪水，技术面试不是问薪水的时候。 不要立刻打听面试的结果。 面试需要的基础知识编程语言:C++、C#（卒） 数据结构数组 占据一块连续的内存并按照顺序存储数据，初始化时就已经确定了大小，然后根据大小分配内存。所以导致空间效率不是很好。 数组的内存是连续的，所以根据下标进行读写的时候，时间效率很高。 动态数组可以在一定程度上解决空间效率不高的问题，但是每一次扩充数组的时候都有大量的额外操作，对时间性能有影响。 字符串在C#中，封装字符串的类型System.String有一个非常特殊的性质：String中的内容是不能改变的。一旦试图改变String的内容，就会产生一个新的实例。 链表内存分配不是在创建链表时一次性完成，而是每添加一个结点分配一次内存。没有闲置的内存，所以空间效率比较高。 树逻辑除了根结点之外每个结点只有一个父结点，根结点没有父结点；除了叶结点之外所有结点都有一个或多个子结点，叶结点没有子结点。父结点和子结点之间用指针链接。 遍历方式 前序遍历：先访问根结点，再访问左子结点，最后访问右子结点。 中序遍历：先访问左子结点，再访问根结点，最后访问右子结点。 后序遍历：先访问左子结点，再访问右子结点，最后访问根结点。 后序遍历：先访问左子结点，再访问右子结点，最后访问根结点。 堆：堆分为最大堆和最小堆。在最大堆中根结点的值最大，在最小堆中根结点的值最小。有很多需要快速找到最大值或者最小值的问题都可以用堆来解决。 红黑树：红黑树是把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短路径的两倍。 二叉树：数中的每个节点只能有两个子节点。 栈和队列栈特点：后进先出，弹栈。 队列特点：先进先出。 算法和数据操作重点掌握二分查找、归并排序和快速排序，做到能随时正确、完整地写出它们的代码。 查找和排序查找顺序查找、二分查找、哈希表查找、二叉排序树查找 排序插入排序、冒泡排序、归并排序、快速排序等。 递归和循环递归 斐波拉契数列: f(n) = f(n-1) + f(n-2).面试题：青蛙上台阶。 通常递归的代码会比较简洁。 但是递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址及临时变量，而且往栈里压入数据和弹出数据都需要时间。严重的话会造成栈溢出。 递归中可能会有很多重复的计算，对性能造成负面影响。 位运算位运算是把数字用二进制表示之后，对每一位上0或者1的运算。 位运算总共只有五种运算：与、或、异或、左移和右移。 高质量的代码 若干经典面试题 书写清晰、布局清晰、命名合理。 考虑边界情况和特殊情况，提升代码的完整性。 提升代码的鲁棒性(健壮性)。 解决面试题的思路 画图让抽象问题具象化。 举例让抽象问题具体化。 分解让复杂问题简单化。 优化空间效率和时间效率权衡好空间换时间。 面试中的各项能力两个案列","categories":[{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/categories/读书/"}],"tags":[{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/tags/读书/"}]},{"title":"开始下一程","slug":"开始下一程","date":"2019-04-24T15:29:05.000Z","updated":"2019-04-25T02:56:21.344Z","comments":true,"path":"2019/04/24/开始下一程/","link":"","permalink":"https://bigporo.github.io/2019/04/24/开始下一程/","excerpt":"我又回来了其实早在18年的年初就已经搭了一个博客，但是当时有很奇怪的包袱，觉得必须要产出很优质的内容，才可以写在博客上，给了自己比较大的压力。然后因为工作比较忙，博客也搁置了，最终索性直接删了。其实都是借口吧，所以最近趁着比较空闲，又重新搭了一个。 这次博客的定位和之前有了一些不同，更像是一个笔记 + 生活感悟 + 发牢骚的地方，所以也没有包袱了，只是单纯的记录。 所以把之前记录在有道云笔记的一部分内容搬运到了这里，占个地吧。","text":"我又回来了其实早在18年的年初就已经搭了一个博客，但是当时有很奇怪的包袱，觉得必须要产出很优质的内容，才可以写在博客上，给了自己比较大的压力。然后因为工作比较忙，博客也搁置了，最终索性直接删了。其实都是借口吧，所以最近趁着比较空闲，又重新搭了一个。 这次博客的定位和之前有了一些不同，更像是一个笔记 + 生活感悟 + 发牢骚的地方，所以也没有包袱了，只是单纯的记录。 所以把之前记录在有道云笔记的一部分内容搬运到了这里，占个地吧。 近况在飞修的一年多里，说实话，成长不多，iOS的本职工作只能说是及格，穿插着看了JS和小程序。现在因为公司的业务调整，移动端的需求不多，所以现在也兼职写写小程序。 在生活上，这一两年做了很多。女朋友 –&gt; 怀孕 –&gt; 结婚 –&gt; 买房买车 –&gt; 装修ing,还有宝宝即将出生。 即将成为父亲的我，渐渐的感受到了生活的压力。和之前的一人吃饱全家不饿不同了。现在每天睁开眼就是老婆、房贷、装修等等事情，让人心力交瘁。突然想起了一个朋友的话:“一个程序员最强形态就是单身狗”。现在体会到的事实也大概如此吧。 可是啊，谁不是负重前行呢，父母渐老，一辈子的积蓄给我换来了一个安家之所，我也必须给他们一个立命之处。咬紧牙关，保持热情，继续走下去吧。","categories":[{"name":"烟火","slug":"烟火","permalink":"https://bigporo.github.io/categories/烟火/"}],"tags":[{"name":"烟火","slug":"烟火","permalink":"https://bigporo.github.io/tags/烟火/"}]},{"title":"Injection：iOS热重载-所见即所得","slug":"Injection：iOS热重载-所见即所得","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T09:23:45.568Z","comments":true,"path":"2019/04/23/Injection：iOS热重载-所见即所得/","link":"","permalink":"https://bigporo.github.io/2019/04/23/Injection：iOS热重载-所见即所得/","excerpt":"","text":"参考博客 参考博客","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"ImageOptim - 图片压缩","slug":"ImageOptim - 图片压缩","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T09:23:32.015Z","comments":true,"path":"2019/04/23/ImageOptim - 图片压缩/","link":"","permalink":"https://bigporo.github.io/2019/04/23/ImageOptim - 图片压缩/","excerpt":"下载地址 ImageOptim是一款基于Mac的图像“瘦身”软件，内置有6种压缩算法，通过删除图片部分无用的EXIF等信息来减小PNG、JPEG和GIF图片的大小。","text":"下载地址 ImageOptim是一款基于Mac的图像“瘦身”软件，内置有6种压缩算法，通过删除图片部分无用的EXIF等信息来减小PNG、JPEG和GIF图片的大小。ImageOptim合并了OptiPNG、PNGCrush、AdvanceComp、PNGOUT、Jpegoptim+Jpegtran和Gifsicle等几个工具，旨在为设计师提供最好的优化效果。在最新发布的1.4.4版本中，ImageOptim改进了文件在文件列表中的拖拽、复制、粘贴功能。","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"LSUnusedResources -无用资源查找","slug":"LSUnusedResources -无用资源查找","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T09:24:02.664Z","comments":true,"path":"2019/04/23/LSUnusedResources -无用资源查找/","link":"","permalink":"https://bigporo.github.io/2019/04/23/LSUnusedResources -无用资源查找/","excerpt":"下载地址","text":"下载地址 核心步骤，简述如下： 查找：选定的目录下的所有资源文件。这一步与上述方案1区别不大，都是调用 find 命令查找指定后缀名的文件。 匹配：与上述方案不同，我不是对每个资源文件名都做一次全文搜索匹配，因为加入项目的资源太多，这里会导致性能快速下降。而我只是针对源码、Xib、Storyboard 和 plist 等文件，先全文搜索其中可能是引用了资源的字符串，然后用资源名和字符串做匹配。 使用方法 点击 Browse.. 选择一个文件夹； 点击 Search 开始搜索； 等待片刻即可看到结果。","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"Reveal 4.0 使用指南","slug":"Reveal 4.0 使用指南","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T09:25:16.212Z","comments":true,"path":"2019/04/23/Reveal 4.0 使用指南/","link":"","permalink":"https://bigporo.github.io/2019/04/23/Reveal 4.0 使用指南/","excerpt":"Reveal 简介Reveal是一款iOS程序界面调试工具，可以让我们在开发时动态的查看和修改APP的界面。免去了每次修改完代码重新启动的痛苦。 启动界面如下图：","text":"Reveal 简介Reveal是一款iOS程序界面调试工具，可以让我们在开发时动态的查看和修改APP的界面。免去了每次修改完代码重新启动的痛苦。 启动界面如下图： Reveal 的安装安装很简单，直接下载一路到底就可以。 官方正版下载地址 破解版下载地址 Reveal 的使用集成方式官方一共提供了三种集成方式 三种集成指南对比 使用cocoapods集成 app内集成Reveal Server framework 利用Xcode的Breakpoint 断点加载Reveal Server 对比:1和2基本相似，需要修改工程文件，3不需要修改工程文件，选用第3种。 利用Xcode的Breakpoint 断点加载Reveal Server 在Xcode中添加一个Symbolic Breakpoint.右击这个断点，编辑如下图: Action里面填写的内容如下:1expr (Class)NSClassFromString(@&quot;IBARevealLoader&quot;) == nil ? (void *)dlopen(&quot;/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/RevealServer.framework/RevealServer&quot;, 0x2) : ((void*)0) 右键当前断点,选择Move Breakpoint To → User。 Xcode 选择9.0系统 ,模拟器运行项目。 运行好项目后,Reveal自动显示，双击即可查看效果。 Reveal在真机中调试应用在真机中调试的安装方法，需要添加静态库到工程中，略微麻烦。 尝试操作了一遍，太麻烦了，卒。 Reveal在调试其它应用的安装方法在Reveal中调试其它应用，需要一部越狱的手机，没越狱的手机没办法调试。(本人没有，咩有尝试) 参考博客","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"Fastlane--自动打包","slug":"Fastlane-自动打包","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-26T15:21:53.346Z","comments":true,"path":"2019/04/23/Fastlane-自动打包/","link":"","permalink":"https://bigporo.github.io/2019/04/23/Fastlane-自动打包/","excerpt":"Fastlane是一套使用Ruby写的自动化工具集，旨在简化Android和iOS的部署过程，自动化你的工作流。它可以简化一些乏味、单调、重复的工作，像截图、代码签名以及发布App","text":"Fastlane是一套使用Ruby写的自动化工具集，旨在简化Android和iOS的部署过程，自动化你的工作流。它可以简化一些乏味、单调、重复的工作，像截图、代码签名以及发布App 安装安装xcode命令行工具xcode-select –install，如果没有安装，会弹出对话框，点击安装。如果提示1xcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates 表示已经安装 安装Fastlanegem install fastlane -NV```或是 ```brew cask install fastlane ```123我这里使用第一种方式安装的如果报错： ERROR: While executing gem … (Errno::EPERM) Operation not permitted - /usr/bin/commander1执行: sudo gem install -n /usr/local/bin fastlane1完成之后执行: fastlane –version1确认下是否安装完成和当前使用的版本号。 fastlane installation at path: /Library/Ruby/Gems/2.3.0/gems/fastlane-2.117.1/bin/fastlane[✔] 🚀fastlane 2.117.1 123## 初始化Fastlanecd到你的项目目录执行``` fastlane init 1234567891. 📸 Automate screenshots2. 👩‍✈️ Automate beta distribution to TestFlight3. 🚀 Automate App Store distribution4. 🛠 Manual setup - manually setup your project to automate your tasks? Ambiguous choice. Please choose one of [1, 2, 3, 4, 📸 Automatescreenshots, 👩‍✈️ Automate beta distribution to TestFlight, 🚀 AutomateApp Store distribution, 🛠 Manual setup - manually setup your project toautomate your tasks]. 选几都行，后续我们自行根据需求完善就可以，这里我选的是3。12[17:38:53]: Please enter your Apple ID developer credentials[17:38:53]: Apple ID Username: 按照提示输入开发者账号和密码，登录成功后会提示你是否需要下载你的App的metadata。点y等待就可以。 文件夹结构初始化成功后会在当前工程目录生成一个fastlane文件夹，文件目录为下。 metadata和screenshots分别对应App元数据和商店应用截图。 Appfile主要存放App的apple_id team_id app_identifier等信息 Deliverfile中为发布的配置信息，一般情况用不到。 Fastfile是我们最应该关注的文件，也是我们的工作文件。 Fastfile文件内容如下:123456789101112131415161718192021222324# This file contains the fastlane.tools configuration# You can find the documentation at https://docs.fastlane.tools## For a list of all available actions, check out## https://docs.fastlane.tools/actions## For a list of all available plugins, check out## https://docs.fastlane.tools/plugins/available-plugins## Uncomment the line if you want fastlane to automatically update itself# update_fastlanedefault_platform(:ios)platform :ios do desc &quot;Push a new release build to the App Store&quot; lane :release do build_app(workspace: &quot;XXX.xcworkspace&quot;, scheme: &quot;XXX&quot;) upload_to_app_store endend 之前我们了解了action，那action的组合就是一个lane，打包到蒲公英是一个lane，打包到应用商店是一个lane，打包到testflight也是一个lane。可能理解为任务会好一些。 打包到蒲公英这里以打包上传到蒲公英为例子，实现我们的一行命令自动打包。 蒲公英在Fastlane是作为一个插件存在的，所以要打包到蒲公英必须先安装蒲公英的插件。 打开终端输入fastlane add_plugin pgyer 更多信息查看蒲公英文档 新建一个lane:12345678910111213desc &quot;打包到pgy&quot;lane :test do |options|gym( clean:true, #打包前clean项目 export_method: &quot;ad-hoc&quot;, #导出方式 scheme:&quot;shangshaban&quot;, #scheme configuration: &quot;Debug&quot;,#环境 output_directory:&quot;./app&quot;,#ipa的存放目录 output_name:get_build_number()#输出ipa的文件名为当前的build号 )#蒲公英的配置 替换为自己的api_key和user_keypgyer(api_key: &quot;xxxxxxx&quot;, user_key: &quot;xxxxxx&quot;,update_description: options[:desc])end option用于接收我们的外部参数，这里可以传入当前build的描述信息到蒲公英平台 执行在工作目录的终端执行 1fastlane test desc:测试打包 打包成功12345678910111213[10:17:35]: Upload success. Visit this URL to see: https://www.pgyer.com/feixiuman+------+------------------+-------------+| fastlane summary |+------+------------------+-------------+| Step | Action | Time (in s) |+------+------------------+-------------+| 1 | default_platform | 0 || 2 | gym | 129 || 3 | pgyer | 12 |+------+------------------+-------------+[10:17:35]: fastlane.tools finished successfully 🎉 参考博客 参考博客 Github 官网 文档","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"获取ipa包以及图片资源","slug":"获取ipa包以及图片资源","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T09:20:19.084Z","comments":true,"path":"2019/04/23/获取ipa包以及图片资源/","link":"","permalink":"https://bigporo.github.io/2019/04/23/获取ipa包以及图片资源/","excerpt":"iTunnes降级首先，是需要将电脑上的itunes删除，然后下载一个低版本的替换最新的，这个方法比较麻烦的是因为itunes是系统的软件，删除会有影响系统的风险而且默认是不能删除的。所以该方法不推荐使用。 可以去这里下载需要的itunes。","text":"iTunnes降级首先，是需要将电脑上的itunes删除，然后下载一个低版本的替换最新的，这个方法比较麻烦的是因为itunes是系统的软件，删除会有影响系统的风险而且默认是不能删除的。所以该方法不推荐使用。 可以去这里下载需要的itunes。 使用Apple Configurator 2 安装Apple Configurator 2在mac的App Store上面，可以搜索到免费的Apple Configurator 2直接点击安装就可以。 打开App Configurator 2 点击账户，用手机上的AppleID进行登录。 手机连接电脑，然后点击“添加”,点击应用下载 下载完成后，会有一个弹窗，不用点任何按键，直接到电脑上的如下地址去找到刚下好的应用程序安装包。 1~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/ 拷贝ipa包，重命名为.zip格式文件，解压就可以了。 如何获取里面的png图片资源图片资源一般都在Assets.car文件中，如何打开Assets.car。我使用的是iOS Images Extractor,在解压后的的文件夹中找到ipa后缀的文件，右击显示包内容，就可以看到Assets.car文件，直接拖进到工具里面就可以输出图片资源文件夹了。 下载链接","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"文档生成工具-appledoc","slug":"文档生成工具-appledoc","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T09:31:51.577Z","comments":true,"path":"2019/04/23/文档生成工具-appledoc/","link":"","permalink":"https://bigporo.github.io/2019/04/23/文档生成工具-appledoc/","excerpt":"简介做项目的人多了，就需要文档了。但是就源代码来说，文档最好和源码在一起，这样更新起来更加方便和顺手。象 Java 语言本身就自带 javadoc 命令，可以从源码中抽取文档。今天抽空调研了一下 Objective-C 语言的类似工具。","text":"简介做项目的人多了，就需要文档了。但是就源代码来说，文档最好和源码在一起，这样更新起来更加方便和顺手。象 Java 语言本身就自带 javadoc 命令，可以从源码中抽取文档。今天抽空调研了一下 Objective-C 语言的类似工具。 appledoc是命令行工具，可帮助Objective-C开发人员从特殊格式的源代码注释中生成类似Apple的源代码文档。它旨在为输入提供尽可能可读的源代码注释，并使用注释以及周围的源代码，以HTML的形式生成视觉上吸引人的文档以及完全索引和可浏览的Xcode文档集。虽然有几种工具可以为Objective-C创建HTML文档，但是我所知道的所有工具都无法满足下面描述的最低目标。 appledoc的主要目标： 人类可读的源代码注释。 对对象和成员的简单交叉引用。 生成类似Apple的源代码HTML文档。 生成并安装完全索引和可浏览的Xcode文档集。 单一工具，用于驱动从源代码解析到文档集安装的生成。 轻松定制输出。 100％Objective-C实现，易于调试。 安装那么简单介绍一下如何安装 appledoc，安装非常简单，只需要 2 步： 123git clone git://github.com/tomaz/appledoc.gitcd appledocsudo sh install-appledoc.sh 安装成功:123** INSTALL SUCCEEDED **install: /tmp/Build/Intermediates.noindex/ArchiveIntermediates/appledoc/InstallationBuildProductsLocation/usr/local/bin/appledoc -&gt; /usr/local/bin//appledoc 另外还有Homebrew： 1brew install appledoc Homebrew默认不安装模板。 安装提示要保持最新，只需转到终端并进入appledoc目录，发出git pull并重新编译appledoc.xcodeproj。不要忘记覆盖已复制到$ PATH的appledoc可执行文件:) 如果您还想编译并运行AppledocTests（单元测试）目标，则需要在构建单元测试目标之前将Libraries＆Frameworks组中指示的所有框架复制到共享框架目录！构建appledoc工具本身不需要这样做。 使用命令行输入:1appledoc --no-create-docset --output ~/Desktop --project-name Runtime_Demo --project-company iDog --company-id com.iDog /Users/idog/Desktop/Object-C_Demo/Runtime_Demo 成功之后可以看到:1appledoc version: 2.2.1 (build 1334) 参数解释: –no-create-docset // 不生成docset类型，生成html –output ~/Desktop // 文档生成的位置 –project-name Runtime_Demo //工程的名字，其实这个可以随便取，至少取成工程的名字可以知道这个文档是哪个 –project-company // 公司的名称 –company-id com.ZQD // 公司的id ~/Desktop/JieLin6/JieLin6/Helpers/ //你要生成文档的注释类所在的文件目录，及工程目录 注释的标准支持如下三种:1231. /*! this a test . */2. /** this a comment. */3. /// this is a long comment. */ 经常使用的标签： 12345678@brief : 使用它来写一段你正在文档化的method, PRoperty, class, file, struct, 或enum的短描述信息。@discusstion: 用它来写一段详尽的描述。如果需要你可以添加换行。@param:通过它你可以描述一个 method 或 function的参数信息。你可以使用多个这种标签。@return: 用它来制定一个 method 或 function的返回值。@see: 用它来指明其他相关的 method 或 function。你可以使用多个这种标签。@sa:同上@code ： 使用这个标签，你可以在文档当中嵌入代码段。当在Help Inspector当中查看文档时，代码通过在一个特别的盒子中用一种不同的字体来展示。始终记住在写的代码结尾处使用@endcode标签。@remark : 在写文档时，用它来强调任何关于代码的特殊之处。 举例：12/*! @brief This property knows my name. */@property (nonatomic, strong) NSString *myName; 记录文件常用标签： 123456789101112131415161718192021222324252627@file: 使用这个标签来指出你正在记录一个文件（header 文件或不是）。如果你将使用Doxygen来输出文档，那么你最好在这个标签后面紧接着写上文件名字。它是一个top level 标签。@header: 跟上面的类似，但是是在 HeaderDoc中使用。当你不使用 Doxygen时，不要使用上面的标签。@author：用它来写下这个文件的创建者信息@copyright: 添加版权信息@version: 用它来写下这个文件的当前版本。如果在工程生命周期中版本信息有影响时这会很重要。再一次的，我只给出最常用的标签。自己查看说明文档了解更多标签信息。@class: 用它来指定一个class的注释文档块的开头。它是一个top level标签，在它后面应该给出class名字。@interface: 同上@protocol: 同上两个一样，只是针对protocols@superclass: 当前class的superclass@classdesign: 用这个标签来指出你为当前class使用的任何特殊设计模式（例如，你可以提到这个class是不是单例模式或者类似其它的模式）。@coclass: 与当前class合作的另外一个class的名字。@helps: 当前class帮助的class的名字。@helper: 帮助当前class的class名字。 参考文档 项目主页","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"Charles 从入门到精通","slug":"Charles 从入门到精通","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T09:22:10.107Z","comments":true,"path":"2019/04/23/Charles 从入门到精通/","link":"","permalink":"https://bigporo.github.io/2019/04/23/Charles 从入门到精通/","excerpt":"巧神原文 本文是在巧神原文的基础上，按照流程走一遍并记录。 简介Charles 是在 Mac 下常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。 Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。 Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。 Charles 主要的功能包括： 截取 Http 和 Https 网络封包。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟慢速网络。","text":"巧神原文 本文是在巧神原文的基础上，按照流程走一遍并记录。 简介Charles 是在 Mac 下常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。 Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。 Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。 Charles 主要的功能包括： 截取 Http 和 Https 网络封包。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟慢速网络。 安装 Charles下载地址 将 Charles 设置成系统代理之前提到，Charles 是通过将自己设置成代理服务器来完成封包截取的，所以使用 Charles 的第一步是将其设置成系统的代理服务器。 启动 Charles 后，第一次 Charles 会请求你给它设置系统代理的权限。你可以输入登录密码授予 Charles 该权限。你也可以忽略该请求，然后在需要将 Charles 设置成系统代理时，选择菜单中的 “Proxy” -&gt; “Mac OS X Proxy” 来将 Charles 设置成系统代理。如下所示： 之后，你就可以看到源源不断的网络请求出现在 Charles 的界面中。 注意：开启了VPN之后，会导致抓取不到请求，需要关闭VPN。 Charles 主界面介绍Charles 主要提供两种查看封包的视图，分别名为 “Structure” 和 “Sequence”。 Structure 视图将网络请求按访问的域名分类。 Sequence 视图将网络请求按访问的时间排序。 大家可以根据具体的需要在这两种视图之前来回切换。请求多了有些时候会看不过来，Charles 提供了一个简单的 Filter 功能，可以输入关键字来快速筛选出 URL 中带指定关键字的网络请求。 对于某一个具体的网络请求，你可以查看其详细的请求内容和响应内容。如果请求内容是 POST 的表单，Charles 会自动帮你将表单进行分项显示。如果响应内容是 JSON 格式的，那么 Charles 可以自动帮你将 JSON 内容格式化，方便你查看。如果响应内容是图片，那么 Charles 可以显示出图片的预览。 过滤网络请求通常情况下，我们需要对网络请求进行过滤，只监控向指定目录服务器上发送的请求。对于这种需求，以下几种办法： 方法一：在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：https://www.ifeixiu.com, 那么只需要在 Filter 栏中填入 ifeixiu 即可。 方法二：在 Charles 的菜单栏选择 “Proxy”-&gt;”Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图所示：通常情况下，我们使用方法一做一些临时性的封包过滤，使用方法二做一些经常性的封包过滤。 方法三：在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项，如下图所示： 截取 iPhone 上的网络封包Charles 通常用来截取本地上的网络封包，但是当我们需要时，我们也可以用来截取其它设备上的网络请求。下面我就以 iPhone 为例，讲解如何进行相应操作。 Charles 上的设置要截取 iPhone 上的网络请求，我们首先需要将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 “Proxy”-&gt;”Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。如下图所示: iPhone 上的设置首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”-&gt;”Local IP Address”，即可在弹出的对话框中看到 IP 地址，如下图所示： 在 iPhone 的 “ 设置 “-&gt;” 无线局域网 “ 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888。 设置好之后，我们打开 iPhone 上的任意需要网络通讯的程序，就可以看到 Charles 弹出 iPhone 请求连接的确认菜单（如下图所示），点击 “Allow” 即可完成设置。 截取 Https 通讯信息安装证书如果你需要截取分析 Https 协议相关的内容。那么需要安装 Charles 的 CA 证书。具体步骤如下。 首先我们需要在 Mac 电脑上安装证书。点击 Charles 的顶部菜单，选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate”，然后输入系统的帐号密码，即可在 KeyChain 看到添加好的证书。如下图所示：需要注意的是，即使是安装完证书之后，Charles 默认也并不截取 Https 网络通讯的信息，如果你想对截取某个网站上的所有 Https 网络请求，可以在该请求上右击，选择 SSL proxy，如下图所示： 截取移动设备中的 Https 通讯信息如果我们需要在 iOS 或 Android 机器上截取 Https 协议的通讯内容，还需要在手机上安装相应的证书。点击 Charles 的顶部菜单，选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate on a Mobile Device or Remote Browser”，然后就可以看到 Charles 弹出的简单的安装教程。如下图所示： 这样，对于该 Host 的所有 SSL 请求可以被截取到了。 按照我们之前说的教程，在设备上设置好 Charles 为代理后，在手机浏览器中访问地址：http://charlesproxy.com/getssl，即可打开证书安装的界面，安装完证书后，就可以截取手机上的 Https 通讯内容了。不过同样需要注意，默认情况下 Charles 并不做截取，你还需要在要截取的网络请求上右击，选择 SSL proxy 菜单项。 可能遇到的问题Charles乱码 3.10版本之前: 去http://www.charlesproxy.com/ssl.zip 下载 CA 证书文件，然后双击 .crt 文件，选择‘总是信任’按钮，在钥匙串访问中即可看到添加成功的证书。 4.02版本以后 先点proxy中的macOS Proxy ，如果进行了网络请求，但是Charles没有出现数据的话，把翻墙软件关了。 然后去钥匙串找到Charles的CA证书，双击修改如下。 关闭窗口就可以看到证书变成: 接下来点击proxy中的SSL Proxying Settings，出现如下图所示，然后点add 在Host里填 * 号 ，在Port里填443，然后点ok：模拟慢速网络在做移动开发的时候，我们常常需要模拟慢速网络或者高延迟的网络，以测试在移动网络下，应用的表现是否正常。Charles 对此需求提供了很好的支持。 在 Charles 的菜单上，选择 “Proxy”-&gt;”Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图所示： 如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 “Only for selected hosts” 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。 修改网络请求内容有些时候为了调试服务器的接口，我们需要反复尝试不同参数的网络请求。Charles 可以方便地提供网络请求的修改和重发功能。只需要在以往的网络请求上点击右键，选择 “Edit”，即可创建一个可编辑的网络请求。如下所示： 给服务器做压力测试我们可以使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力，方法如下。 我们在想打压的网络请求上（POST 或 GET 请求均可）右击，然后选择 「Repeat Advanced」菜单项，如下所示： 接着我们就可以在弹出的对话框中，选择打压的并发线程数以及打压次数，确定之后，即可开始打压。 悄悄说一句，一些写得很弱的投票网站，也可以用这个办法来快速投票。当然，我也可以用 Charles 的 Repeat 功能给一些诈骗的钓鱼网站喂了不少垃圾数据。 修改服务器返回内容有些时候我们想让服务器返回一些指定的内容，方便我们调试一些特殊情况。例如列表页面为空的情况，数据异常的情况，部分耗时的网络请求超时的情况等。如果没有 Charles，要服务器配合构造相应的数据显得会比较麻烦。这个时候，使用 Charles 相关的功能就可以满足我们的需求。 根据具体的需求，Charles 提供了 Map 功能、 Rewrite 功能以及 Breakpoints 功能，都可以达到修改服务器返回内容的目的。这三者在功能上的差异是： Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。 Rewrite 功能适合对网络请求进行一些正则替换。 Breakpoints 功能适合做一些临时性的修改。 Map 功能Charles 的 Map 功能分 Map Remote 和 Map Local 两种。顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。 在 Charles 的菜单中，选择 “Tools”-&gt;”Map Remote” 或 “Map Local” 即可进入到相应功能的设置页面。也可以选中一个请求，右击选择对应的操作。 对于 Map Remote 功能，我们需要分别填写网络重定向的源地址和目的地址，对于不需要限制的条件，可以留空。下图是一个示例，我将所有 dev.ifeixiu.com（测试服务器）的请求重定向到了 ifeixiu.com（线上服务器）。 对于 Map Local 功能，我们需要填写的重定向的源地址和本地的目标文件。对于有一些复杂的网络请求结果，我们可以先使用 Charles 提供的 “Save Response…” 功能，将请求结果保存到本地，然后稍加修改，成为我们的目标映射文件。 下图是一个示例，我将一个指定的网络请求通过 Map Local 功能映射到了本地的一个经过修改的文件中。 Map Local 在使用的时候，有一个潜在的问题，就是其返回的 Http Response Header 与正常的请求并不一样。这个时候如果客户端校验了 Http Response Header 中的部分内容，就会使得该功能失效。解决办法是同时使用 Map Local 以下面提到的 Rewrite 功能，将相关的 Http 头 Rewrite 成我们希望的内容。 Rewrite 功能Rewrite 功能功能适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。 Breakpoints 功能上面提供的 Rewrite 功能最适合做批量和长期的替换，但是很多时候，我们只是想临时修改一次网络请求结果，这个时候，使用 Rewrite 功能虽然也可以达到目的，但是过于麻烦，对于临时性的修改，我们最好使用 Breakpoints 功能。 Breakpoints 功能类似我们在 Xcode 中设置的断点一样，当指定的网络请求发生时，Charles 会截获该请求，这个时候，我们可以在 Charles 中临时修改网络请求的返回内容。 需要注意的是，使用 Breakpoints 功能将网络请求截获并修改过程中，整个网络请求的计时并不会暂停，所以长时间的暂停可能导致客户端的请求超时。 反向代理Charles 的反向代理功能允许我们将本地的端口映射到远程的另一个端口上。 设置外部代理，解决与翻墙软件的冲突Charles 的原理是把自己设置成系统的代理服务器，但是在中国，由于工作需要，我们常常需要使用 Google 搜索，所以大部分程序员都有自己的翻墙软件，而这些软件的基本原理，也是把自己设置成系统的代理服务器，来做到透明的翻墙。 为了使得两者能够和平共处，我们可以在 Charles 的 External Proxy Settings 中，设置翻墙的代理端口以及相关信息。同时，我们也要关闭相关翻墙软件的自动设置，使其不主动修改系统代理，避免 Charles 失效。 总结通过 Charles 软件，我们可以很方便地在日常开发中，截取和调试网络请求内容，分析封包协议以及模拟慢速网络。用好 Charles 可以极大的方便我们对于带有网络请求的 App 的开发和调试。","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"cocoapods安装及使用","slug":"cocoapods安装及使用","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T09:22:31.375Z","comments":true,"path":"2019/04/23/cocoapods安装及使用/","link":"","permalink":"https://bigporo.github.io/2019/04/23/cocoapods安装及使用/","excerpt":"参考文档 参考文档 CocoaPods 简介每种语言发展到一个阶段，就会出现相应的依赖管理工具，例如 Java 语言的 Maven，nodejs 的 npm。随着 iOS 开发者的增多，业界也出现了为 iOS 程序提供依赖管理的工具，它的名字叫做：CocoaPods。 CocoaPods项目的源码 在 Github 上管理。该项目开始于 2011 年 8 月 12 日，经过多年发展，现在已经成为 iOS 开发事实上的依赖管理标准工具。开发 iOS 项目不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。","text":"参考文档 参考文档 CocoaPods 简介每种语言发展到一个阶段，就会出现相应的依赖管理工具，例如 Java 语言的 Maven，nodejs 的 npm。随着 iOS 开发者的增多，业界也出现了为 iOS 程序提供依赖管理的工具，它的名字叫做：CocoaPods。 CocoaPods项目的源码 在 Github 上管理。该项目开始于 2011 年 8 月 12 日，经过多年发展，现在已经成为 iOS 开发事实上的依赖管理标准工具。开发 iOS 项目不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。 CocoaPods 的安装和使用介绍安装 升级 gem: 1sudo gem update --system 接下来输入系统密码就可以安装了，输入密码时不会显示的，输完回车就行了 另外，ruby 的软件源 https://rubygems.org 因为使用的是亚马逊的云服务，所以被墙了，需要更新一下 ruby 的源，使用如下代码将官方的 ruby 源替换成国内的源： 12gem sources --remove https://rubygems.org/gem sources --add https://gems.ruby-china.com/ 接下来查看下源路径是否更换了 1gem sources -l 如果是以下结果说明正确.123*** CURRENT SOURCES ***https://gems.ruby-china.com/ 这时候才正式开始安装CocoaPods1sudo gem install cocoapods 如果出现这个了,指的是你没有权限 输入这个1sudo gem install -n /usr/local/bin cocoapods 如果显示这个表示安装成功 安装本地库 1pod setup 执行以上命令后就是漫长的等待，当然,网络好的情况下会更快 123456Setting up CocoaPods master repo $ /usr/bin/git clone https://github.com/CocoaPods/Specs.git master --progress Cloning into &apos;master&apos;... remote: Counting objects: 1879515, done. remote: Compressing objects: 100% (321/321), done. Receiving objects: 21% (404525/1879515), 73.70 MiB | 22.00 KiB/ 要查看文件下载进度的可以另外打开一个终端窗口(快捷键:选中终端按下Command+N组合键)，输入以下两行命令回车执行 123cd ~/.cocoapodsdu -sh * 执行du -sh *之后会显示已下载的文件大小，可以多次执行来监看下载进度，如果之前还有文件大小，后来变成0了，可能是网络问题，下载已经中断了,需要结束命令并从新执行 pod setup 下载安装完成之后可执行下列命令检查是否可用（第一次使用可能要等一会）1pod search AFNetworking 结果是这样的就妥了(输入q回到终端控制界面) 使用 CocoaPods使用时需要新建一个名为 Podfile 的文件，以如下格式，将依赖的库名字依次列在文件中即可 1234platform :ios, &apos;7.0&apos;target &apos;demo&apos; dopod &apos;SDWebImage&apos;，end 然后你将编辑好的 Podfile 文件放到你的项目根目录中，执行如下命令即可： 12cd &quot;your project home&quot;pod install 现在，你的所有第三方库都已经下载完成并且设置好了编译参数和依赖，你只需要记住如下 2 点即可： 使用 CocoaPods 生成的 .xcworkspace 文件来打开工程，而不是以前的 .xcodeproj 文件。 每次更改了 Podfile 文件，你需要重新执行一次pod update命令。 可能会遇到的问题 当在终端输入,pod search AFNetworking可能会出现这种情况 这是因为之前pod search的时候生成了缓存文件search_index.json 1rm ~/Library/Caches/CocoaPods/search_index.json 来删除该文件然后再次输入pod search AFNetworking进行搜索这时会提示Creating search index for spec repo ‘master’.. 当运行pod 命令出现 1command not found 解决办法:1sudo gem install -n /usr/local/bin cocoapods 之后pod命令可以使用了 如果pod update / pod install 卡在：1Updating local specs repositories 等待即可，或者 可以使用 “pod install –verbose –no-repo-update” 进行下载，原因可能x被墙。 出现如下错误:12345678Cloning into &apos;master&apos;...remote: Enumerating objects: 395, done. remote: Counting objects: 100% (395/395), done. remote: Compressing objects: 100% (308/308), done. error: RPC failed; curl 56 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 60fatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 解决办法:1gem install rails 如下:1234Successfully installed rails-5.0.1Parsing documentation for rails-5.0.1Done installing documentation for rails after 0 seconds1 gem installed 然后继续:1pod setup 使用 CocoaPods 的镜像索引所有的项目的 Podspec 文件都托管在https://github.com/CocoaPods/Specs。第一次执行pod setup时，CocoaPods 会将这些podspec索引文件更新到本地的 ~/.cocoapods/目录下，这个索引文件比较大，有 80M 左右。所以第一次更新时非常慢。 一个叫 akinliu 的朋友在 gitcafe 和 oschina 上建立了 CocoaPods 索引库的镜像，因为 gitcafe 和 oschina 都是国内的服务器，所以在执行索引更新操作时，会快很多。如下操作可以将 CocoaPods 设置成使用 gitcafe 镜像：123pod repo remove masterpod repo add master https://gitcafe.com/akuandev/Specs.gitpod repo update 将以上代码中的 https://gitcafe.com/akuandev/Specs.git 替换成 http://git.oschina.net/akuandev/Specs.git 即可使用 oschina 上的镜像。 查找第三方库你如果不知道 cocoaPods 管理的库中，是否有你想要的库，那么你可以通过 pod search 命令进行查找，以下是我用 pod search json 查找到的所有可用的库： 123456789101112$ pod search json-&gt; AnyJSON (0.0.1) Encode / Decode JSON by any means possible. - Homepage: https://github.com/mattt/AnyJSON - Source: https://github.com/mattt/AnyJSON.git - Versions: 0.0.1 [master repo]-&gt; JSONKit (1.5pre) A Very High Performance Objective-C JSON Library. - Homepage: https://github.com/johnezang/JSONKit - Source: git://github.com/johnezang/JSONKit.git - Versions: 1.5pre, 1.4 [master repo]// ... 以下省略若干行 Podfile.lock当你执行pod install之后，除了 Podfile 外，CocoaPods 还会生成一个名为Podfile.lock的文件，Podfile.lock 应该加入到版本控制里面，不应该把这个文件加入到.gitignore中。因为Podfile.lock会锁定当前各依赖库的版本，之后如果多次执行pod install 不会更改版本，要pod update才会改Podfile.lock了。这样多人协作的时候，可以防止第三方库升级时造成大家各自的第三方库版本不一致。 CocoaPods 的这篇 官方文档 也在What is a Podfile.lock一节中介绍了Podfile.lock的作用，并且指出： This file should always be kept under version control. 为自己的项目创建 podspec 文件我们可以为自己的开源项目创建podspec文件，首先通过如下命令初始化一个podspec文件： 1pod spec create your_pod_spec_name 该命令执行之后，CocoaPods 会生成一个名为your_pod_spec_name.podspec的文件，然后我们修改其中的相关内容即可。 具体步骤可以参考这两篇博文中的相关内容： 创建 podspec 文件，给自己写的框架添加 CocoaPos 支持 创建podspec文件，为自己的项目添加pod支持 使用私有的 pods我们可以直接指定某一个依赖的podspec，这样就可以使用公司内部的私有库。该方案有利于使企业内部的公共项目支持 CocoaPods。如下是一个示例： 1pod &apos;MyCommon&apos;, :podspec =&gt; &apos;https://yuantiku.com/common/myCommon.podspec&apos; 不更新 podspecCocoaPods 在执行pod install和pod update时，会默认先更新一次podspec索引。使用–no-repo-update参数可以禁止其做索引更新操作。如下所示：12pod install --no-repo-updatepod update --no-repo-update 其他操作生成第三方库的帮助文档如果你想让 CococaPods 帮你生成第三方库的帮助文档，并集成到 Xcode 中，那么用 brew 安装 appledoc 即可：1brew install appledoc 关于 appledoc，唐巧在另一篇博客 《使用 Objective-C 的文档生成工具:appledoc》 中有专门介绍。它最大的优点是可以将帮助文档集成到 Xcode 中，这样你在敲代码的时候，按住 opt 键单击类名或方法名，就可以显示出相应的帮助文档。 原理&lt;巧神说的&gt;大概研究了一下 CocoaPods 的原理，它是将所有的依赖库都放到另一个名为 Pods 项目中，然后让主项目依赖 Pods 项目，这样，源码管理工作都从主项目移到了 Pods 项目中。发现的一些技术细节有： Pods 项目最终会编译成一个名为 libPods.a 的文件，主项目只需要依赖这个 .a 文件即可。 对于资源文件，CocoaPods 提供了一个名为 Pods-resources.sh 的 bash 脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。 CocoaPods 通过一个名为 Pods.xcconfig 的文件来在编译时设置所有的依赖和参数。","categories":[{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/categories/工具集/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"工具集","slug":"工具集","permalink":"https://bigporo.github.io/tags/工具集/"}]},{"title":"Runtime应用篇","slug":"Runtime应用篇","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T08:58:26.133Z","comments":true,"path":"2019/04/23/Runtime应用篇/","link":"","permalink":"https://bigporo.github.io/2019/04/23/Runtime应用篇/","excerpt":"前言Runtime简直就是做大型框架的利器。它的应用场景非常多，下面就介绍一些常见的应用场景。 关联对象(Objective-C Associated Objects)给分类增加属性 方法魔法(Method Swizzling)方法添加和替换和KVO实现 消息转发(热更新)解决Bug(JSPatch) 实现NSCoding的自动归档和自动解档 实现字典和模型的自动转换(MJExtension)","text":"前言Runtime简直就是做大型框架的利器。它的应用场景非常多，下面就介绍一些常见的应用场景。 关联对象(Objective-C Associated Objects)给分类增加属性 方法魔法(Method Swizzling)方法添加和替换和KVO实现 消息转发(热更新)解决Bug(JSPatch) 实现NSCoding的自动归档和自动解档 实现字典和模型的自动转换(MJExtension) 关联对象(Objective-C Associated Objects)我们都是知道分类是不能自定义属性和变量的。如果在分类的声明中写@property 只能为其生成get 和 set 方法的声明，但无法生成成员变量，就是虽然点语法能调用出来，但程序执行后会crash。 下面通过关联对象实现给分类添加属性。 关联对象Runtime提供了下面几个接口： 123456//关联对象void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)//获取关联的对象id objc_getAssociatedObject(id object, const void *key)//移除关联的对象void objc_removeAssociatedObjects(id object) 参数解释 1234id object：被关联的对象const void *key：关联的key，要求唯一id value：关联的对象objc_AssociationPolicy policy：内存管理的策略 通过关联对象实现的属性的内存管理也是有ARC管理的，所以我们只需要给定适当的内存策略就行了，不需要操心对象的释放。 内存管理策略 内存策略 属性修饰 描述 OBJC_ASSOCIATION_ASSIGN @property (assign) 或 @property (unsafe_unretained) 指定一个关联对象的弱引用。 OBJC_ASSOCIATION_RETAIN_NONATOMIC @property (nonatomic, strong) 指定一个关联对象的强引用，不能被原子化使用。 OBJC_ASSOCIATION_COPY_NONATOMIC @property (nonatomic, copy) 指定一个关联对象的copy引用，不能被原子化使用 OBJC_ASSOCIATION_RETAIN @property (atomic, strong) 指定一个关联对象的强引用，能被原子化使用。 OBJC_ASSOCIATION_COPY @property (atomic, copy) 指定一个关联对象的copy引用，能被原子化使用。 下面实现一个UIView的Category添加自定义属性defaultColor。 1234567891011121314151617181920212223242526272829303132333435363738394041#import &quot;ViewController.h&quot;#import &quot;objc/runtime.h&quot;@interface UIView (DefaultColor)@property (nonatomic, strong) UIColor *defaultColor;@end@implementation UIView (DefaultColor)@dynamic defaultColor;static char kDefaultColorKey;- (void)setDefaultColor:(UIColor *)defaultColor &#123;objc_setAssociatedObject(self, &amp;kDefaultColorKey, defaultColor, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (id)defaultColor &#123;return objc_getAssociatedObject(self, &amp;kDefaultColorKey);&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.UIView *test = [UIView new];test.defaultColor = [UIColor blackColor];NSLog(@&quot;%@&quot;, test.defaultColor);&#125;@end 方法魔法(Method Swizzling)方法添加12//class_addMethod(Class _Nullable __unsafe_unretained cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)class_addMethod([self class], sel, (IMP)fooMethod, &quot;v@:&quot;); 参数解释 cls 被添加方法的类 name 添加的方法的名称的SEL imp 方法的实现。该函数必须至少要有两个参数，self,_cmd 类型编码 方法替换12345678// 获得某个类的类方法Method class_getClassMethod(Class cls , SEL name)// 获得某个类的实例对象方法Method class_getInstanceMethod(Class cls , SEL name)// 交换两个方法的实现void method_exchangeImplementations(Method m1 , Method m2) 示例如下:1234567891011121314151617181920212223242526272829303132333435@implementation ViewController+ (void)load &#123;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;Class class = [self class];SEL originalSelector = @selector(viewDidLoad);SEL swizzledSelector = @selector(jkviewDidLoad);Method originalMethod = class_getInstanceMethod(class,originalSelector);Method swizzledMethod = class_getInstanceMethod(class,swizzledSelector);//judge the method named swizzledMethod is already existed.BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));// if swizzledMethod is already existed.if (didAddMethod) &#123;class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));&#125;else &#123;method_exchangeImplementations(originalMethod, swizzledMethod);&#125;&#125;);&#125;- (void)jkviewDidLoad &#123;NSLog(@&quot;替换的方法&quot;);[self jkviewDidLoad];&#125;- (void)viewDidLoad &#123;NSLog(@&quot;自带的方法&quot;);[super viewDidLoad];&#125; 在 Objective-C 的运行时中，每个类有两个方法都会自动调用。+load 是在一个类被初始装载时调用，+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。 实现图解如下图。 从图中可以看出，我们通过swizzling特性，将selectorC的方法实现IMPc与selectorN的方法实现IMPn交换了，当我们调用selectorC，也就是给对象发送selectorC消息时，所查找到的对应的方法实现就是IMPn而不是IMPc了。 KVO实现质量博客解读 全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。在MVC大行其道的Cocoa中，KVO机制很适合实现model和controller类之间的通讯。 KVO的实现依赖于 Objective-C 强大的 Runtime，当观察某对象 A 时，KVO 机制动态创建一个对象A当前类的子类，并为这个新的子类重写了被观察属性 keyPath 的 setter 方法。setter 方法随后负责通知观察对象属性的改变状况。 Apple 使用了 isa-swizzling 来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为：NSKVONotifying_A的新类，该类继承自对象A的本类，且 KVO 为 NSKVONotifying_A 重写观察属性的 setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。 所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对 KVO 的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类，就会发现系统运行到注册 KVO 的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为 NSKVONotifying_A 的中间类，并指向这个中间类了。 子类setter方法剖析 KVO 的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangeValueForKey: ，在存取数值的前后分别调用 2 个方法：被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该keyPath 的属性值已经变更；之后， observeValueForKey:ofObject:change:context:也会被调用。且重写观察属性的setter 方法这种继承方式的注入是在运行时而不是编译时实现的。KVO 为子类的观察者属性重写调用存取方法的工作原理在代码中相当于： 12345- (void)setName:(NSString *)newName &#123; [self willChangeValueForKey:@&quot;name&quot;]; //KVO 在调用存取方法之前总调用 [super setValue:newName forKey:@&quot;name&quot;]; //调用父类的存取方法 [self didChangeValueForKey:@&quot;name&quot;]; //KVO 在调用存取方法之后总调用&#125; 示例如下： 123456789101112131415161718- (void)dealloc&#123;[self.person removeObserver:self forKeyPath:@&quot;name&quot;];&#125;- (void)viewDidLoad &#123;[super viewDidLoad];self.person = [Person new];[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:@&quot;传个值？&quot;];&#125;#pragma mark KVO- (void)KVO&#123;self.person.name = @&quot;new name&quot;;&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;NSLog(@&quot;%@对象的%@属性改变了：%@,传值:%@&quot;, object, keyPath, change,context);&#125; 输出如下 1234&lt;Person: 0x600000907280&gt;对象的name属性改变了：&#123;kind = 1;new = &quot;new name&quot;;&#125;,传值:传个值？ 消息转发(热更新)解决Bug(JSPatch) JSPatch 是一个 iOS 动态更新框架，只需在项目中引入极小的引擎，就可以使用 JavaScript 调用任何 Objective-C 原生接口，获得脚本语言的优势：为项目动态添加模块，或替换项目原生代码动态修复 bug。 消息转发分为三级，我们可以在每级实现替换功能，实现消息转发，从而不会造成崩溃。JSPatch不仅能够实现消息转发，还可以实现方法添加、替换能一系列功能。 获得一个类的所有成员变量用runtime提供的函数遍历Model自身所有属性。 12345678910111213unsigned int outCount = 0;Ivar *ivars = class_copyIvarList([Person class], &amp;outCount);// 遍历所有成员变量for (int i = 0; i &lt; outCount; i++) &#123;// 取出i位置对应的成员变量Ivar ivar = ivars[i];const char *name = ivar_getName(ivar);const char *type = ivar_getTypeEncoding(ivar);NSLog(@&quot;成员变量名：%s 成员变量类型：%s&quot;,name,type);&#125;// 注意释放内存！free(ivars); 实现NSCoding的自动归档和自动解档原理描述：用runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。 核心方法：在Model的基类中重写方法： 12345678910111213141516171819202122- (id)initWithCoder:(NSCoder *)aDecoder &#123;if (self = [super init]) &#123;unsigned int outCount;Ivar * ivars = class_copyIvarList([self class], &amp;outCount);for (int i = 0; i &lt; outCount; i ++) &#123;Ivar ivar = ivars[i];NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];[self setValue:[aDecoder decodeObjectForKey:key] forKey:key];&#125;&#125;return self;&#125;- (void)encodeWithCoder:(NSCoder *)aCoder &#123;unsigned int outCount;Ivar * ivars = class_copyIvarList([self class], &amp;outCount);for (int i = 0; i &lt; outCount; i ++) &#123;Ivar ivar = ivars[i];NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];[aCoder encodeObject:[self valueForKey:key] forKey:key];&#125;&#125; 实现字典和模型的自动转换(MJExtension)原理描述：用runtime提供的函数遍历Model自身所有属性，如果属性在json中有对应的值，则将其赋值。核心方法：在NSObject的分类中添加方法12345678910111213141516171819202122232425262728293031323334- (instancetype)initWithDict:(NSDictionary *)dict &#123;if (self = [self init]) &#123;//(1)获取类的属性及属性对应的类型NSMutableArray * keys = [NSMutableArray array];NSMutableArray * attributes = [NSMutableArray array];/** 例子* name = value3 attribute = T@&quot;NSString&quot;,C,N,V_value3* name = value4 attribute = T^i,N,V_value4*/unsigned int outCount;objc_property_t * properties = class_copyPropertyList([self class], &amp;outCount);for (int i = 0; i &lt; outCount; i ++) &#123;objc_property_t property = properties[i];//通过property_getName函数获得属性的名字NSString * propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding];[keys addObject:propertyName];//通过property_getAttributes函数可以获得属性的名字和@encode编码NSString * propertyAttribute = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding];[attributes addObject:propertyAttribute];&#125;//立即释放properties指向的内存free(properties);//(2)根据类型给属性赋值for (NSString * key in keys) &#123;if ([dict valueForKey:key] == nil) continue;[self setValue:[dict valueForKey:key] forKey:key];&#125;&#125;return self;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"}]},{"title":"《iOS开发进阶》读书总结","slug":"《iOS开发进阶》读书总结","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T09:11:17.557Z","comments":true,"path":"2019/04/23/《iOS开发进阶》读书总结/","link":"","permalink":"https://bigporo.github.io/2019/04/23/《iOS开发进阶》读书总结/","excerpt":"iOS开发工具","text":"iOS开发工具 依赖包管理工具-CocoapPodshttp://note.youdao.com/noteshare?id=afbf57911d0ba85e6ae7073d6c8b2c83 网络封包分析工具-Charleshttp://note.youdao.com/noteshare?id=c758ee77fa20a7888e89d035dec8906a 界面调试工具-Revealhttp://note.youdao.com/noteshare?id=b06327cef4d357e2da55bd1cfe33cb7c 移动统计工具Flurry现在咱用友盟了 崩溃日志记录工具-Crashlytics现在用的是Bugtags App Store统计工具-App Annie现在的App Store Connect 做的还可以的。 Xcode 插件最新的Xcode 10 已经不支持这些花里胡哨(很实用)的东西了。 不过Apple将一些优秀的插件直接集成到Xcode里面了。比如: 快速添加注释1⌥ Option + ⌘ Command + / 该快捷键的前生是喵神的VVDocumenter-Xcode 其它工具介绍取色器基操 其它图形工具ImageOptimhttp://note.youdao.com/noteshare?id=60cd5fb3f8e7b20e6a4663946e52daa3 马克鳗主要是用来标注设计图的。官网 Dash是一款API文档查询及代码片段管理的工具。 蒲公英是一个应用的内测分发工具，使用频率还是蛮高的，具体的使用文档见官网。 命令行工具nomad工具主页：https://nomad-cli.com/ 不过现在好像faltlane更加好用。 xctool工具主页：https://github.com/facebook/xctool 参考博客 xctool是 facebook 开源的一个 iOS 编译和测试的工具。使用它而不是用 Xcode 的 UI 界面是因为它是一个纯命令行工具。比如：我们可以使用 xctool 在命令生下进行编译和单元测试，然后将测试结果集成到 Jenkins 中，这样就实现了自动化的持续集成。虽然苹果也在 OSX Server 上推出了自己的自动化集成工具 BOT，但其配置和使用上现在仍然不太方便。 appledoc是一个从源代码中抽取文档的工具工具主页：https://github.com/tomaz/appledoc 使用教程 iOS开发实践理解内存管理循环引用的监测大部分内容都是广为人知的，网上的资料也很多，这里着重说一下通过Xcoded的Instruments工具集来监测循环引用。 数组A和数组B构成了循环引用 12345678910- (void)viewDidLoad &#123;[super viewDidLoad];// 测试循环引用的监测NSMutableArray *arrA = [NSMutableArray new];NSMutableArray *arrB = [NSMutableArray new];[arrA addObject:arrB];[arrB addObject:arrA];&#125; Xcode的菜单栏 -&gt; Product -&gt; Profile 点击右上角开始监测 点击切换到”Leaks”,点击选中”Cycles &amp; Roots”就可以看到循环引用了，也可以很方便的找到源头。 Core Foundation对象的内存管理Core Foundation对象需要我们手动管理其内存 GCD书中也只是说了一些GCD的常用API，并不涉及底层源码和实现原理。 使用UIWindow可以参考这篇文章 动态下载系统提供的多种中文字体操作不难，可以参考这篇文章，书中的说明也很详细。 使用应用内支付可以参考这篇文章 基于UIWebView的混合编程现在基本都是WKWebView，但是基本原理相似。 安全性问题网络安全 安全的传输用户密码 主要是加密 防止通讯协议被轻易破解 使用二进制通讯协议或者自定义通讯协议 验证应用内支付的凭证本地文件和数据安全 程序文件的安全 将JavaScript源码进行混淆和加密。 本地数据安全 本地的重要数据需要加密或者保存到keychian中 源代码安全通过一些工具可以分析编译之后的二进制程序文件，比如IDA。这种情况比较无解，除非将一些关键的逻辑使用C来实现。 基于CoreText的排版引擎主要介绍如何基本CoreText自定义一个排版引擎。 实战技巧App Store与审核 撤销正在审核的应用 申请加急审核 测试设备数的限制 如何将应用下架 如何举报别的应用侵权开发技巧 大部分比较熟知，单独提几点： 查找技巧 Xcode的查找替换功能提供了Insert Pattern的方式，方便输入常见的查找规则。 代码片段管理 点击可以看到系统提供的一些代码片段，我们也可以自己自定义代码片段。 选中代码库，右击选择”Create Code Snippet“,就可以将其保存。如果有些地方想要替换掉，使用&lt;#被替换的内容#&gt;的格式，这样代码片段带使用后，焦点会自动移到此处。 自定义的代码片段保存在 ~/Library/Developer/Xcode/UserData/CodeSnippets/ 目录下，可以将其设置为Git仓库，然后将代码片段都放在Github上，方便管理。 iOS底层开发原理Objective-C对象模型isa指针 Objective-C是一门面向对象的语音，所有的对象都是一个类的实例，每一个对象都有一个isa指针，指向该对象的类。每一个类描述了它的实例的特点，包括成员变量的的列表，成员函数的列表等。 类也是一个对象，所以是另一个类的实例，这个类就是元类。元类保存了类方法列表，当一个类方法被调用的时候，元类会首先查找它自身是否有该方法的时候，没有的话就会向其父类查找方法，这样可以一直找到继承链的头。 元类也是对象，其isa指针指向根元类。根元类的isa指针指向自己，这样就形成了一个闭环。 类的成员变量 对象在内存中的排布可以看成一个结构体，该结构体的大小不能动态变化，所以无法再运行时动态的添加成员变量。 方法的定义列表是一个名为methodLists的指针的指针，通过修改该指针指向的指针的值，可以动态的为某个类增加成员方法，这也是分类的实现原理。 isa本身也是指针，我们可以动态的修改指针的值，达到替换对象整个行为的目的，不过用的较少。 对象模型的应用这一小节简单介绍了一些Runtime的应用，具体查看这篇笔记。 Tagged Pointer对象背景假设要存储一个NSNumber对象，其值是一个整数。正常情况下，如果这个整数只是一个NSInteger的普通变量，那么它所占用的内存是与CPU的位数有关，在32位CPU下占4个字节，在64位CPU下是占8个字节的。而指针类型的大小通常也是与CPU位数相关，一个指针所占用的内存在32位CPU下为4个字节，在64位CPU下也是8个字节。所以一个普通的iOS程序，如果没有Tagged Pointer对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但这种NSNumber、NSDate一类的对象所占用的内存会翻倍。 原理把指针指向的内容直接放在了指针变量的内存地址中，因为在 64 位环境下指针变量的大小达到了 8 位足以容纳一些长度较小的内容。于是使用了标签指针这种方式来优化数据的存储方式。从引用计数可以看出，这个是一个释放不掉的单例常量对象。在运行时根据实际情况创建。 Block对象模型巧哥的博客12345678struct Block_layout &#123;void *isa;int flags;int reserved;void (*invoke)(void *, ...);struct Block_descriptor *descriptor;/* Imported variables. */&#125;; 123456struct Block_descriptor &#123;unsigned long int reserved;unsigned long int size;void (*copy)(void *dst, void *src);void (*dispose)(void *);&#125;; 一个 block 实例实际上由 6 部分构成： isa 指针，所有对象都有该指针，用于实现对象相关的功能。 flags，用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用。 reserved，保留变量。 invoke，函数指针，指向具体的 block 实现的函数调用地址。 descriptor， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。 variables，capture 过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。","categories":[{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/categories/读书/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/tags/读书/"}]},{"title":"iOS各种设备信息获取总结","slug":"iOS各种设备信息获取总结","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T08:57:59.043Z","comments":true,"path":"2019/04/23/iOS各种设备信息获取总结/","link":"","permalink":"https://bigporo.github.io/2019/04/23/iOS各种设备信息获取总结/","excerpt":"为了统计用户信息、下发广告，服务器端往往需要手机用户设备及app的各种信息，下面讲述一下各种信息的获取方式：","text":"为了统计用户信息、下发广告，服务器端往往需要手机用户设备及app的各种信息，下面讲述一下各种信息的获取方式：直接上代码:1234567891011121314151617181920212223242526272829303132333435363738// 这个方法后面会列出来NSString *deviceName = [self getDeviceName];NSLog(@&quot;设备型号--&gt;%@&quot;, deviceName);NSString *iPhoneName = [UIDevice currentDevice].name;NSLog(@&quot;iPhone名称--&gt;%@&quot;, iPhoneName); NSString *appVerion = [[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleShortVersionString&quot;];NSLog(@&quot;app版本号--&gt;%@&quot;, appVerion);CGFloat batteryLevel = [[UIDevice currentDevice] batteryLevel];NSLog(@&quot;电池电量--&gt;%f&quot;, batteryLevel);NSString *localizedModel = [UIDevice currentDevice].localizedModel;NSLog(@&quot;localizedModel--&gt;%@&quot;, localizedModel);NSString *systemName = [UIDevice currentDevice].systemName;NSLog(@&quot;当前系统名称--&gt;%@&quot;, systemName);NSString *systemVersion = [UIDevice currentDevice].systemVersion;NSLog(@&quot;当前系统版本号--&gt;%@&quot;, systemVersion);struct utsname systemInfo;uname(&amp;systemInfo);NSString *device_model = [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];NSLog(@&quot;device_model--&gt;%@&quot;, device_model);// 这个方法后面会单独列出NSString *macAddress = [self getMacAddress];NSLog(@&quot;macAddress--&gt;%@&quot;, macAddress);// 这个方法后面会单独列出NSString *deviceIP = [self getDeviceIPAddresses];NSLog(@&quot;deviceIP--&gt;%@&quot;, deviceIP);// 设备上次重启的时间NSTimeInterval time = [[NSProcessInfo processInfo] systemUptime];NSDate *lastRestartDate = [[NSDate alloc] initWithTimeIntervalSinceNow:(0 - time)]; 广告位标识符在同一个设备上的所有App都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设的，用户可以在 设置|隐私|广告追踪里重置此id的值，或限制此id的使用，故此id有可能会取不到值，但好在Apple默认是允许追踪的，而且一般用户都不知道有这么个设置，所以基本上用来监测推广效果，是戳戳有余了。12NSString *idfa = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];NSLog(@&quot;广告位标识符idfa--&gt;%@&quot;, idfa); UUID是Universally Unique Identifier的缩写，中文意思是通用唯一识别码。它是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指 定。这样，每个人都可以建立不与其它人冲突的 UUID。在此情况下，就不需考虑数据库建立时的名称重复问题。苹果公司建议使用UUID为应用生成唯一标识字符串。 12NSString *uuid = [[[UIDevice currentDevice] identifierForVendor] UUIDString];NSLog(@&quot;唯一识别码uuid--&gt;%@&quot;, uuid); 获取设备型号123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 需要#import &quot;sys/utsname.h&quot;#warning 题主呕心沥血总结！！最全面！亲测！全网独此一份！！struct utsname systemInfo;uname(&amp;systemInfo);NSString *deviceString = [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];if ([deviceString isEqualToString:@&quot;iPhone3,1&quot;]) return @&quot;iPhone 4&quot;;if ([deviceString isEqualToString:@&quot;iPhone3,2&quot;]) return @&quot;iPhone 4&quot;;if ([deviceString isEqualToString:@&quot;iPhone3,3&quot;]) return @&quot;iPhone 4&quot;;if ([deviceString isEqualToString:@&quot;iPhone4,1&quot;]) return @&quot;iPhone 4S&quot;;if ([deviceString isEqualToString:@&quot;iPhone5,1&quot;]) return @&quot;iPhone 5&quot;;if ([deviceString isEqualToString:@&quot;iPhone5,2&quot;]) return @&quot;iPhone 5 (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPhone5,3&quot;]) return @&quot;iPhone 5c (GSM)&quot;;if ([deviceString isEqualToString:@&quot;iPhone5,4&quot;]) return @&quot;iPhone 5c (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPhone6,1&quot;]) return @&quot;iPhone 5s (GSM)&quot;;if ([deviceString isEqualToString:@&quot;iPhone6,2&quot;]) return @&quot;iPhone 5s (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPhone7,1&quot;]) return @&quot;iPhone 6 Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone7,2&quot;]) return @&quot;iPhone 6&quot;;if ([deviceString isEqualToString:@&quot;iPhone8,1&quot;]) return @&quot;iPhone 6s&quot;;if ([deviceString isEqualToString:@&quot;iPhone8,2&quot;]) return @&quot;iPhone 6s Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone8,4&quot;]) return @&quot;iPhone SE&quot;;// 日行两款手机型号均为日本独占，可能使用索尼FeliCa支付方案而不是苹果支付if ([deviceString isEqualToString:@&quot;iPhone9,1&quot;]) return @&quot;国行、日版、港行iPhone 7&quot;;if ([deviceString isEqualToString:@&quot;iPhone9,2&quot;]) return @&quot;港行、国行iPhone 7 Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone9,3&quot;]) return @&quot;美版、台版iPhone 7&quot;;if ([deviceString isEqualToString:@&quot;iPhone9,4&quot;]) return @&quot;美版、台版iPhone 7 Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,1&quot;]) return @&quot;国行(A1863)、日行(A1906)iPhone 8&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,4&quot;]) return @&quot;美版(Global/A1905)iPhone 8&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,2&quot;]) return @&quot;国行(A1864)、日行(A1898)iPhone 8 Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,5&quot;]) return @&quot;美版(Global/A1897)iPhone 8 Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,3&quot;]) return @&quot;国行(A1865)、日行(A1902)iPhone X&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,6&quot;]) return @&quot;美版(Global/A1901)iPhone X&quot;;if ([deviceString isEqualToString:@&quot;iPhone11,2&quot;]) return @&quot;iPhone XS&quot;;if ([deviceString isEqualToString:@&quot;iPhone11,4&quot;]) return @&quot;iPhone XS Max&quot;;if ([deviceString isEqualToString:@&quot;iPhone11,6&quot;]) return @&quot;iPhone XS Max&quot;;if ([deviceString isEqualToString:@&quot;iPhone11,8&quot;]) return @&quot;iPhone XR&quot;;if ([deviceString isEqualToString:@&quot;iPod1,1&quot;]) return @&quot;iPod Touch 1G&quot;;if ([deviceString isEqualToString:@&quot;iPod2,1&quot;]) return @&quot;iPod Touch 2G&quot;;if ([deviceString isEqualToString:@&quot;iPod3,1&quot;]) return @&quot;iPod Touch 3G&quot;;if ([deviceString isEqualToString:@&quot;iPod4,1&quot;]) return @&quot;iPod Touch 4G&quot;;if ([deviceString isEqualToString:@&quot;iPod5,1&quot;]) return @&quot;iPod Touch (5 Gen)&quot;;if ([deviceString isEqualToString:@&quot;iPad1,1&quot;]) return @&quot;iPad&quot;;if ([deviceString isEqualToString:@&quot;iPad1,2&quot;]) return @&quot;iPad 3G&quot;;if ([deviceString isEqualToString:@&quot;iPad2,1&quot;]) return @&quot;iPad 2 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad2,2&quot;]) return @&quot;iPad 2&quot;;if ([deviceString isEqualToString:@&quot;iPad2,3&quot;]) return @&quot;iPad 2 (CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPad2,4&quot;]) return @&quot;iPad 2&quot;;if ([deviceString isEqualToString:@&quot;iPad2,5&quot;]) return @&quot;iPad Mini (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad2,6&quot;]) return @&quot;iPad Mini&quot;;if ([deviceString isEqualToString:@&quot;iPad2,7&quot;]) return @&quot;iPad Mini (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPad3,1&quot;]) return @&quot;iPad 3 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad3,2&quot;]) return @&quot;iPad 3 (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPad3,3&quot;]) return @&quot;iPad 3&quot;;if ([deviceString isEqualToString:@&quot;iPad3,4&quot;]) return @&quot;iPad 4 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad3,5&quot;]) return @&quot;iPad 4&quot;;if ([deviceString isEqualToString:@&quot;iPad3,6&quot;]) return @&quot;iPad 4 (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,1&quot;]) return @&quot;iPad Air (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,2&quot;]) return @&quot;iPad Air (Cellular)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,4&quot;]) return @&quot;iPad Mini 2 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,5&quot;]) return @&quot;iPad Mini 2 (Cellular)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,6&quot;]) return @&quot;iPad Mini 2&quot;;if ([deviceString isEqualToString:@&quot;iPad4,7&quot;]) return @&quot;iPad Mini 3&quot;;if ([deviceString isEqualToString:@&quot;iPad4,8&quot;]) return @&quot;iPad Mini 3&quot;;if ([deviceString isEqualToString:@&quot;iPad4,9&quot;]) return @&quot;iPad Mini 3&quot;;if ([deviceString isEqualToString:@&quot;iPad5,1&quot;]) return @&quot;iPad Mini 4 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad5,2&quot;]) return @&quot;iPad Mini 4 (LTE)&quot;;if ([deviceString isEqualToString:@&quot;iPad5,3&quot;]) return @&quot;iPad Air 2&quot;;if ([deviceString isEqualToString:@&quot;iPad5,4&quot;]) return @&quot;iPad Air 2&quot;;if ([deviceString isEqualToString:@&quot;iPad6,3&quot;]) return @&quot;iPad Pro 9.7&quot;;if ([deviceString isEqualToString:@&quot;iPad6,4&quot;]) return @&quot;iPad Pro 9.7&quot;;if ([deviceString isEqualToString:@&quot;iPad6,7&quot;]) return @&quot;iPad Pro 12.9&quot;;if ([deviceString isEqualToString:@&quot;iPad6,8&quot;]) return @&quot;iPad Pro 12.9&quot;;if ([deviceString isEqualToString:@&quot;iPad6,11&quot;]) return @&quot;iPad 5 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad6,12&quot;]) return @&quot;iPad 5 (Cellular)&quot;;if ([deviceString isEqualToString:@&quot;iPad7,1&quot;]) return @&quot;iPad Pro 12.9 inch 2nd gen (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad7,2&quot;]) return @&quot;iPad Pro 12.9 inch 2nd gen (Cellular)&quot;;if ([deviceString isEqualToString:@&quot;iPad7,3&quot;]) return @&quot;iPad Pro 10.5 inch (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad7,4&quot;]) return @&quot;iPad Pro 10.5 inch (Cellular)&quot;;if ([deviceString isEqualToString:@&quot;iPad7,5&quot;]) return @&quot;iPad 6th generation&quot;;if ([deviceString isEqualToString:@&quot;iPad7,6&quot;]) return @&quot;iPad 6th generation&quot;;if ([deviceString isEqualToString:@&quot;iPad8,1&quot;]) return @&quot;iPad Pro (11-inch)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,2&quot;]) return @&quot;iPad Pro (11-inch)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,3&quot;]) return @&quot;iPad Pro (11-inch)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,4&quot;]) return @&quot;iPad Pro (11-inch)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,5&quot;]) return @&quot;iPad Pro (12.9-inch) (3rd generation)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,6&quot;]) return @&quot;iPad Pro (12.9-inch) (3rd generation)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,7&quot;]) return @&quot;iPad Pro (12.9-inch) (3rd generation)&quot;;if ([deviceString isEqualToString:@&quot;iPad8,8&quot;]) return @&quot;iPad Pro (12.9-inch) (3rd generation)&quot;;if ([deviceString isEqualToString:@&quot;AppleTV2,1&quot;]) return @&quot;Apple TV 2&quot;;if ([deviceString isEqualToString:@&quot;AppleTV3,1&quot;]) return @&quot;Apple TV 3&quot;;if ([deviceString isEqualToString:@&quot;AppleTV3,2&quot;]) return @&quot;Apple TV 3&quot;;if ([deviceString isEqualToString:@&quot;AppleTV5,3&quot;]) return @&quot;Apple TV 4&quot;;if ([deviceString isEqualToString:@&quot;i386&quot;]) return @&quot;Simulator&quot;;if ([deviceString isEqualToString:@&quot;x86_64&quot;]) return @&quot;Simulator&quot;;return deviceString;&#125; 获取 iPhone 设备颜色/外壳颜色12345678910111213141516#warning 该方法是私有API，上线会被拒// 由于每款手机同一颜色具体色号不一样，如 iPhone 6和 iPhone SE粉色的两个具体色值是不一样的，因此在这里只能返回一个色号UIDevice *device = [UIDevice currentDevice];SEL selector = NSSelectorFromString(@&quot;deviceInfoForKey:&quot;);if (![device respondsToSelector:selector]) &#123;selector = NSSelectorFromString(@&quot;_deviceInfoForKey:&quot;);&#125;if ([device respondsToSelector:selector]) &#123;// 消除警告“performSelector may cause a leak because its selector is unknown”IMP imp = [device methodForSelector:selector];NSString * (*func)(id, SEL, NSString *) = (void *)imp;NSString *deviceColor = func(device, selector, @&quot;DeviceColor&quot;);NSString *deviceEnclosureColor = func(device, selector, @&quot;DeviceEnclosureColor&quot;);NSLog(@&quot;deviceColor --&gt; %@ \\n @&quot;deviceEnclosureColor --&gt; %@ &quot;, deviceColor, deviceEnclosureColor);&#125; mac 地址12345678910111213141516171819202122232425262728293031323334353637383940414243- (NSString *)getMacAddress &#123;int mib[6];size_t len;char *buf;unsigned char *ptr;struct if_msghdr *ifm;struct sockaddr_dl *sdl;mib[0] = CTL_NET;mib[1] = AF_ROUTE;mib[2] = 0;mib[3] = AF_LINK;mib[4] = NET_RT_IFLIST;if ((mib[5] = if_nametoindex(&quot;en0&quot;)) == 0) &#123;printf(&quot;Error: if_nametoindex error/n&quot;);return NULL;&#125;if (sysctl(mib, 6, NULL, &amp;len, NULL, 0) &lt; 0) &#123;printf(&quot;Error: sysctl, take 1/n&quot;);return NULL;&#125;if ((buf = malloc(len)) == NULL) &#123;printf(&quot;Could not allocate memory. error!/n&quot;);return NULL;&#125;if (sysctl(mib, 6, buf, &amp;len, NULL, 0) &lt; 0) &#123;printf(&quot;Error: sysctl, take 2&quot;);return NULL;&#125;ifm = (struct if_msghdr *)buf;sdl = (struct sockaddr_dl *)(ifm + 1);ptr = (unsigned char *)LLADDR(sdl);NSString *outstring = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x&quot;, *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)];free(buf);return [outstring uppercaseString];&#125; IP地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354- (NSString *)getDeviceIPAddresses &#123;int sockfd = socket(AF_INET, SOCK_DGRAM, 0);NSMutableArray *ips = [NSMutableArray array];int BUFFERSIZE = 4096;struct ifconf ifc;char buffer[BUFFERSIZE], *ptr, lastname[IFNAMSIZ], *cptr;struct ifreq *ifr, ifrcopy;ifc.ifc_len = BUFFERSIZE;ifc.ifc_buf = buffer;if (ioctl(sockfd, SIOCGIFCONF, &amp;ifc) &gt;= 0)&#123;for (ptr = buffer; ptr &lt; buffer + ifc.ifc_len; )&#123;ifr = (struct ifreq *)ptr;int len = sizeof(struct sockaddr);if (ifr-&gt;ifr_addr.sa_len &gt; len) &#123;len = ifr-&gt;ifr_addr.sa_len;&#125;ptr += sizeof(ifr-&gt;ifr_name) + len;if (ifr-&gt;ifr_addr.sa_family != AF_INET) continue;if ((cptr = (char *)strchr(ifr-&gt;ifr_name, &apos;:&apos;)) != NULL) *cptr = 0;if (strncmp(lastname, ifr-&gt;ifr_name, IFNAMSIZ) == 0) continue;memcpy(lastname, ifr-&gt;ifr_name, IFNAMSIZ);ifrcopy = *ifr;ioctl(sockfd, SIOCGIFFLAGS, &amp;ifrcopy);if ((ifrcopy.ifr_flags &amp; IFF_UP) == 0) continue;NSString *ip = [NSString stringWithFormat:@&quot;%s&quot;, inet_ntoa(((struct sockaddr_in *)&amp;ifr-&gt;ifr_addr)-&gt;sin_addr)];[ips addObject:ip];&#125;&#125;close(sockfd);NSString *deviceIP = @&quot;&quot;;for (int i=0; i &lt; ips.count; i++) &#123;if (ips.count &gt; 0) &#123;deviceIP = [NSString stringWithFormat:@&quot;%@&quot;,ips.lastObject];&#125;&#125;return deviceIP;&#125; CPU12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// CPU总数目- (NSUInteger)getCPUCount &#123;return [NSProcessInfo processInfo].activeProcessorCount;&#125;// 已使用的CPU比例- (float)getCPUUsage &#123;float cpu = 0;NSArray *cpus = [self getPerCPUUsage];if (cpus.count == 0) return -1;for (NSNumber *n in cpus) &#123;cpu += n.floatValue;&#125;return cpu;&#125;// 获取每个cpu的使用比例- (NSArray *)getPerCPUUsage &#123;processor_info_array_t _cpuInfo, _prevCPUInfo = nil;mach_msg_type_number_t _numCPUInfo, _numPrevCPUInfo = 0;unsigned _numCPUs;NSLock *_cpuUsageLock;int _mib[2U] = &#123; CTL_HW, HW_NCPU &#125;;size_t _sizeOfNumCPUs = sizeof(_numCPUs);int _status = sysctl(_mib, 2U, &amp;_numCPUs, &amp;_sizeOfNumCPUs, NULL, 0U);if (_status)_numCPUs = 1;_cpuUsageLock = [[NSLock alloc] init];natural_t _numCPUsU = 0U;kern_return_t err = host_processor_info(mach_host_self(), PROCESSOR_CPU_LOAD_INFO, &amp;_numCPUsU, &amp;_cpuInfo, &amp;_numCPUInfo);if (err == KERN_SUCCESS) &#123;[_cpuUsageLock lock];NSMutableArray *cpus = [NSMutableArray new];for (unsigned i = 0U; i &lt; _numCPUs; ++i) &#123;Float32 _inUse, _total;if (_prevCPUInfo) &#123;_inUse = ((_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER])+ (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM])+ (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE]));_total = _inUse + (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE]);&#125; else &#123;_inUse = _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER] + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM] + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE];_total = _inUse + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE];&#125;[cpus addObject:@(_inUse / _total)];&#125;[_cpuUsageLock unlock];if (_prevCPUInfo) &#123;size_t prevCpuInfoSize = sizeof(integer_t) * _numPrevCPUInfo;vm_deallocate(mach_task_self(), (vm_address_t)_prevCPUInfo, prevCpuInfoSize);&#125;return cpus;&#125; else &#123;return nil;&#125;&#125; Disk磁盘空间123456789101112131415161718192021222324252627// 获取磁盘总空间- (int64_t)getTotalDiskSpace &#123;NSError *error = nil;NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&amp;error];if (error) return -1;int64_t space = [[attrs objectForKey:NSFileSystemSize] longLongValue];if (space &lt; 0) space = -1;return space;&#125;// 获取未使用的磁盘空间- (int64_t)getFreeDiskSpace &#123;NSError *error = nil;NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&amp;error];if (error) return -1;int64_t space = [[attrs objectForKey:NSFileSystemFreeSize] longLongValue];if (space &lt; 0) space = -1;return space;&#125;// 获取已使用的磁盘空间- (int64_t)getUsedDiskSpace &#123;int64_t totalDisk = [self getTotalDiskSpace];int64_t freeDisk = [self getFreeDiskSpace];if (totalDisk &lt; 0 || freeDisk &lt; 0) return -1;int64_t usedDisk = totalDisk - freeDisk;if (usedDisk &lt; 0) usedDisk = -1;return usedDisk;&#125; Memory内存相关数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 系统总内存空间- (int64_t)getTotalMemory &#123;int64_t totalMemory = [[NSProcessInfo processInfo] physicalMemory];if (totalMemory &lt; -1) totalMemory = -1;return totalMemory;&#125;// 活跃的内存,正在使用或者很短时间内被使用过- (int64_t)getActiveMemory &#123;mach_port_t host_port = mach_host_self();mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);vm_size_t page_size;vm_statistics_data_t vm_stat;kern_return_t kern;kern = host_page_size(host_port, &amp;page_size);if (kern != KERN_SUCCESS) return -1;kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);if (kern != KERN_SUCCESS) return -1;return vm_stat.active_count * page_size;&#125;// 最近使用过,但是目前处于不活跃状态的内存- (int64_t)getInActiveMemory &#123;mach_port_t host_port = mach_host_self();mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);vm_size_t page_size;vm_statistics_data_t vm_stat;kern_return_t kern;kern = host_page_size(host_port, &amp;page_size);if (kern != KERN_SUCCESS) return -1;kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);if (kern != KERN_SUCCESS) return -1;return vm_stat.inactive_count * page_size;&#125;// 空闲的内存空间- (int64_t)getFreeMemory &#123;mach_port_t host_port = mach_host_self();mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);vm_size_t page_size;vm_statistics_data_t vm_stat;kern_return_t kern;kern = host_page_size(host_port, &amp;page_size);if (kern != KERN_SUCCESS) return -1;kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);if (kern != KERN_SUCCESS) return -1;return vm_stat.free_count * page_size;&#125;// 已使用的内存空间- (int64_t)getUsedMemory &#123;mach_port_t host_port = mach_host_self();mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);vm_size_t page_size;vm_statistics_data_t vm_stat;kern_return_t kern;kern = host_page_size(host_port, &amp;page_size);if (kern != KERN_SUCCESS) return -1;kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);if (kern != KERN_SUCCESS) return -1;return page_size * (vm_stat.active_count + vm_stat.inactive_count + vm_stat.wire_count);&#125;// 用来存放内核和数据结构的内存,framework、用户级别的应用无法分配- (int64_t)getWiredMemory &#123;mach_port_t host_port = mach_host_self();mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);vm_size_t page_size;vm_statistics_data_t vm_stat;kern_return_t kern;kern = host_page_size(host_port, &amp;page_size);if (kern != KERN_SUCCESS) return -1;kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);if (kern != KERN_SUCCESS) return -1;return vm_stat.wire_count * page_size;&#125;// 可释放的内存空间：内存吃紧自动释放，针对大对象存放所需的大块内存空间- (int64_t)getPurgableMemory &#123;mach_port_t host_port = mach_host_self();mach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);vm_size_t page_size;vm_statistics_data_t vm_stat;kern_return_t kern;kern = host_page_size(host_port, &amp;page_size);if (kern != KERN_SUCCESS) return -1;kern = host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size);if (kern != KERN_SUCCESS) return -1;return vm_stat.purgeable_count * page_size;&#125; 作者：si1ence链接：https://www.jianshu.com/p/b23016bb97af來源：简书","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"}]},{"title":"RunLoop详解","slug":"RunLoop详解","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T08:58:09.617Z","comments":true,"path":"2019/04/23/RunLoop详解/","link":"","permalink":"https://bigporo.github.io/2019/04/23/RunLoop详解/","excerpt":"RunLoop 详解RunLoop的概念一般来讲，一个线程一次只能执行一个任务，在执行完一个任务之后线程就退出了。通过RunLoop,我们可以让一个线程可以随时处理任务而不退出。","text":"RunLoop 详解RunLoop的概念一般来讲，一个线程一次只能执行一个任务，在执行完一个任务之后线程就退出了。通过RunLoop,我们可以让一个线程可以随时处理任务而不退出。 通常的代码逻辑是这样的：1234567function loop()&#123;do &#123;var message = get_next_message();process_message(message);&#125; while (message != quit);&#125; 这种模型通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。 所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。 OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 RunLoop与线程之间的关系CFRunLoop 是基于 pthread 来管理的。 线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。RunLoop是可以嵌套的。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。 1234567891011121314151617181920212223242526272829303132333435363738/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;/// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock;/// 获取一个 pthread 对应的 RunLoop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;OSSpinLockLock(&amp;loopsLock);if (!loopsDic) &#123;// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。loopsDic = CFDictionaryCreateMutable();CFRunLoopRef mainLoop = _CFRunLoopCreate();CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);&#125;/// 直接从 Dictionary 里获取。CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));if (!loop) &#123;/// 取不到时，创建一个loop = _CFRunLoopCreate();CFDictionarySetValue(loopsDic, thread, loop);/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。_CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);&#125;OSSpinLockUnLock(&amp;loopsLock);return loop;&#125;CFRunLoopRef CFRunLoopGetMain() &#123;return _CFRunLoopGet(pthread_main_thread_np());&#125;CFRunLoopRef CFRunLoopGetCurrent() &#123;return _CFRunLoopGet(pthread_self());&#125; RunLoop提供的接口1#include &lt;CoreFoundation/CFRunLoop.h&gt; 在 CoreFoundation 里面关于 RunLoop 有5个类: CFRunLoopRef CFRunLoopModeRef CFRunLoopSourceRef CFRunLoopTimerRef CFRunLoopObserverRef 其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。 他们的关系如下: 一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 CFRunLoopSourceRef是事件产生的地方。Source有两个版本：Source0 和 Source1。 Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。 处理APP内部事件、APP自己负责管理(触发)，如UIEvent等 Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。 由RunLoop和内核管理，Mach Port 驱动，如CFMachPort,CFMessagePort CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入LoopkCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 TimerkCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 SourcekCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 上面的 Source/Timer/Observer 被统称为mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 RunLoop的ModeCFRunLoopMode 和 CFRunLoop 的结构大致如下： 12345678910111213141516struct __CFRunLoopMode &#123;CFStringRef _name; // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;CFMutableSetRef _sources0; // SetCFMutableSetRef _sources1; // SetCFMutableArrayRef _observers; // ArrayCFMutableArrayRef _timers; // Array...&#125;;struct __CFRunLoop &#123;CFMutableSetRef _commonModes; // SetCFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;CFRunLoopModeRef _currentMode; // Current Runloop ModeCFMutableSetRef _modes; // Set...&#125;; 这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。 应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为“Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。 有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop自动更新到所有具有”Common”属性的 Mode 里去。 CFRunLoop对外暴露的管理 Mode 接口只有下面2个: 12CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);CFRunLoopRunInMode(CFStringRef modeName, ...); Mode 暴露的管理 mode item 的接口有下面几个：123456CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); 你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。 苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。还有一个私有的Mode是UIInitializationRunLoopMode, 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。 同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。 RunLoop内部逻辑RunLoop 内部的逻辑大致如下: 其内部代码整理如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/// 用DefaultMode启动void CFRunLoopRun(void) &#123;CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);&#125;/// 用指定的Mode启动，允许设置RunLoop超时时间int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&#125;/// RunLoop的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;/// 首先根据modeName找到对应modeCFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);/// 如果mode里没有source/timer/observer, 直接返回。if (__CFRunLoopModeIsEmpty(currentMode)) return;/// 1. 通知 Observers: RunLoop 即将进入 loop。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);/// 内部函数，进入loop__CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;Boolean sourceHandledThisLoop = NO;int retVal = 0;do &#123;/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);/// 执行被加入的block__CFRunLoopDoBlocks(runloop, currentMode);/// 4. RunLoop 触发 Source0 (非port) 回调。sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);/// 执行被加入的block__CFRunLoopDoBlocks(runloop, currentMode);/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。if (__Source0DidDispatchPortLastTime) &#123;Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)if (hasMsg) goto handle_msg;&#125;/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。if (!sourceHandledThisLoop) &#123;__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);&#125;/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。/// • 一个基于 port 的Source 的事件。/// • 一个 Timer 到时间了/// • RunLoop 自身的超时时间到了/// • 被其他什么调用者手动唤醒__CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg&#125;/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);/// 收到消息，处理消息。handle_msg:/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。if (msg_is_timer) &#123;__CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())&#125; /// 9.2 如果有dispatch到main_queue的block，执行block。else if (msg_is_dispatch) &#123;__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);&#125; /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件else &#123;CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);if (sourceHandledThisLoop) &#123;mach_msg(reply, MACH_SEND_MSG, reply);&#125;&#125;/// 执行加入到Loop的block__CFRunLoopDoBlocks(runloop, currentMode);if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;/// 进入loop时参数说处理完事件就返回。retVal = kCFRunLoopRunHandledSource;&#125; else if (timeout) &#123;/// 超出传入参数标记的超时时间了retVal = kCFRunLoopRunTimedOut;&#125; else if (__CFRunLoopIsStopped(runloop)) &#123;/// 被外部调用者强制停止了retVal = kCFRunLoopRunStopped;&#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;/// source/timer/observer一个都没有了retVal = kCFRunLoopRunFinished;&#125;/// 如果没超时，mode里没空，loop也没被停止，那继续loop。&#125; while (retVal == 0);&#125;/// 10. 通知 Observers: RunLoop 即将退出。__CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&#125; 可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 RunLoop底层实现RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。 为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图： 苹果用 RunLoop 实现的功能首先我们可以看一下 App 启动后 RunLoop 的状态： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CFRunLoop &#123;current mode = kCFRunLoopDefaultModecommon modes = &#123;UITrackingRunLoopModekCFRunLoopDefaultMode&#125;common mode items = &#123;// source0 (manual)CFRunLoopSource &#123;order =-1, &#123;callout = _UIApplicationHandleEventQueue&#125;&#125;CFRunLoopSource &#123;order =-1, &#123;callout = PurpleEventSignalCallback &#125;&#125;CFRunLoopSource &#123;order = 0, &#123;callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;// source1 (mach port)CFRunLoopSource &#123;order = 0, &#123;port = 17923&#125;&#125;CFRunLoopSource &#123;order = 0, &#123;port = 12039&#125;&#125;CFRunLoopSource &#123;order = 0, &#123;port = 16647&#125;&#125;CFRunLoopSource &#123;order =-1, &#123;callout = PurpleEventCallback&#125;&#125;CFRunLoopSource &#123;order = 0, &#123;port = 2407,callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;CFRunLoopSource &#123;order = 0, &#123;port = 1c03,callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;CFRunLoopSource &#123;order = 0, &#123;port = 1b03,callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;CFRunLoopSource &#123;order = 1, &#123;port = 1903,callout = __IOMIGMachPortPortCallback&#125;&#125;// OvserverCFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entrycallout = _wrapRunLoopWithAutoreleasePoolHandler&#125;CFRunLoopObserver &#123;order = 0, activities = 0x20, // BeforeWaitingcallout = _UIGestureRecognizerUpdateObserver&#125;CFRunLoopObserver &#123;order = 1999000, activities = 0xa0, // BeforeWaiting | Exitcallout = _afterCACommitHandler&#125;CFRunLoopObserver &#123;order = 2000000, activities = 0xa0, // BeforeWaiting | Exitcallout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exitcallout = _wrapRunLoopWithAutoreleasePoolHandler&#125;// TimerCFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0,next fire date = 453098071 (-4421.76019 @ 96223387169499),callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;&#125;,modes ＝ &#123;CFRunLoopMode &#123;sources0 = &#123; /* same as &apos;common mode items&apos; */ &#125;,sources1 = &#123; /* same as &apos;common mode items&apos; */ &#125;,observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,timers = &#123; /* same as &apos;common mode items&apos; */ &#125;,&#125;,CFRunLoopMode &#123;sources0 = &#123; /* same as &apos;common mode items&apos; */ &#125;,sources1 = &#123; /* same as &apos;common mode items&apos; */ &#125;,observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,timers = &#123; /* same as &apos;common mode items&apos; */ &#125;,&#125;,CFRunLoopMode &#123;sources0 = &#123;CFRunLoopSource &#123;order = 0, &#123;callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;&#125;,sources1 = (null),observers = &#123;CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000,callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;)&#125;,timers = (null),&#125;,CFRunLoopMode &#123;sources0 = &#123;CFRunLoopSource &#123;order = -1, &#123;callout = PurpleEventSignalCallback&#125;&#125;&#125;,sources1 = &#123;CFRunLoopSource &#123;order = -1, &#123;callout = PurpleEventCallback&#125;&#125;&#125;,observers = (null),timers = (null),&#125;,CFRunLoopMode &#123;sources0 = (null),sources1 = (null),observers = (null),timers = (null),&#125;&#125;&#125; 可以看到，系统默认注册了5个Mode: kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。 UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。 GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。 kCFRunLoopCommonModes: 这是一个占位的Mode,带有Common标记的字符串，没有实际作用。 AutoreleasePoolApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 小结：AutoreleasePool是在RunLoop即将开始的时候创建，是在RunLoop即将休眠时候释放。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 事件响应苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 手势识别当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 PerformSelecter当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 关于GCD实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。 当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。 定时器NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop， 关于网络请求iOS 中，关于网络请求的接口自下至上有如下几层: 1234CFSocketCFNetwork -&gt;ASIHttpRequestNSURLConnection -&gt;AFNetworkingNSURLSession -&gt;AFNetworking2, Alamofire CFSocket 是最底层的接口，只负责 socket 通信。 CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。 NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。 NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。 下面主要介绍下 NSURLConnection 的工作过程。 通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。 当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。 NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。 RunLoop 的实际应用举例AFNetworkingAFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop： 123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;@autoreleasepool &#123;[[NSThread currentThread] setName:@&quot;AFNetworking&quot;];NSRunLoop *runLoop = [NSRunLoop currentRunLoop];[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];[runLoop run];&#125;&#125;+ (NSThread *)networkRequestThread &#123;static NSThread *_networkRequestThread = nil;static dispatch_once_t oncePredicate;dispatch_once(&amp;oncePredicate, ^&#123;_networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];[_networkRequestThread start];&#125;);return _networkRequestThread;&#125; RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。 12345678910- (void)start &#123;[self.lock lock];if ([self isCancelled]) &#123;[self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];&#125; else if ([self isReady]) &#123;self.state = AFOperationExecutingState;[self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];&#125;[self.lock unlock];&#125; 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。 AsyncDisplayKitAsyncDisplayKit是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下： UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。 排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。 其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。 为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。 ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。 TableView中实现平滑滚动延迟加载图片利用CFRunLoopMode的特性，可以将图片的加载放到NSDefaultRunLoopMode的mode里，这样在滚动UITrackingRunLoopMode这个mode时不会被加载而影响到。 12345UIImage *downloadedImage = ...;[self.avatarImageView performSelector:@selector(setImage:)withObject:downloadedImageafterDelay:0inModes:@[NSDefaultRunLoopMode]]; ibireme：深入理解RunLoop iOS线下分享《RunLoop》by 孙源@sunnyxx","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"}]},{"title":"Runtime原理篇","slug":"Runtime原理篇","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T08:58:15.610Z","comments":true,"path":"2019/04/23/Runtime原理篇/","link":"","permalink":"https://bigporo.github.io/2019/04/23/Runtime原理篇/","excerpt":"Runtime介绍 Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。 Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。了解 Runtime ，要先了解它的核心 - 消息传递 （Messaging）","text":"Runtime介绍 Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。 Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。了解 Runtime ，要先了解它的核心 - 消息传递 （Messaging） Runtime其实有两个版本: “modern” 和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统，只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中。而 macOS 较老的32位程序仍采用 Objective-C 1 中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。 Runtime 基本是用 C 和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在这里下到苹果维护的开源代码。苹果和GNU各自维护一个开源的 runtime 版本，这两个版本之间都在努力的保持一致。平时的业务中主要是使用官方Api，解决我们框架性的需求。高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但是OC并不能直接编译为汇编语言，而是要先转写为纯C语言再进行编译和汇编的操作，从OC到C语言的过渡就是由runtime来实现的。然而我们使用OC进行面向对象开发，而C语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。 Runtime消息传递一个对象的方法像这样[obj foo]，编译器转成消息发送objc_msgSend(obj, foo)，Runtime时执行的流程是这样的： 首先，通过obj的isa指针找到它的 class ; 在 class 的 method list 找 foo ; 如果 class 中没到 foo，继续往它的 superclass 中找 ; 一旦找到 foo 这个函数，就去执行它的实现IMP 。 但这种实现有个问题，效率低。但一个class 往往只有 20% 的函数会被经常调用，可能占总调用次数的 80% 。每个消息都需要遍历一次objc_method_list 并不合理。如果把经常被调用的函数缓存下来，那可以大大提高函数查询的效率。这也就是objc_class 中另一个重要成员objc_cache 做的事情 - 再找到foo 之后，把foo 的method_name 作为key ，method_imp作为value 给存起来。当再次收到foo 消息的时候，可以直接在cache 里找到，避免去遍历objc_method_list。从前面的源代码可以看到objc_cache是存在objc_class 结构体中的。objec_msgSend的方法定义如下： 1OBJC_EXPORT id objc_msgSend(id self, SEL op, ...) 那消息传递是怎么实现的呢？我们看看对象(object)，类(class)，方法(method)这几个的结构体： 1234567891011121314151617181920212223242526272829303132333435//对象struct objc_object &#123;Class isa OBJC_ISA_AVAILABILITY;&#125;;//类struct objc_class &#123;Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__Class super_class OBJC2_UNAVAILABLE;const char *name OBJC2_UNAVAILABLE;long version OBJC2_UNAVAILABLE;long info OBJC2_UNAVAILABLE;long instance_size OBJC2_UNAVAILABLE;struct objc_ivar_list *ivars OBJC2_UNAVAILABLE;struct objc_method_list **methodLists OBJC2_UNAVAILABLE;struct objc_cache *cache OBJC2_UNAVAILABLE;struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;//方法列表struct objc_method_list &#123;struct objc_method_list *obsolete OBJC2_UNAVAILABLE;int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__int space OBJC2_UNAVAILABLE;#endif/* variable length structure */struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;//方法struct objc_method &#123;SEL method_name OBJC2_UNAVAILABLE;char *method_types OBJC2_UNAVAILABLE;IMP method_imp OBJC2_UNAVAILABLE;&#125; 系统首先找到消息的接收对象，然后通过对象的isa找到它的类。 在它的类中查找method_list，是否有selector方法。 没有则查找父类的method_list。 找到对应的method，执行它的IMP。 转发IMP的return值。 消息传递用到的一些概念类对象(objc_class)Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。类对象(Class)是由程序员定义并在运行时由编译器创建的，它没有自己的实例变量，这里需要注意的是类的成员变量和实例方法列表是属于实例对象的，但其存储于类对象当中的。 1typedef struct objc_class *Class; 查看objc/runtime.h中objc_class结构体的定义如下： 12345678910111213141516struct objc_class &#123;Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__Class _Nullable super_class OBJC2_UNAVAILABLE;const char * _Nonnull name OBJC2_UNAVAILABLE;long version OBJC2_UNAVAILABLE;long info OBJC2_UNAVAILABLE;long instance_size OBJC2_UNAVAILABLE;struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE;struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE;struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE;struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; struct objc_class结构体定义了很多变量，通过命名不难发现，结构体里保存了指向父类的指针、类的名字、版本、实例大小、实例变量列表、方法列表、缓存、遵守的协议列表等，一个类包含的信息也不就正是这些吗？没错，类对象就是一个结构体struct objc_class，这个结构体存放的数据称为元数据(metadata)，该结构体的第一个成员变量也是isa指针，这就说明了Class本身其实也是一个对象，因此我们称之为类对象，类对象在编译期产生用于创建实例对象，是单例。 参数解析 isa指针是和Class同类型的objc_class结构指针，类对象的指针指向其所属的类，即元类。元类中存储着类对象的类方法，当访问某个类的类方法时会通过该isa指针从元类中寻找方法对应的函数指针。 super_class指针指向该类所继承的父类对象，如果该类已经是最顶层的根类(如NSObject或NSProxy), 则 super_class为NULL。 cache：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，但提高了调用的效率。 version：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。 protocols：当然可以看出这一个objc_protocol_list的指针。关于objc_protocol_list的结构体构成后面会讲。 获取类名 1const char * class_getName ( Class cls ); 动态创建类 12345678// 创建一个新类和元类Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes ); //如果创建的是root class，则superclass为Nil。extraBytes通常为0// 销毁一个类及其相关联的类void objc_disposeClassPair ( Class cls ); //在运行中还存在或存在子类实例，就不能够调用这个。// 在应用中注册由objc_allocateClassPair创建的类void objc_registerClassPair ( Class cls ); //创建了新类后，然后使用class_addMethod，class_addIvar函数为新类添加方法，实例变量和属性后再调用这个来注册类，再之后就能够用了。 实例(objc_object)实例对象是我们对类对象alloc或者new操作时所创建的，在这个过程中会拷贝实例所属的类的成员变量，但并不拷贝类定义的方法。调用实例方法时，系统会根据实例的isa指针去类的方法列表及父类的方法列表中寻找与消息对应的selector指向的方法。1234567/// Represents an instance of a class.struct objc_object &#123;Class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id; 另外我们常见的id类型，它是一个objc_object结构类型的指针。该类型的对象可以转换为任何一种对象，类似于C语言中void *指针类型的作用。其定义如下所示: 123/// A pointer to an instance of a class.typedef struct objc_object *id;#endif 对对象的类操作 123456// 返回给定对象的类名const char * object_getClassName ( id obj );// 返回对象的类Class object_getClass ( id obj );// 设置对象的类Class object_setClass ( id obj, Class cls ); 获取对象的类定义 12345678910111213// 获取已注册的类定义的列表int objc_getClassList ( Class *buffer, int bufferCount );// 创建并返回一个指向所有已注册类的指针列表Class * objc_copyClassList ( unsigned int *outCount );// 返回指定类的类定义Class objc_lookUpClass ( const char *name );Class objc_getClass ( const char *name );Class objc_getRequiredClass ( const char *name );// 返回指定类的元类Class objc_getMetaClass ( const char *name ); 动态创建对象 12345678// 创建类实例id class_createInstance ( Class cls, size_t extraBytes ); //会在heap里给类分配内存。这个方法和+alloc方法类似。// 在指定位置创建类实例id objc_constructInstance ( Class cls, void *bytes ); // 销毁类实例void * objc_destructInstance ( id obj ); //不会释放移除任何相关引用 元类(Meta Class)类对象中的元数据存储的都是如何创建一个实例的相关信息，那么类对象和类方法应该从哪里创建呢？就是从isa指针指向的结构体创建，类对象的isa指针指向的我们称之为元类(metaclass)，元类中保存了创建类对象以及类方法所需的所有信息，因此整个结构应该如下图所示: 通过上图我们可以看出整个体系构成了一个自闭环，struct objc_object结构体实例它的isa指针指向类对象，类对象的isa指针指向了元类，super_class指针指向了父类的类对象，而元类的super_class指针指向了父类的元类，那元类的isa指针又指向了自己。元类(Meta Class)是一个类对象的类。 操作函数 1234567// 获取类的父类Class class_getSuperclass ( Class cls );// 判断给定的Class是否是一个meta classBOOL class_isMetaClass ( Class cls );// 获取实例大小size_t class_getInstanceSize ( Class cls ); 属性(property)在Objective-C中，属性(property)和成员变量是不同的。那么，属性的本质是什么？它和成员变量之间有什么区别？简单来说属性是添加了存取方法的成员变量，也就是:1@property = ivar + getter + setter; 因此，我们每定义一个@property都会添加对应的ivar, getter和setter到类结构体objc_class中。具体来说，系统会在objc_ivar_list中添加一个成员变量的描述，然后在methodLists中分别添加setter和getter方法的描述。下面的objc_property_t是声明的属性的类型，是一个指向objc_property结构体的指针。 用法举例 123456789101112131415//遍历获取所有属性Property- (void) getAllProperty &#123;unsigned int propertyCount = 0;objc_property_t *propertyList = class_copyPropertyList([Person class], &amp;propertyCount);for (unsigned int i = 0; i &lt; propertyCount; i++ ) &#123;objc_property_t *thisProperty = propertyList[i];const char* propertyName = property_getName(*thisProperty);NSLog(@&quot;Person拥有的属性为: &apos;%s&apos;&quot;, propertyName);&#125;/** objc_property_t:/// An opaque type that represents an Objective-C declared property.typedef struct objc_property *objc_property_t;&#125; 另外，关于属性有一个objc_property_attribute_t结构体列表，objc_property_attribute_t结构体包含name和value，定义如下:1234typedef struct &#123;const char * _Nonnull name; /**&lt; The name of the attribute */const char * _Nonnull value; /**&lt; The value of the attribute (usually empty) */&#125; objc_property_attribute_t; 常用的属性如下： 属性类型 name值：T value：变化 编码类型 name值：C(copy) &amp;(strong) W(weak)空(assign) 等 value：无 非/原子性 name值：空(atomic) N(Nonatomic) value：无 变量名称 name值：V value：变化1234567891011@interface person : NSObjec&#123; NSString *_name; &#125; int main()&#123; objc_property_attribute_t nonatomic = &#123;&quot;N&quot;, &quot;&quot;&#125;; objc_property_attribute_t strong = &#123;&quot;&amp;&quot;, &quot;&quot;&#125;; objc_property_attribute_t type = &#123;&quot;T&quot;, &quot;@\\&quot;NSString\\&quot;&quot;&#125;; objc_property_attribute_t ivar = &#123;&quot;V&quot;, &quot;_name&quot;&#125;; objc_property_attribute_t attributes[] = &#123;nonatomic, strong, type, ivar&#125;; BOOL result = class_addProperty([person class], &quot;name&quot;, attributes, 4); &#125; 操作函数 12345678// 获取属性名const char * property_getName ( objc_property_t property );// 获取属性特性描述字符串const char * property_getAttributes ( objc_property_t property );// 获取属性中指定的特性char * property_copyAttributeValue ( objc_property_t property, const char *attributeName );// 获取属性的特性列表objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, unsigned int *outCount ); 成员变量(objc_ivar)Ivar: 实例变量类型，是一个指向objc_ivar结构体的指针 12/// An opaque type that represents an instance variable.typedef struct objc_ivar *Ivar; objc_ivar结构体的组成如下： 12345678- struct objc_ivar &#123;char * _Nullable ivar_name OBJC2_UNAVAILABLE;char * _Nullable ivar_type OBJC2_UNAVAILABLE;int ivar_offset OBJC2_UNAVAILABLE;#ifdef __LP64__int space OBJC2_UNAVAILABLE;#endif&#125; 这里我们注意第三个成员 ivar_offset。它表示基地址偏移字节。 操作函数 12345678910111213141516171819//成员变量操作函数// 修改类实例的实例变量的值Ivar object_setInstanceVariable ( id obj, const char *name, void *value );// 获取对象实例变量的值Ivar object_getInstanceVariable ( id obj, const char *name, void **outValue );// 返回指向给定对象分配的任何额外字节的指针void * object_getIndexedIvars ( id obj );// 返回对象中实例变量的值id object_getIvar ( id obj, Ivar ivar );// 设置对象中实例变量的值void object_setIvar ( id obj, Ivar ivar, id value );// 获取类成员变量的信息Ivar class_getClassVariable ( Class cls, const char *name );// 添加成员变量BOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types ); //这个只能够向在runtime时创建的类添加成员变量// 获取整个成员变量列表Ivar * class_copyIvarList ( Class cls, unsigned int *outCount ); //必须使用free()来释放这个数组. 成员变量列表(objc_ivar_list)在objc_class中，所有的成员变量、属性的信息是放在链表ivars中的。ivars是一个数组，数组中每个元素是指向Ivar(变量信息)的指针。 12345678struct objc_ivar_list &#123;int ivar_count OBJC2_UNAVAILABLE;#ifdef __LP64__int space OBJC2_UNAVAILABLE;#endif/* variable length structure */struct objc_ivar ivar_list[1] OBJC2_UNAVAILABLE;&#125; 例子，获取所有成员变量 123456789101112//遍历获取Person类所有的成员变量IvarList- (void) getAllIvarList &#123;unsigned int methodCount = 0;Ivar * ivars = class_copyIvarList([Person class], &amp;methodCount);for (unsigned int i = 0; i &lt; methodCount; i ++) &#123;Ivar ivar = ivars[i];const char * name = ivar_getName(ivar);const char * type = ivar_getTypeEncoding(ivar);NSLog(@&quot;Person拥有的成员变量的类型为%s，名字为 %s &quot;,type, name);&#125;free(ivars);&#125; Method(objc_method)objc_method 存储了方法名，方法类型和方法实现： 1234567891011runtime.h/// An opaque type that represents a method in a class definition.代表类定义中一个方法的不透明类型typedef struct objc_method *Method;struct objc_method &#123;SEL method_name;OBJC2_UNAVAILABLE;char *method_types; OBJC2_UNAVAILABLE;IMP method_imp; OBJC2_UNAVAILABLE;&#125; Method和我们平时理解的函数是一致的，就是表示能够独立完成一个功能的一段代码，比如： 1234- (void)logName&#123;NSLog(@&quot;name&quot;);&#125; 我们来看下objc_method这个结构体的内容： SEL method_name 方法名 char *method_types 方法类型，存储方法的参数类型和返回值类型 IMP method_imp 指向了方法的实现，本质是一个函数指针 简言之，Method = SEL + IMP + method_types，相当于在SEL和IMP之间建立了一个映射。 在这个结构体中，我们已经看到了SEL和IMP，说明SEL和IMP其实都是Method的属性。 操作函数 1234567891011121314151617181920212223242526// 调用指定方法的实现，返回的是方法实现时的返回，参数receiver不能为空，这个比method_getImplementation和method_getName快id method_invoke ( id receiver, Method m, ... );// 调用返回一个数据结构的方法的实现void method_invoke_stret ( id receiver, Method m, ... );// 获取方法名，希望获得方法明的C字符串，使用sel_getName(method_getName(method))SEL method_getName ( Method m );// 返回方法的实现IMP method_getImplementation ( Method m );// 获取描述方法参数和返回值类型的字符串const char * method_getTypeEncoding ( Method m );// 获取方法的返回值类型的字符串char * method_copyReturnType ( Method m );// 获取方法的指定位置参数的类型字符串char * method_copyArgumentType ( Method m, unsigned int index );// 通过引用返回方法的返回值类型字符串void method_getReturnType ( Method m, char *dst, size_t dst_len );// 返回方法的参数的个数unsigned int method_getNumberOfArguments ( Method m );// 通过引用返回方法指定位置参数的类型字符串void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );// 返回指定方法的方法描述结构体struct objc_method_description * method_getDescription ( Method m );// 设置方法的实现IMP method_setImplementation ( Method m, IMP imp );// 交换两个方法的实现void method_exchangeImplementations ( Method m1, Method m2 ); 方法列表(objc_method_list)方法调用是通过查询对象的isa指针所指向归属类中的methodLists来完成。 12345678910struct objc_method_list &#123;struct objc_method_list * _Nullable obsolete OBJC2_UNAVAILABLE;int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__int space OBJC2_UNAVAILABLE;#endif/* variable length structure */struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125; 操作函数 123456789101112131415161718192021// 添加方法BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types ); //和成员变量不同的是可以为类动态添加方法。如果有同名会返回NO，修改的话需要使用method_setImplementation// 获取实例方法Method class_getInstanceMethod ( Class cls, SEL name );// 获取类方法Method class_getClassMethod ( Class cls, SEL name );// 获取所有方法的数组Method * class_copyMethodList ( Class cls, unsigned int *outCount );// 替代方法的实现IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );// 返回方法的具体实现IMP class_getMethodImplementation ( Class cls, SEL name );IMP class_getMethodImplementation_stret ( Class cls, SEL name );// 类实例是否响应指定的selectorBOOL class_respondsToSelector ( Class cls, SEL sel ); SEL(objc_selector)123Objc.h/// An opaque type that represents a method selector.代表一个方法的不透明类型typedef struct objc_selector *SEL; objc_msgSend函数第二个参数类型为SEL，它是selector在Objective-C中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:1@property SEL selector; 可以看到selector是SEL的一个实例。 1A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded. 其实selector就是个映射到方法的C字符串，你可以用 Objective-C 编译器命令@selector()或者 Runtime 系统的sel_registerName函数来获得一个 SEL 类型的方法选择器。 selector既然是一个string，我觉得应该是类似className+method的组合，命名规则有两条： 同一个类，selector不能重复 不同的类，selector可以重复 这也带来了一个弊端，我们在写C代码的时候，经常会用到函数重载，就是函数名相同，参数不同，但是这在Objective-C中是行不通的，因为selector只记了method的name，没有参数，所以没法区分不同的method。 操作函数 12345678// 返回给定选择器指定的方法的名称const char * sel_getName ( SEL sel );// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器SEL sel_registerName ( const char *str );// 在Objective-C Runtime系统中注册一个方法SEL sel_getUid ( const char *str );// 比较两个选择器BOOL sel_isEqual ( SEL lhs, SEL rhs ); IMP123/// A pointer to the function of a method implementation. 指向一个方法实现的指针typedef id (*IMP)(id, SEL, ...); #endif 就是指向最终实现程序的内存地址的指针。 在iOS的Runtime中，Method通过selector和IMP两个属性，实现了快速查询方法及实现，相对提高了性能，又保持了灵活性。 类缓存(objc_cache)当Objective-C运行时通过跟踪它的isa指针检查对象时，它可以找到一个实现许多方法的对象。然而，你可能只调用它们的一小部分，并且每次查找时，搜索所有选择器的类分派表没有意义。所以类实现一个缓存，每当你搜索一个类分派表，并找到相应的选择器，它把它放入它的缓存。所以当objc_msgSend查找一个类的选择器，它首先搜索类缓存。这是基于这样的理论：如果你在类上调用一个消息，你可能以后再次调用该消息。 为了加速消息分发， 系统会对方法和对应的地址进行缓存，就放在上述的objc_cache，所以在实际运行中，大部分常用的方法都是会被缓存起来的，Runtime系统实际上非常快，接近直接执行内存地址的程序速度。 Category(objc_category)Category是表示一个指向分类的结构体的指针，其定义如下： 12345678struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods;struct protocol_list_t *protocols;struct property_list_t *instanceProperties;&#125;; name：是指 class_name 而不是 category_name。 cls：要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对 应到对应的类对象。 instanceMethods：category中所有给类添加的实例方法的列表。 classMethods：category中所有添加的类方法的列表。 protocols：category实现的所有协议的列表。 instanceProperties：表示Category里所有的properties，这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，不过这个和一般的实例变量是不一样的。 从上面的category_t的结构体中可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，不可以添加成员变量。 Runtime消息转发前文介绍了进行一次发送消息会在相关的类对象中搜索方法列表，如果找不到则会沿着继承树向上一直搜索知道继承树根部（通常为NSObject），如果还是找不到并且消息转发都失败了就回执行doesNotRecognizeSelector:方法报unrecognized selector错。那么消息转发到底是什么呢？接下来将会逐一介绍最后的三次机会。 动态方法解析 备用接收者 完整消息转发 动态方法解析首先，Objective-C运行时会调用 +resolveInstanceMethod:或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数并返回YES， 那运行时系统就会重新启动一次消息发送的过程。 实现一个动态方法解析的例子如下： 123456789101112131415161718- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.//执行foo函数[self performSelector:@selector(foo:)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;if (sel == @selector(foo:)) &#123;//如果是执行foo函数，就动态解析，指定新的IMPclass_addMethod([self class], sel, (IMP)fooMethod, &quot;v@:&quot;);return YES;&#125;return [super resolveInstanceMethod:sel];&#125;void fooMethod(id obj, SEL _cmd) &#123;NSLog(@&quot;Doing foo&quot;);//新的foo函数&#125; 打印结果：2018-04-01 12:23:35.952670+0800 ocram[87546:23235469] Doing foo 可以看到虽然没有实现foo:这个函数，但是我们通过class_addMethod动态添加fooMethod函数，并执行fooMethod这个函数的IMP。从打印结果看，成功实现了。如果resolve方法返回 NO ，运行时就会移到下一步：forwardingTargetForSelector。 备用接收者如果目标对象实现了-forwardingTargetForSelector:，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。 实现一个备用接收者的例子如下：1234567891011121314151617181920212223242526272829303132333435363738394041#import &quot;ViewController.h&quot;#import &quot;objc/runtime.h&quot;@interface Person: NSObject@end@implementation Person- (void)foo &#123;NSLog(@&quot;Doing foo&quot;);//Person的foo函数&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.//执行foo函数[self performSelector:@selector(foo)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;return YES;//返回YES，进入下一步转发&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123;if (aSelector == @selector(foo)) &#123;return [Person new];//返回Person对象，让Person对象接收这个消息&#125;return [super forwardingTargetForSelector:aSelector];&#125;@end 打印结果：2018-04-01 12:45:04.757929+0800 ocram[88023:23260346] Doing foo 可以看到我们通过forwardingTargetForSelector把当前ViewController的方法转发给了Person去执行了。打印结果也证明我们成功实现了转发。 完整消息转发如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil ，Runtime则会发出 -doesNotRecognizeSelector: 消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation 对象并发送 -forwardInvocation:消息给目标对象。 实现一个完整转发的例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#import &quot;ViewController.h&quot;#import &quot;objc/runtime.h&quot;@interface Person: NSObject@end@implementation Person- (void)foo &#123;NSLog(@&quot;Doing foo&quot;);//Person的foo函数&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view, typically from a nib.//执行foo函数[self performSelector:@selector(foo)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;return YES;//返回YES，进入下一步转发&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123;return nil;//返回nil，进入下一步转发&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;foo&quot;]) &#123;return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];//签名，进入forwardInvocation&#125;return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;SEL sel = anInvocation.selector;Person *p = [Person new];if([p respondsToSelector:sel]) &#123;[anInvocation invokeWithTarget:p];&#125;else &#123;[self doesNotRecognizeSelector:sel];&#125;&#125;@end 打印结果：2018-04-01 13:00:45.423385+0800 ocram[88353:23279961] Doing foo 从打印结果来看，我们实现了完整的转发。通过签名，Runtime生成了一个对象anInvocation，发送给了forwardInvocation，我们在forwardInvocation方法里面让Person对象去执行了foo函数。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"}]},{"title":"《Effective Objective-C 2.0》读书总结","slug":"《Effective Objective-C 2.0》读书总结","date":"2019-04-23T09:17:43.000Z","updated":"2019-04-24T09:12:31.717Z","comments":true,"path":"2019/04/23/《Effective Objective-C 2.0》读书总结/","link":"","permalink":"https://bigporo.github.io/2019/04/23/《Effective Objective-C 2.0》读书总结/","excerpt":"Objective-C了解 Objective-C 语言的起源Objective-C 语言使用”消息结构”而非”函数调用”.Objective-C 语言由 SmallTalk演化而来,后者是消息类型语言的鼻祖.编译器甚至不关心接收消息对象的何种类型.接收消息的对象问题也要在运行时处理,其过程叫做”动态绑定”. Objective-C为 C 语言添加了面向对象特性,是其超类. Objective-C 使用动态绑定的消息结构,也就是说,在运行时才会检查对象类型.接收一条消息后,究竟应执行何种代码,有运行期环境而非编译器决定.理解 C 语言的核心有助于写好 Objective-C 程序.尤其是掌握内存模型与指针.","text":"Objective-C了解 Objective-C 语言的起源Objective-C 语言使用”消息结构”而非”函数调用”.Objective-C 语言由 SmallTalk演化而来,后者是消息类型语言的鼻祖.编译器甚至不关心接收消息对象的何种类型.接收消息的对象问题也要在运行时处理,其过程叫做”动态绑定”. Objective-C为 C 语言添加了面向对象特性,是其超类. Objective-C 使用动态绑定的消息结构,也就是说,在运行时才会检查对象类型.接收一条消息后,究竟应执行何种代码,有运行期环境而非编译器决定.理解 C 语言的核心有助于写好 Objective-C 程序.尤其是掌握内存模型与指针. 在类的头文件中尽量少引用其他头文件Objective-C 语言编写类的标准行为:以类名做文件名,分别闯将两个文件,有文件后缀用. h,实现文件后缀用. m. 在开发中有时候我们会在. h 文件中引入很多用不到的内容,这当然会增加编译时间.除非有必要,否则不要引入头文件,一般来说,某个类的头文件中使用向前声明来体积别的类,并在实现文件中引入哪些类的头文件,这样做可以尽量降低类之间的耦合.有时无法使用向前声明,比如要声明某个类遵循意向协议,这种情况下,尽量把 “该类遵循某协议”的这条声明移至 class=continuation 分类中,如果不行的话,就把协议单独存放在一个头文件中,然后将其引入. 多用字面量语法,少用与之等价的方法12NSArray *arr = [NSArray arrayWithObjects:@&quot;num1&quot;,@&quot;num2&quot;,@&quot;num3&quot;, nil];NSArray *arr = @[@&quot;num1&quot;,@&quot;num2&quot;,@&quot;num3”]; 字面量语法创建字符串,数组,数值,字典.与创建此类对象的常规方法相比,这么做更加简明扼要，并且更加安全。 注意事项: 除了字符串以外,所创建的类必须属于 Foundation 框架才行,如果自定义了这些类的子类,则无法用字面量语法创建其对象. 创建的数组或字典时,若值有 nil, 则会抛出异常.因此,务必确保值中不含 nil。 多用类型常量,少用# deine 预处理指令不要用预处理指令定义常量,这样定义出来的常量不含类型信息,编译器只会在编译前根据执行查找与替换操作,即使有人重新定义了常量值,编译器也不会产生井道信息,这将导致应用程序常量值不一致. 1static NSString *const PersonConstant = @&quot;PersonConstantStr” ; 但是我个人认为其实,还是#define用的多, 开发避免不了使用 pch文件, 同时#define还可以定义方法，这个是类型常量无法做到的。 如果有强迫症的同学,定义常量就想使用 staitc,extren,const 这些关键字.那我建议新建一个专门存放这些常量的类,然后在 pch 中导入这个类. static 修饰符意味着该变量仅在定义此变量的单元中可见 extern 全局变量 用枚举表示状态,选项,状态码应该用枚举来表示状态机的状态,传递给方法的选项以及状态码等值,给这些值起个易懂的名字。 如果把传递的给某个方法的选项表示为枚举类型，而多个类型又可同时使用，那么就将各选项值定义为2的幂，通过按位或操作将其结合起来。 123456enum PersonEnum&#123;PersonEnumNum1,PersonEnumNum2,PersonEnumNum3,&#125;;typedef enum PersonEnum PersonState; 对象、消息、运行时理解属性这一概念属性是 Objective-C 的一项特性,用于封存对象中的数据.属性特质:原子性 读写权限 内存管理语义: assign 这是方法只会执行针对纯量类型(CGFloat,NSInteger)的简单赋值操作 strong 此特质表明该属性定义一种拥有关系,为这种属性设置新值时,这只方法会先保存新值,并释放旧值 weak 此特质表明属性定义了一种”非拥有关系”,为这种属性设置新值是,设置方法既不保留新值,也不释放旧值.此特质同 assign 类似,然而在属性所指对象遭到摧毁时,属性值会清空 unsafe_unretainde 此特质与 assign 相同,它适用于对象类型,该特质表达一种”非拥有关系”,当目标对象遭到摧毁时,属性不会自动清空,因为它是不安全的,这一点与 weak 的区别 copy 此特质所表达的所属关系与 strong 类似,然而设置方法并不保留新值,而是将其拷贝,多用于 NSString. 在对象内部尽量直接访问实例变量直接访问实例变量的速度比较快,因为不经过 Objective-C 方法派发,编译器所生成的代码会直接访问保存催下实例量的那块内存。直接访问实例变量时,不会调用设置方法,这就绕过了相关属性所定义的内存管理语义。 读取实例变量的时候采用直接访问的的形式，设置实例变量的时候通过属性来做。 注意： 直接访问访问实例变量，不会触发KVO。 懒加载时，必须通过属性来读取数据。 理解”对象等同性”这一概念根据等同性来比较对象是一个非常有用的功能,不过,按照 == 操作符比较出来的结果未必是我们想要的,因为该操作比较的事两个指针本身,而不是其所指的对象，应该使用 NSObject 协议中的声明的”isEqual”方法来判断两个对象的等同性,一般来说两个类型不同的对象总是不相等的.直接比较字符串的时候 isEqual 比 isEqualToString慢,因为前者还要执行额外步骤. NSObjec中有两个判断等同性的关键方法:12- (BOOL) isEqual:(id)object;- (NSUInteger)hash; 以”类族模式”隐藏实现细节“类族”是一种很有用的模式,可以隐藏抽象基类背后实现的细节. 这是一种”工厂模式”.比如iOS 用户界面框架 UIKit 中就有一个名为 UIButton 的类.想创建按钮,需要调用下面这个类方法。1+ (UIButton*)buttonWithType:(UIButtonType)type; 在既有类中使用关联对象存放自定义数据有时需要在对象中存放相关信息,这是我们通常会从对象所属的类中继承一个子类,然后改用这个子类对象.然而并非所有情况下都这么做,有时候类的实例可能是由某种机制所创建的,而开发者无法令这种机制创建出自己所写的实例. Objective-C 中有一项强大的特性可以解决问题,这就是关联对象。 123456//关联对象void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)//获取关联的对象id objc_getAssociatedObject(id object, const void *key)//移除关联的对象void objc_removeAssociatedObjects(id object) 理解objc_msgSend的作用用Objetive-C的术语来说，这叫做“消息传递”。这里说的是运行时。 理解消息转发机制当对象接收到无法解读的消息后，就会启动消息转发机制，程序员可经此过程告诉对象应该图和处理未知消息。这里说的是运行时。 动态方法解析 1234567891011+ (BOOL)resolveClassMethod:(SEL)sel&#123;/**动态消息转发if (sel == @selector(foo:)) &#123;class_addMethod([self class], sel, (IMP)fooMethod, &quot;v@:&quot;);&#125;return [super resolveInstanceMethod:sel];*/return YES; // 进入下一步转发&#125; 备用接收者 123456789101112- (id)forwardingTargetForSelector:(SEL)aSelector&#123;/**备用接收者if (aSelector == @selector(foo)) &#123;return [Person new]; // 返回一个Person实例作为备用接收者&#125;return [super forwardingTargetForSelector:aSelector];*/return nil; // 进入下一步转发&#125; 完整的消息转发 12345678910111213141516171819- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;if (aSelector == @selector(foo)) &#123;return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];//签名，进入forwardInvocation&#125;return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;SEL sel = anInvocation.selector;Person *person = [Person new];if ([person respondsToSelector:sel]) &#123;[anInvocation invokeWithTarget:person]; // 直接调用 person 的 foo 方法&#125;else&#123;[self doesNotRecognizeSelector:sel];&#125;&#125; 用方法调配技术调试黑盒方法运行期间，可以向类中新增或替换选择子所对应的方法实现。使用另一份实现来替换原有的方法实现，这道工序叫做方法调配，开发者常用此技术想原有实现中添加新功能。一般来说，只有调试程序的时候才需要运行期修改方法实现，这种做法不易滥用。这里说的是方法交换。 理解类对象的用意每个Objective-C对象实例都是指向某块内存数据的指针，如果把对象所需的内存分配到栈上编译器就会报错. 每个对象结构体的首个成员是Class类的变量，该变量定义了对象所属的类，通常称为isa指针。 12345678910111213typedef struct objc_class *classstruct objc_class&#123;Class isa;Class super_class;const char* name;long version;long info;long instance_size;struct objc_ivar_list *ivars;struct objc_method_list *ivars;struct objc_cache *cache;struct objc_protocol_list protocols;&#125; 此结构体存放类的元数据，例如类的实例实现了几个方法，具备多少个实例变量等信息。此结构体的首个变量也是isa指针，这说明Class本身亦为Objctive-C对象。结构体里还有个变量叫做super_class,它定义本类的超类，类对象所属的类型（isa指针所指向的类型）是另外一个类，叫做元类，用来标书类本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法，每个类仅有一个类对象，每个类对象仅有一个与之相关的元类。（元数据，就是这个类的数据）。 isKindOfClass：能够判断对象是否为某类或其派生类的实例 isMemberOfClass: 能够判断出对象是否为某个特定类的实例 接口设计用前缀避免命名空间冲突Objective-C没有其他语言那种内置的命名空间，所以需要避免命名冲突，否则会直接报错。 提供全能初始化方法即可以为对象提供必要信息以便其完成能完成工作的初始化方法。 注意：如果子类的全能初始化方法与父类的不一致，就应该覆写父类的全能初始化方法。有时我们不想覆写，这时我们可以覆写父类的全能初始化方法并在里面抛出异常。 实现description方法调试程序时经常需要打印并查看对象信息。description 很实用。 debugDescription 方法是开发者在调试器中以命令打印对象时候才调用。12345678910111213141516171819Person.h#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@property(nonatomic,assign)int age;@property(nonatomic ,copy)NSString* name;@endPerson.m#import &quot;Person.h&quot;@implementation Person- (NSString *)description&#123;return [NSString stringWithFormat:@&quot;name %@ , age %d&quot;, self.name, self.age];&#125;- (NSString *)debugDescription&#123;return [NSString stringWithFormat:@&quot;name %@ , age %d&quot;, self.name, self.age];&#125;@end 尽量使用不可变对象通过readonly将属性修饰为不可变，如果想修改封装在对象内部的数据，可以在对象的内部将readonly属性重新声明为readwrite。 注意:readonly修饰的属性，仍然可以使用KVC来修改。 使用清晰而协调的全名方式没啥好说的 为私有方法名加前缀不要单用一个下划线给私有方法做前缀，这个是苹果爸爸用的。 理解Objective-C错误模型NSError的用法更加灵活，因此经由此对象，我们可以把导致错误的原因汇报给调用者。 NSError domain(错误范围，其类型为字符串)错误发生的范围，也就是产生错误的根源，通常用一个特有的全局变量来定义，比方说 “处理URL子系统”从URL的解析获取数据时如果出错了，那么就会使用NSURLErrorDomain来表示错误范围 Error code(错误码，其类型为整数)独有的错误代码，用以指明在某个范围内具体发生了何种错误。某个特性范围内可能会发生一系列相关错误，这些错误情况通常采用enum来定义。例如，当HTTP请求出错时，可能会把HTTP状态码设为错误码 User info(用户信息，其类型为字典)有关错误的额外信息，其中或许包含一段“本地化的描述”或许还含有导致错误发生的另外一个错误，经由此种信息，可将相关错误串成一条“错误链” 123456789101112@try &#123;NSString *str = @&quot;wotaxiwa&quot;;NSString *strErr = [str substringFromIndex:100];NSLog(@&quot;%@&quot;,str);&#125; @catch (NSException *exception) &#123;NSLog(@&quot;ERROR: %@&quot;,exception);&#125; @finally &#123;NSLog(@&quot;%s&quot;,__func__);&#125;如果出现exception，异常后面的代码将不会继续执行 理解NSCopying协议 copy方法实际上是调用 -(id)copyWithZone:(NSZone*)zone; 实现copy操作， 如果想对自己的类支持拷贝并且做额外操作，那就要实现NSCopying协议此的方法。为何出现NSZone呢，以前开发程序时，会据此把内存分成不用的区，而对象会创建在某个区。 现在不用了，每个程序只有一个区：“默认区”，所以不用担心zone参数。copy方法由NSObject实现，该方法只是以默认区为参数调用。 mutableCopy方法实际上是调用 -(id)mutableCopyWithZone:(NSZone*)zone; 实现mutableCopy操作 协议与分类通过委托与数据协议进行对象间通信这一条说的就是delegate(代理设计模式)。但是并没有说delegate的循环引用的问题,在使用代理声明一个 @property的时候，记得用weak。 将类的实现代码分散到便于管理的数个分类之中 使用分类机制把类的实现代码划分成易于管理的小块 将应该视为“私有”的方法归入名为Private的分类中，以隐藏细节。 勿在分类中声明属性正常的分类是不可以声明属性的，但是从技术上说，分类里可以用runtime声明属性。 1234567891011#import &lt;objc.runtime.h&gt;static const char *kFriendsPropertyKey = “kFriendsPropertyKey”;@implementation EOCPerson(Friendship)-(NSArray*)friends&#123;return objc_getAssociatedObject(self,kFriendsPropertyKey);&#125;-(void)setFriends:(NSArray*)friends&#123;objc_setAssociateObject(self.kFriendsPropertyKey,friends,OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 这样做可行，但是不太理想，要把相似的代码写很多遍。而且容易出现Bug，可以使用class-continuation实现分类添加属性。 使用class-continuation分类隐藏实现细节class-continuation分类和普通的分类不同，它必须在其所接续的那个类的实现文件里。其重要之处在于，这是唯一能声明实例变量的分类，而且此分类没有特定的实现文件，其中的方法应该定义在类的主实现文件里。与其他分类不同，“class-continuation分类”没有名字，比如，有个类叫做EOCPerson，其“class-continuation分类”写法如下： 12345678910111213141516171819@interface EOCPerson()@end#import &quot;ViewController.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];&#125;- (void)didReceiveMemoryWarning &#123;[super didReceiveMemoryWarning];&#125;@end 没错它就是 class-continuation分类，在此代码之间可以添加属性，修改属性。 12@interface ViewController ()@end 使用class-continuation分类的好处 可以向类中新增实例变量。 如果类中的主接口声明为只读，可以再类内部修改此属性。 把私有方法的原型文件生命在”class-continuation分类”里面。 想使类遵循的协议不为人知，可以用“class-continuation分类”中声明。 通过协议提供匿名对象就说下面这句话1@property (nonatomic,weak)id&lt;PersonDelegate&gt; pd; 内存管理理解引用计数理解引用计数，方便于了解iOS的内存管理。不过现在都是ARC的时代了。 引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当保存计数降为0，对象就被销毁了。 在对象生命期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。 以ARC简化引用计数使用ARC要计数，引用计数实际上还是要执行的，只不过保留与释放操作现在由ARC自动为你添加。由于ARC会自动执行retain、release、autorelease等操作，所以直接在ARC下调用这些内存管理方法是非法的。 ARC管理对象生命周期的的办法基本就是：在合适的位置插入“保留”和“释放”操作。 ARC在调用这些方法时，并不用过普通的Objective-C消息派发机制，而是直接调用其底层C语言版本，这样做性能更好，直接调用底层函数节省很多CPU周期。 虽然有了ARC之后无需担心内存管理问题，但是CoreFoundation对象不归ARC管理，开发者必须适时调用CFRetain/CFRelease。 在dealloc方法中只释放引用并解除监听 当一个对象销毁的时候会调用dealloc方法，但是当开销较大或系统内稀缺资源则不再此列，像是文件描述、套接字、大块内存等都属于这种资源，通常对于开销较大的资源实现一个方法，当程序用完资源对象后，就调用此方法。这样一来，资源对象的生命期就变得明确了。 执行异步任务的方法不应该在dealloc里面调用；只能在正常状态下调用的那些方法也不应该调用，因为此时对象已经处于正在回收的状态了。 编写“异常安全代码”时留意内存管理问题 在使用@try 的时也要注意，在捕获到异常的时候@try{}中的语句执行到异常代码的那一行后不在执行，然后把异常抛给@catch。当然@finally是一定要执行的。 在默认情况下，ARC不生成安全处理异常所需的清理代码。开启编译器标志后，可以生成这种代码，不过会导致应用程序变大，而且会降低运行效率。 以弱引用避免保留环 unsafe_unretained 语义同assign等价。然而assign通常用于int、float、结构体等。unsafe_unretained多用于对象类型。 weak 与 unsafe_unretained 作用相同，然而只要系统把属性回收，属性值为nil。推荐使用weak，毕竟是ARC时代的产物，而且用的人也很多。 以“自动释放池块”降低内存峰值自动释放池排布在栈中，对象收到autorelease消息后，系统将其放入最顶端的池里。12345678910111213141516@autoreleasepool &#123;&lt;#statements#&gt;&#125;for (int i = 0; i &lt; 1000000; i++) &#123;@autoreleasepool &#123;NSNumber *num = [NSNumber numberWithInt:i];NSString *str = [NSString stringWithFormat:@&quot;%d &quot;, i];[NSString stringWithFormat:@&quot;%@%@&quot;, num, str];if(lagerNum-1 == i)&#123;NSLog(@&quot;end&quot;);&#125;&#125;&#125; 用“僵尸对象”调试内存管理问题在左上角标题栏找到项目单击后选择 Edit scheme 勾选图中检测僵尸对象。 开启后，系统在回收对象的时候，可以不真的将其回收，而是转成僵尸对象。 系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使该对象变成僵尸对象。僵尸类能响应所有的方法，响应方式为：打印一条包含消息内容及其接受者的消息，然后终止应用程序。 不要使用retainCount 任何给定时间点上的“绝对保留计数”都无法反应对象生命周期的全貌。 ARC的时代，调用该方法会直接报错。 块与大中枢派发理解”块“这一概念这里其实就是在说block，复习一下block的语法：返回值类型（block名称)(参数) 需要注意的是定义block时候，其所占内存区域是分配在栈中的，块只在定义它的那个范围内有效。 block所使用的整个内存区域，在编译期已经完全确定，因此，全局block可以生命在全局内存里，而不需要在每次用到的时候于栈中创建，另外，全局block的拷贝是个空操作，因为全局block绝不可能为系统所回收，这种block实际上相当于单例。 可以调用 copy 方法将块从栈拷贝到堆，拷贝之后的块就可以在定义它的范围之外使用了。而且，拷贝到堆以后，块就变成带引用计数的对象了，后续的copy操作不会真的执行，只是递增引用计数。 为常用的块类型创建typedef就是给block起个别名12typedef &lt;#returnType#&gt;(^&lt;#name#&gt;)(&lt;#arguments#&gt;);@property (nonatomic,copy)name nm_blk; 用handler块降低代码分散程度说的就是block的回调。只不过是把block放在方法中去使用,使代码更加紧致。 12345678910111213141516171819202122// Person.h#import &lt;Foundation/Foundation.h&gt;typedef void(^Blk)(NSString *name,int age);@interface Person : NSObject-(void)handler:(Blk)blk;@end// Person.m#import &quot;Person.h@implementation Person-(void)handler:(Blk)blk&#123;if(blk)&#123;blk(@&quot;zhangsan&quot; ,28);&#125;&#125;@end// 使用Person *per =[Person new];[per handler:^(NSString *name, int age) &#123;NSLog(@&quot;%@ %d&quot;,name, age);&#125;]; 用块引用其所属对象时不要出现保留环注意用weak，不要出现循环引用。 多用派发队列，少用同步锁派发队列可用来表述同步语义，这种做法比使用@synchronize块或NSLock对象更简单将同步与异步派发结合起来，可以实现与普通枷锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程。 使用同步队列及栅栏块，可以令同步行为更加高效（不常用）。 多用GCD，少用performSelector系列方法这个没啥可说的 掌握GCD及操作队列的适用时机这个没啥可说的 解决多线程与任务管理问题时，派发队列并非唯一方案 操作队列提供了一套高层的Objective-C API 能实现纯GCD所具备的绝大部分功能，而且还完成一些更为复杂的操作，那些操作弱改用GCD来实现，则需另外编写代码。 使用NSOperation对线程管理 通过Dispatch Group机制，根据系统资源状况来执行任务这个没啥可说的一系列任务可归入一个dispatch group之中。开发者可以在这组任务执行完毕时获得通知通过dispatch group，可以在并发式派发队列里同时执行多项任务。此时GCD会根据系统西苑状况来调度这些并发执行的任务。开发者若自己来实现此功能。则需要便携大量代码。 使用dispatch_once来执行秩序运行一次的线程安全代码1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;&lt;#code to be executed once#&gt;&#125;); 不用使用dispatch_get_current_queue这个没啥可说的。iOS系统6.0版本起，已经正式弃用此函数了。 系统框架熟悉系统框架打开Xcode command + shift + 0 选择性的了解一些 Foundation、UIKit也可以看看这篇博客 http://www.jianshu.com/p/58bc11c800e4 多用块枚举，少用for循环因为枚举遍历的时候用的多线程（GCD并发执行），所以效率更快些。我觉得其实用什么都行。 123NSArray *arr = @[@&quot;b&quot;,@&quot;c&quot;,@&quot;s&quot;];[arr enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;&#125;]; 对自定义其内存管理语义的collection使用无缝桥接123NSArray *anNSArray = @[@1,@3,@5,@8];CFArrayRef acFArray = (__bridge CFArrayRef)anNSArray;NSLog(@&quot;%@&quot;,acFArray); 通过无缝桥接技术，可以在Foundation框架中Objective-C对象与CoreFoundation框架中的C语言数据结构之间来回转换。 在CoreFoundation层面穿件collection时，可以指定许多回调函数，这些函数表示此collection应如何处理其元素，然后可运用无缝桥接技术，将其转换成具备特殊内存管理语义的Objective-C collection。 __bridge:ARC仍然具备这个OC对象的所有权 bridgeretained:ARC将交出对象的所有权 构建缓存时选用NSCache而非NSDictionary NSCache胜过NSDictionary之处在于，当系统资源耗尽时，它能自动删减缓存。 NSCache线程安全 精简Initialize与load的实现代码类初始化的时候一定会调用两个方法 12345678+(void)load&#123;&#125;+ (void)initialize&#123;if (self == [&lt;#ClassName#&gt; class]) &#123;&lt;#statements#&gt;&#125;&#125; load方法只会调用一次，不管该类的头文件有没有被使用，该类都会被系统自动调用，而且只调用一次。 当然了，如果不重写这个方法的话，我们是不知道这个方法有没有被调用的。如果分类也重写了load方法，先调用类里的，在调用分类。 load方法执行时，运行期系统处于“脆弱状态”，在执行子类的load方法之前，必定会先执行所以超类的load方法，而如果代码还依赖了其他的库，那么其他库的相关类的load方法一定会先执行，但是执行的顺序不好判断，所以在load方法中使用其他类是不安全的。 整个程序在执行load方法时都会阻塞。 initialize 和load类似，不过在类被初始化的时候才会被调用（init之前）。需要注意的是，&lt;#ClassName#&gt;如果有子类继承的时候要判断类名。 两个方法的实现都应该精简些，这有助于保持应用程序的响应能力。 别忘了NSTimer会保留其目标对象1234567891011121314151617181920212223242526272829303132333435363738394041// Person.h#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@property (nonatomic,strong)NSTimer *timer;-(void)start;-(void)stop;@end// Person.m#import &quot;Person.h&quot;@implementation Person-(void)start&#123;self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(run) userInfo:nil repeats:YES];&#125;-(void)run&#123;NSLog(@&quot;%s&quot;,__func__);&#125;-(void)dealloc&#123;NSLog(@&quot;%s&quot;,__func__);&#125;-(void)stop&#123;[self.timer invalidate];&#125;@end调用@property (nonatomic,strong)Person *person;self.person = [Person new];[self.person start];-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;[self.person stop];&#125; 好，那么问题来了，是不是没有调用dealloc方法，没有调用dealloc方法就说明Person对象并没有被销毁，为什么没有被销毁因为在控制器强引用了self.person，[self.person start]强引用了 self.timer; self.timer 的target指向了self（self.person）所以循环引用了。 怎么解决。 NSTimer销毁的时候，把Person对象为nil即可。 1234-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;[self.person stop];self.person = nil;&#125;","categories":[{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/categories/读书/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bigporo.github.io/tags/iOS/"},{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/tags/读书/"}]},{"title":"《计算机网络（第七版）》读书总结","slug":"《计算机网络（第七版）》读书总结","date":"2019-04-23T09:17:43.000Z","updated":"2019-05-16T07:53:02.363Z","comments":true,"path":"2019/04/23/《计算机网络（第七版）》读书总结/","link":"","permalink":"https://bigporo.github.io/2019/04/23/《计算机网络（第七版）》读书总结/","excerpt":"主要是摘录书中的重要概念。 概述 计算机网络(可简称为网络)把许多计算机连接在一起，而互连网则把许多网络连接在一起，是网络的网络。","text":"主要是摘录书中的重要概念。 概述 计算机网络(可简称为网络)把许多计算机连接在一起，而互连网则把许多网络连接在一起，是网络的网络。 以小写字母i开始的 internet(互连网)是通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议(即通信规则)可以是任意的。 以大写字母I开始的 Internet(互联网)是专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，并采用TCP/IP协议族作为通信规则，且其前身是美国的 ARPANET。 Internet的推荐译名是“因特网”，但很少被使用。 互联网现在采用存储转发的分组交换技术，以及三层ISP结构。 互联网按工作方式可划分为边缘部分与核心部分。主机在网络的边缘部分，其作用是进行信息处理。路由器在网络的核心部分，其作用是按存储转发方式进行分组交换。 计算机通信是计算机中的进程(即运行着的程序)之间的通信。计算机网络采用的通信方式是客户一服务器方式和对等连接方式(P2P方式)客户和服务器都是指通信中所涉及的应用进程。 客户是服务请求方，服务器是服务提供方。按作用范围的不同，计算机网络分为广域网WAN、城域网MAN、局域网LAN和个人区域网PAN。 计算机网络最常用的性能指标是:速率、带宽、吞吐量、时延(发送时延、传播延、处理时延、排队时延)、时延带宽积、往返时间和信道(或网络)利用率 网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构。 五层协议的体系结构由应用层、运输层、网络层(或网际层)、数据链路层和物理层组成。运输层最重要的协议是TCP和UDP协议，而网络层最重要的协议是IP协议。 物理层 物理层的主要任务就是确定与传输媒体的接口有关的一些特性，如机械特性、电气特性、功能特性和过程特性。 一个数据通信系统可划分为三大部分，即源系统、传输系统和目的系统。源系统包括源点(或源站、信源)和发送器，目的系统包括接收器和终点(或目的站，或信宿)。 通信的目的是传送消息。如话音、文字、图像、视频等都是消息。数据是运送消息的实体。信号则是数据的电气或电磁的表现。 根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号(或连续信号)和数字信号(或离散信号)。代表数字信号不同离散数值的基本波形称为码元。根据双方信息交互的方式，通信可以划分为单向通信(或单工通信)、双向交替通信(或半双工通信)和双向同时通信(或全双工通信)。 来自信源的信号叫做基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅、调频和调相。还有更复杂的调制方法，如正交振幅调制。 要提高数据在信道上的传输速率，可以使用更好的传输媒体，或使用先进的调制技型传输媒体(无线或红外或大气激光)。但数据传输速率不可能被任意地提高。 传输媒体可分为两大类，即导引型传输媒体(双绞线、同轴电缆或光纤)和非导引型传输媒体(无线或红外或大气激光)。 常用的信道复用技术有频分复用、时分复用、统计时分复用、码分复用和波分复用（光的频分复用）。 最初在数字传输系统中使用的传输标准是脉冲编码调制PCM。现在高速的数字传输系统使用同步光纤网 SONET(美国标准)或同步数字系列SDH(国际标准)。 用户到互联网的宽带接入方法有非对称数字用户线ADSL(用数字技术对现有的模拟电话用户线进行改造)、光纤同轴混合网HFC(在有线电视网的基础上开发的)和FTTx(即光纤到户)。 为了有效地利用光纤资源，在光纤干线和用户之间广泛使用无源光网络PON。无源光网络无须配备电源，其长期运营成本和管理成本都很低。最流行的无源光网经是以太网无源光网络EPON和吉比特无源光网络GPON。 数据链路层 链路是从一个结点到相部结点的一段物理线路，数据链路则是在链路的基础上增加了一些必要的硬件(如网络适配器)和软件(如协议的实现)。 数据链路层使用的信道主要有点对点信道和广播信道两种。数据链路层传送的协议数据单元是帧。数据链路层的三个基本问题则是:封装成帧、透明传输和差错检测。 循环冗余检验CRC是一种检错方法，而检验序列FCS是添加在数据后面的冗余码。 点对点协议PPP是数据链路层使用最多的一种协议，它的特点是:简单；只检测差错，而不是纠正差错:不使用序号，也不进行流量控制:可同时支持多种网络层协议。 PPPOE是为宽带上网的主机使用的链路层协议。 局域网的优点是:具有广播功能，从一个站点可很方便地访问全网:便于系统的扩展和逐渐演变；提高了系统的可靠性、可用性和生存性。 共享通信媒体资源的方法有二:一是静态划分信道(各种复用技术)，二是动态媒体接入控制，又称为多点接入(随机接入或受控接入)。 IEE802委员会曾把局域网的数据链路层拆成两个子层，即逻辑链路控制(LC)子层(与传输媒体无关)和媒体接入控制MAC)子层(与传输媒体有关)。但现在LC子层已成为历史。 计算机与处界局域网的通信要通过通信适配器(或网络适配器)，它又称为网络接口卡或网卡，主要功能是进行数据串行传输和并行传输的转换。计算机的硬件地址就在适配器ROM中。 以太网采用无连接的工作方式，对发送的数据不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢弃，其他什么也不做。 以太网采用的协议是具有冲突检测的載波监听多点接入 CSMA/CD。协议的要点是:发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。因此，每一个站在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。以太网上各站点都平等地争用以太网信道。 传统的总线以太网基本上都是使用集线器的双绞线以太网。这种以太网在物理上是星形网，但在逻辑上则是总线形网。集线器工作在物理层，它的每个接口仅仅简单地转发比特不进行碰撞检测。 以太网的硬件地址，即MAC地址事实上就是适配器地址或适配器标识符，与主机所在的地点无关。源地址和目的地址都是48位长。 以太网的适配器有过滤功能，它只接收单播帧、广播帧或多播帧。 使用集线器可以在物理层扩展以太网(扩展后的以太网仍然是一个网络)。 交换式集线器常称为以太网交換机或第二层交换机(工作在数据链路它就是个多接口的网桥），而每个接口都直接与某台单主机或另一个集线器相连，且工作在全双工方式。 以太网交换机其实就是个多接口的网桥，能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，无碰撞地传输数据。 高速以太网有100Mits的快速以太网、吉比特以太网和10 Gbit/s的10吉比特以太网。最近还发展到100吉比特以太网。在宽带接入技术中，也常使用高速以太网进行接入。 网络层 TCP/IP体系中的网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组可能出错、丢失、重复和失序。进程之间通信的可靠性由运输层负责。 IP网是虚拟的，因为从网络层上看，IP网就是一个统一的、抽象的网络(实际上是异构的)。IP层抽象的互联网屏蔽了下层网络很复杂的细节，使我们能够使用统一的、抽象的IP地址处理主机之间的通信问题。 在互联网上的交付有两种:在本网络上的直接交付(不经过路由器)和到其他网络的间接交付(经过至少一个路由器，但最后一次一定是直接交付)。 一个IP地址在整个互联网范围内是唯一的。分类的IP地址包括A类、B类和C类地址(单播地址)，以及D类地址(多播地址)。E类地址未使用。 分类的IP地址由网络号字段(指明网络)和主机号字段(指明主机)组成。网络号字段最前面的类别位指明IP地址的类别。 IP地址是一种分等级的地址结构。IP地址管理机构在分配IP地址时只分配网络号，而主机号则由得到该网络号的单位自行分配。路由器仅根据目的主机所连接的网络号来转发分组。 IP地址标志一台主机(或路由器)和一条链路的接口。多归属主机同时连接到两个或更多的网络上。这样的主机同时具有两个或更多的IP地址，其网络号必须不同的。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有2个不同的IP地址。 按照互联网的观点，用转发器或网桥连接起来的若干个局域网仍为一个网络。所分配到网络号的网络(不管是范围很小的局域网，还是可能覆盖很大地理范围的域网)都是平等的。 物理地址(即硬件地址)是数据链路层和物理层使用的地址，而P地址是网络和以上各层使用的地址，是一种逻辑地址(用软件实现的)，在数据路层看不见数据报的IP地址。 IP数据报分为首部和数据两部分。首部的前一部分是固定长度，共20字节，是所有IP数据报必须具有的(源地址、目的地址、总长度等重要字段部在定首部中)。一些长度可变的可选字段放在固定首部的后面。 IP首部中的生存时间字段给出了IP数据报在互联网中所能经过的最大路由器数，可防止IP数据报在互联网中无限制地兜圈子。 地址解析协议ARP把IP地址解析为硬件地址，它解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。ARP的高速缓存可以大大减少网络上的通信量。 在互联网中，我们无法仅根据硬件地址寻找到在某个网络上的某台主机。因此，从IP地址到硬件地址的解析是非常必要的。 无分类域间路由选择CIDR是解決目前IP地址紧缺的一个好方法。CIDR记法把IP地址后面加上斜线”/“，然后写上前缀所占的位数。前(或网络前级)用来指 明网络，前缀后面的部分是后缀，用来指明主机。CIDR把前绶都相同的连续的IP地址组成一个“CIDR地址块”。IP地址的分配都以CIDR地址块为单位。 CIDR的32位地址掩码(或子网掩码)由一串1和一串0组成，而1的个数就是前缀的长度。只要把IP地址和地址掩码逐位进行“逻辑与(AND)”运算，就很容易得出网络地址A类地址的默认地址掩码是25500。B类地址的默认地址码是255250.0。C类地址的默认地址掩码是255.2552550. 路由聚合(把许多前缀相同的地址用一个来代替)有利于减少路由表中的项目，减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。 “转发”和“路由选择”有区别。“转发”是单个路由器的动作。“路由选择”是许 多由置共同鼓作的过程，这些路由器相立交换信息，目的是生成路由表，再从路由表导出转发表。若采用自适应路由选择算法，则当网络拓扑变化时，路由表和转发表都能够自动更新。在许多情况下，可以不考虑转发表和路由表的区别，而都使用路由表这一名词。 自治系统(AS)就是在单一的技术管理下的一组路由器。一个自治系统对其他它自治系统表现出的是一个单一的和一致的路由选择策略。 路由选择协议有两大类:内部网关协议(或自治系统内部的路由选择协议)，如RIP和OSP；外部网关协议(或自治系统之间的路由选择协议)，如BGP-4。 RIP是分布式的基于距离向量的路由选择协议，只适用于小型互联网。RIP按固定的时间间隔与相邻路由器交换信息。交换的信息是自己当前的路由表，即到达本自治系统中所有网络的(最短)距离，以及到每个网络应经过的下一跳路由器。 OSPF是分布式的链路状态协议，适用于大型互联网。OSPF只在链路状态发生 化时，才向本自治系统中的所有路由器，用洪泛法发送与本路由器相邻的所有路由器的链路状态信息。“链路状态”指明本路由器都和哪些路由器相邻，以及该链路的“度量”。“度量”可表示费用、距离、时延、带宽等，可统称为“代价”。所有的路由器最终都能建立一个全网的拓扑结构图。 BGP4是不同AS的路由器之间交换路由信息的协议，是一种路径向量路由选择协议。BGP力求寻找一条能够到达目的网络(可达)且比较好的路由(不兜圈子)，而并非要寻找一条最佳路由。 网际控制报文协议ICMP是IP层的协议。ICMP报文作为IP数据报的数据，加上首部后组成IP数据报发送出去。使用ICMP并非为了实现可靠传输。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP报文的种类有两种，即ICMP差错报告报文和ICMP询问报文。 ICMP的一个重要应用就是分组网间探测PING，用来测试两台主机之间的连通性。PING使用了ICMP回送请求与回送回答报文。 要解决IP地址耗尽的问题，最根本的办法就是采用具有更大地址空间的新版本的IP协议，即IPv6。 IPV6所带来的主要变化是:(1)更大的地址空间(采用128位的地址):(2)灵活的首部格式:(3)改进的选项:(4)支持即插即用:(5)支持资源的预分配:(6)IPv6的首部改为8字节对齐。 IPv6数据报在基本首部的后面允许有零个或多个扩展首部，再后面是数据。所有的扩展首部和数据合起来叫做数据报的有效载荷或净负荷。 IPv6数据报的目的地址可以是以下三种基本类型地址之一:单播、多播和任播。 IPv6的地址使用冒号十六进制记法。 向IPV6过渡只能采用逐步演进的办法，必须使新安装的IPv6系统能够向后兼容向IPw6过渡可以使用双协议栈或使用隧道技术。 与单播相比，在一对多的通信中，IP多播可大大节约网络资源。IP多播使用D类IP地址。IP多播需要使用网际组管理协议IGMP和多播路由选择协议。 虚拟专用网VPN利用公用的互联网作为本机构各专用网之间的通信载体。VPN内部使用互联网的专用地址。ー个VPN至少要有一个路由器具有合法的全球IP地址，这样オ能和本系统的另ー个VPN通过互联网进行通信。所有通过互联网传送的数据都必须加密。 使用网络地址转换NAT技术，可以在专用网络内部使用专用IP地址，而仅在连接到互联网的路由器使用全球P地址。这样就大大节约了宝贵的IP地址。 MPLS的特点:(1)支持面向连接的服务质量；(2)支持流量工程，平衡网络负载:(3)有效地支持虚拟专用网VPN。 MPLS在入口结点给每一个IP数据报打上固定长度的“标记”，然后根据标记在第二层(链路层)用硬件进行转发(在标记交换路由器中进行标记对换)，因而转发速率大大加快。 运输层 运输层提供应用进程间的逻辑通信，也就是说，运输层之间的通信并不是真正在两 个运输层之间直接传送数据。运输层向应用层屏蔽了下面网络的细节(如网络拓扑、所采用的路由选择协议等)，它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。 网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。 运输层有两个主要的协议:TCP和UDP。它们都有复用和分用，以及检错的功能。当运输层采用面向连接的TCP协议时，尽管下面的网络是不可靠的(只提供尽最大努力服务)，但这种逻辑通信信道就相当于一条全双工通信的可靠信道。当运输层采用无连接的UDP协议时，这种逻辑通信信道仍然是一条不可靠信道。 运输层用一个16位端口号来标志一个端口。端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。 两台计算机中的进程要互相通信，不仅要知道对方的IP地址(为了找到对方的计算机)，而且还要知道对方的端口号(为了找到对方计算机中的应用进程)。 运输层的端口号分为服务器端使用的端口号(0~1023指派给熟知端口，1024~49151是登记端口号)和客户端暫时使用的端口号(49152~65535)。 UDP的主要特点是:(1)无连接:(2)尽最大努力交付:(3)面向报文；(4)无拥塞控制:(5)支持一对对多、多对一和多对多的交互通信；(6)首部开销小(只有四个字段:源端口、目的端口、长度、检验和) TCP的主要特点是:(1)面向连接；(2)每一条TCP连接只能是点对点的(一对一):(3)提供可靠交付的服务:(4)提供全双工通信:(5)面向字节流。 TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点。这样的端点就叫做套接字( socket)或插口。套接字用(IP地址:端口号)来表示。 停止等待协议能够在不可靠的传输网络上实现可靠的通信。每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。分组需要进行编号。 超时重传是指只要超过了一段时间仍然没有收到确认，就重传前面发送过的分组(认为刚オ发送的分组丢失了)。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。 连续ARQ协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都己正确收到了。 TCP报文段首部的前20个字节是固定的，后面有4N字节是根据需要而增加的选项(N是整数)。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号。 TCP首部中的确认号是期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则表明:到序号N-1为止的所有数据都已正确收到。 TCP首部中的窗口字段指出了现在允许对方发送的数据量。窗口值是经常在动态变化着的。 TCP使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到了确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动(没有收到新的确认)和前移(收到了新的确认) 发送窗口前沿通常是不断向前移动的。 流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做拥塞。拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。 流量控制是一个端到端的问题，是接收端抑制发送端发送数据的速率，以便使接收端来得及接收。拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 为了进行拥塞控制、TCP的发送方要推持一个拥塞窗口cwnd的状态变量。拥塞窗口的大小取決于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。 TCP的拥塞控制采用了四种算法，即慢开始、拥塞避免、快重传和快恢复。在网终层，也可以使路由器采用适当的分组丢弃策略(如主动队列管理AQM)，以减少网络拥塞的发生 运输连接有三个阶段，即:连接建立、数据传送和连接释放。 主动发起TCP连接建立的应用进程叫做客户，而被动等待连接建立的应用进程做眼务器。TCP的连接建立采用三报文握手机制。服务器要确认客户的连接请求，然后客户要对服务器的确认进行确认。 TCP的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发送连接释放的通知，待对方确认后就进入半关闭状态。当另一方也没有数据再发送时，则发送链接释放通知，对方确认后就完全关闭了TCP连接接释放的通知。 应用层 应用层协议是为了解决某一类应用问题，而问题的解决又是通过位于多个应用进程之间的通信和协同工作来完成的。应用层规定了应用进程在通信时所遵循的协议。 应用层的许多协议都是基于客户服务器方式的。客户是服务请求方，服务器是服务提供方。 域名系统DNS是互联网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址。DNS是一个联机分布式数据库系统，并采用客户服务器方式。 域名到IP地址的解析是由分布在互联网上的许多域名服务器程序(即域名服务器)共同完成的。 互联网采用层次树状结构的命名方法，任何一台连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。域名中的点和点分十进制IP地址中的点没有关系。 域名服务器分为根域名服务器、顶级域名服务器、权限域名服务器和本地域名服务器。 文件传送协议FTP使用TCP可靠的运输服务。FTP使用客户服务器方式。一个FTP服务器进程可同时为多个客户进程提供服务。在进行文件传输时，FTP 的客户和服务器之间要建立两个并行的TCP连接:控制连接和数据连接。实际用于传输文件的是数据连接。 万维网www是一个大规模的、联机式的信息储藏所，可以非常方便地从互联网上的一个站点链接到另一个站点。 万维网的客户程序向互联网中的服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。 在客户程序上显示出的万维网文档称为页面。 万维网使用统资源定位符URL来标志万维网上的各种文档，并使每一个文档在整个互联网的范围内具有唯一的标识符URL。 万维网客户程序与服务器程序之间进行交互所使用的协议是超文本传送协议HTTP。HTTP使用TCP连接进行可靠的传送。但HTTP协议本身是无连接、无状态的。HTTP/1.1 协议使用了持续连接(分为非流水线方式和流水线方式)。 万维网使用超文本标记语言HTML来显示各种万维网页面。 万维网静态文档是指在文档创作完毕后就存放在万维网服务器中，在被用户浏览的才由应用程序动态创建的。过程中，内容不会改变。动态文档是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建的。 活动文档技术可以使浏览器屏幕连续更新。活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。 在万维网中用来进行搜索的工具叫做搜索引擎。搜索引擎大体上可划分为全文检索搜索引擎和分类目录搜索引擎两大类。 电子邮件是互联网上使用最多的和最受用户欢迎的一种应用。电子邮件把邮件发到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自 送己使用的邮件服务器进行读取，相当于“电子信箱”。 这个电子邮件系统有三个主要组成构件即用户代理、邮件服务器，以及邮件协议(包括邮件发送协议，如SMTP，和邮件读取协议，如PPOP3和IMAP)。用户代理和邮件服务器都要运行这些协议。 电子邮件的用户代理就是用户与电子邮件系统的接口，它向用户提供一个很友好的视窗界面来发送和接收邮件。 从用户代理把邮件传送到邮件服务器，一级在邮件服务器之间的传送，都要使用SMTP协议。但用户代理从邮件服务器读取邮件时，则要使用POP3（或IMAP）协议。 基于万维网的电子邮件使用户能够利用浏览器收发电子邮件。用户浏 浏览器和邮件服务器之间的邮件传送使用HTTP协议，而在邮 件服务器之间邮件的传送仍然使用SMTP协议。 简单网络管理协议SNMP由三部分组成，即(1)SNMP本身，负责读取和改变各代理中的对象名及其状态数值: (2)管理信息结构SMI，定义命名对象和定义对象类型(包括范围和长度)的通用规则，以及把对象和对象的值进行编码的基本编码规则BER； (3) 管理信息库MIB，在被管理的实体中创建了命名对象，并规定了其类型。 系统调用接口是应用进程的控制权和操作系统的控制权进行转换的一个接口，又称为应用编程接口API。API 就是应用程序和操作系统之间的接口。 套接字是应用进程和运输层协议之间的接口，是应用进程为了获得网络通信服务而与操作系统进行交互时使用的一种机制。 目前P2P工作方式下的文件共享在互联网流量中已占据最大的份额，比万维网应用所占的比例大得多。 BT是很流行的种P2P应用。BT采用“是稀有的优先”的技术，可以尽早把取稀有的文件块收集到。此外，凡有当前以最高数据率向某个对等方传送文件块的相邻对等方，该对等方就优先把所请求的文件块传送给这些相邻对等方。这样做的结果是，这些对等方相互之间都能够以令人满意的速率交换文件块。 当对等方的数量很大时，采用P2P方式下载大文件，要比传统的客户-服务器方式快得多。 在P2P应用中，广泛使用的索引和查找技术是分布式散列表DHT。 网络安全 计算机网络上的通信面临的威胁可分为两大类， 即被动攻击(如截获)和主动攻击 (如中断、算改、伪造)。主动攻击的类型有更改报文流、拒绝服务、伪造初始 化、恶意程序(病毒、蠕虫、木马、逻辑炸弹、后门入侵、流氓软件)等。 计算机网络安全主要有以下一些内容:保密性、安全协议的设计和访问控制。 密码编码学是密码体制的设计学，而密码分析学则是在未知密钥的情况下从密文推演出明文或密钥的技术。密码编码学与密码分析学合起来即为密码学。 如果不论截取者获得了多少密文，都无法唯一地确定出对应的明文，则这一密码体制称为无条件安全的(或理论上是不可破的)。在无任何限制的条件下，目前几乎所有实用的密码体制均是可破的。如果一个密码体制中的密码不能在一定时间内被可以使用的计算资源破译，则这密码体制称为在计算上是安全的。 对称密钥密码体制是加密密钥与解密密钥相同的密码体制(如数据加密标准DES和高级加密标准AES)。这种加密的保密性仅取决于对密钥的保密，而算法是公开的。 公钥密码体制(又称为公开密钥密码体制)使用不同的加密密钥与解密密钥。加密算法和解密算法也都是公开的。加密密钥(即公钥)是向公众公开的，而解密密钥(即私钥或秘钥)则是需要保密的。 目前最著名的公钥密码体制是RSA体制，它是基于数论中的大数分解问题的体制。任何加密方法的安全性取决于密钥的长度，以及攻破密文所需的计算量，而不是简单地取决于加密的体制(公钥密码体制或传统加密体制)。 数字签名必须保证能够实现以三点功能(1)报文鉴别，即接收者能够核实发送者对报文的签名(2)报文的完整性，即接收者确信所收到的数据完全和发送者发送的完全一样而没有被篡改过；(3)不可否认，即发送者事后不能抵赖对报文的签名。 鉴别是要验证通信的对方的确是自己所要通信的对象，而不是其他的冒充者。鉴别与授权是不同的概念。 密钥管理包括:密钥的产生、分配、注入、验证和使用。密钥分配(或密钥分发)是密钥管理中最大的问题。密钥必须通过最安全的通路进行分配。目前常用的密钥分配方式是设立密钥分配中心KDC。 认证中心CA是一个值得信赖的机构，用来将公钥与其对应的实体(人或机器)进行绑定。每个实体都有CA发来的证书，里面有公钥及其拥有者的标识信息(人名或IP地址)。此证书被CA进行了数字签名。任何用户都可从可信的地方获得认证中心CA的公钥。 在网络层可使用IPsec协议族，IPsec包括鉴别首部协议AH和封装安全有效载荷协议ESP。AH协议提供源点鉴别和数据完整性，但不能保密。而ESP协议提供源点鉴别、数据完整性和保密。IPsec 支持IPv4和IPV6。在IPv6中，AH和ESP都是扩展首部的一部分。IPsee 数据报的工作方式有运输方式和隧道方式两种。 运输层的安全协议有SSL (安全套接字层)和TLS (运输层安全)。SSL最新的版本是SSL 3.0， 它是保护万维网HTTP通信量所公认的事实上的标准。SSL不仅被所有常用的浏览器和万维网服务器所支持，而且也是TLS的基础。 PGP是一个完整的电子邮件安全软件包，包括加密、鉴别、电子签名和压缩等技术。PGP并没有使用什么新的概念，它只是把现有的一些加密算法(如RSA公钥加密算法或MDS报文摘要算法)综合在一起而已。 防火墙是种特殊编程的路由器，安装在一个网点和网络的其余部分之间，目的是实施访问控制策略。防火墙里面的网络称为“可信的网络”，而把防火墙外面的网络称为“不可信的网络”。防火墙的功能有两个:一个是阻止(主要的)，另一个是允许。 防火墙技术分为:网络级防火墙，用来防止整个网络出现外来非法的入侵(属于这类的有分组过滤和授权服务器)；应用级防火墙，用来进行访问控制(用应用网关或代理服务器来区分各种应用)。 入侵检测系统IDS是在入侵已经开始，但还没有造成危害或在造成更大危害前，及时检测到入侵，以便尽快阻止入侵，把危害降低到最小。 网络上的音视频服务 多媒体信息有两个重要特点:(1)多媒体信息的信息量往往很大1(2)在传输多媒体数据时，对时延和时延抖动均有较高的要求。在互联网上传输多媒体数据时，我们都是指含有“边传输、边播放”的特点。 由多媒体信息构成的分组在发送时是等时的。这些分组在到达接收端时就变成为非等时的。当接收端存中的分组数达到一定的数量后，再以恒定速率按顺序将这些分组进行还原播放。这样就产生了播放时延，同时也可以在很大程度上消除时延的抖动。 在传送时延敏感的实时数据时，传输时延和时延抖动都必须受到限。通常宁可丢失少量分组，也不要接收太晚到达的分组。 目前互联网提供的音频视频服务有三种类型:(1)流式存储音频视频，用户通过互联网边下载、边播放。(2)流式实况音/视频，其特点是在发送方边录例、边发送，在接收时也是要求能够述续播放。(3)交互式音频视频，如互联网电话或互联网电视会议。 流媒体( streaming media)就是流式音频/视频，其特点是边下载、边播放，但不能存储在硬盘上成为用户的文件。 媒体服务器(或称为流式服务器)可以更好地支持流式音频和视频的传送。TCP能够保证流式音频/视频文件的播放质量，但开始播放的时间要比请求播放的时间滞后一些(必须先在缓存中存储一定数量的分组)。对于实时流式音频视频文件的传送则应当选用UDP。 实时流式协议RTSP是为了给流式过程增加更多功能而设计的协议。RTSP本身并不传送数据，而仅仅是使媒体放器能够控制多媒体流的传送。RTSP又称为“互联网录像机遥控协议” 。 狭义的IP电话是指在IP网络上打电话。广义的IP电话则不仅是电话通信，而且还可以在IP网络上进行交互式多媒体实时通信(包括话音、视像等),甚至还包括即时传信IM(如QQ和ssyp等)。 IP电话的通话质量主要由两个因素决定:(1)通话双方端到端的时延和时延抖动；(2)话音分组的丢失率。但这两个因素都是不确定的，而是取决于当时网络上的通信量。 实时运输协议RTP为实时应用提供端到端的运输，但不提供任何服务质量的保证。需要发送的多媒体数据块(音频/视频)经过压缩编码处理后，先送给RTP封装成为RTP分组，装入运输层的UDP用户数据报后，再向下递交给IP层。可以把RTP看成是在UDP之上的一个运输层子层的协议。 实时运输控制协议RTCP是与RTP配合使用的协议。RTCP协议的主要功能是:服务质量的监视与反馈，媒体间的同步，以及多播组中成员的标志。RTCP分组也使用UDP来传送，但RTCP并不对音频视频分组进行封装。 现在IP电话有两套信令标准。一套是ITU-T定义的H323协议，另一套是ETF提出的会话发起协议SIP。 H323不是一个单独的协议而是一组协议。H323包括系统和构件的描述、呼叫模型的描述、呼叫信令过程、控制报文、复用、话音编解码器、视像编解码器，以及数据协议等。H323标准的四个构件是:(1)H323终端:(2)网关；(3)网间(4)多点控制单元MCU . 会话发起协议SIP只涉及到P电话所需的信令和有关服务质量的间题。SIP使用文本方式的客户服务器协议。SP系统只有两种构件，即用户代理(包括用户代理客户和用户代理服务器)和网络服务器(包括代理服务器和重定向服务器)。SIP的地址十分灵活，它可以是电话号码，也可以是电子邮件地址、IP地址或其他类型的地址。 服务质量QoS是服务性能的总效果，此效果决定了一个用户对服务的满意程度。因此，有服务质量的服务就是能够满足用户的应用需求的服务。或者说，可提供致的、可预计的数据交付服务。 服务质量可用若干基本的性能指标来描述，包括可用性、差错率、响应时间、吞吐量、分组丢失率、连接建立时间、故障检测和改正时间等。服务提供者可向其用户保证某一种等级的服务质量。 为了使互联网具有一定的服务质量，可采取以下一些措施:(1)分类，如区分服务；(2)管制；(3)调度；(4)呼叫接纳；(5)加权公平排队等。 综合服务 Intserv可对单个的应用会话提供服务质量的保证，它定义了两类服务，即有保证的服务和受控负載的服务。Intserv共有以下四个组成部分，即(1)资源预留协议RSVP；(2)接纳控制；(3)分类器；(4)调度器。 区分服务 Diffserv在路由器中增加区分服务的功能，把IP协议中原有的服务类型字段重新定义为区分服务DS，利用DS字段的不同数值提供不同等级的服务质量。Diffserv将所有的复杂性放在DS域的边界结点中，而使DS域内部路由器工作得尽可能地简单。Diffserv定义了在转发分组时体现服务水平的每跳行为PHB，包括EF和AF，即迅速转发PHB和确保转发PHB。 无线网络和移动网络 无线局域网可分为两大类。第一类是有固定基础设施的，第二类是无固定基础设施的 无线局域网的标准是IE的802.11系列。使用802.11系列协议的局域网又称为Wi-Fi。 802.11无线以太网标准使用星形拓扑，其中心叫做接入点AP，它就是基本服务集内的基站。 应当弄清几种不同的接入:固定接入、移动接入、便携接入和游牧接入。 802.11无线以太网在MAC层使用CSMA/CA协议。不能使用CSMA/CD的原因是:在无线局域网中，并非所有的站点都能够听见对方(例如，当有障碍物出现在站点之间时)，因此无法实现碰撞检测。使用 CSMA/CA协议是为了尽量减小碰撞发生的概率。 802.11无线局域网在使用 CSMA/CA的同时，还使用停止等待协议。 8021标准规定，所有的站在完成发送后，必须再等待一段帧间间隔时间才能发送下一帧。帧间间隔的长短取决于该站要发送的帧的优先级。 在802.11无线局域网的MAC帧首部中有一个持续期字段，用来填入在本帧结束后还要占用信道多少时间(以微秒为单位)。 802.11标准允许要发送数据的站对信道进行预约，即在发送数据帧之前先发送RTS帧请求发送。在收到响应允许发送的CTS帧后，就可发送数据帧。 802.1的MAC帧共有三种类型，即控制帧、数据帧和管理帧。需要注意的是，地址字段，即源地址、目的地址和AP地址。MAC帧有四个地址字段。在有固定基础设施的无线局域网中，只使用其中的三个 几种无线网络简介:无线个人区域网(蓝牙系统、 Zigbee和超高速WPAN)。无线城域网 WIMAX。 当计算机移动到外地时，移动IP技术允许该计算机仍然保留其原来的IP地址。移动IP使用了一些新概念，如永久地址、归属地址、归属网络、被访网络或外地网络、归属代理、外地代理、转交地址、同址转交地址等。 移动IP使用了几种协议，如移动站到外地代理的协议，外地代理到归属代理的登记协议，归属代理数据报封装协议，外地代理拆封协议等。 移动IP的路由选择有间接路由选择和直接路由选择，后者需要使用通信者代理和锚外地代理。 蜂窝移动通信网中对移动用户的路由选择需要弄清一些概念:归属位置寄存器HLR和来访用户位置寄存器VLR，移动站漫游号码MSRN，归属网络交换中心，归属MSC，锚MSC，被访网络的MSC。","categories":[{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/categories/读书/"}],"tags":[{"name":"基本功","slug":"基本功","permalink":"https://bigporo.github.io/tags/基本功/"},{"name":"读书","slug":"读书","permalink":"https://bigporo.github.io/tags/读书/"}]}]}