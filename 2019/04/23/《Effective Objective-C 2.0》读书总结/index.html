<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="iOS,读书,">










<meta name="description" content="Objective-C了解 Objective-C 语言的起源Objective-C 语言使用”消息结构”而非”函数调用”.Objective-C 语言由 SmallTalk演化而来,后者是消息类型语言的鼻祖.编译器甚至不关心接收消息对象的何种类型.接收消息的对象问题也要在运行时处理,其过程叫做”动态绑定”. Objective-C为 C 语言添加了面向对象特性,是其超类. Objective-C">
<meta name="keywords" content="iOS,读书">
<meta property="og:type" content="article">
<meta property="og:title" content="《Effective Objective-C 2.0》读书总结">
<meta property="og:url" content="https://bigporo.github.io/2019/04/23/《Effective Objective-C 2.0》读书总结/index.html">
<meta property="og:site_name" content="iDog的精神时光屋">
<meta property="og:description" content="Objective-C了解 Objective-C 语言的起源Objective-C 语言使用”消息结构”而非”函数调用”.Objective-C 语言由 SmallTalk演化而来,后者是消息类型语言的鼻祖.编译器甚至不关心接收消息对象的何种类型.接收消息的对象问题也要在运行时处理,其过程叫做”动态绑定”. Objective-C为 C 语言添加了面向对象特性,是其超类. Objective-C">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1840079-f235ec86a8734f5e.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1840079-efc5d33752ba9003.png">
<meta property="og:updated_time" content="2019-04-24T09:12:31.717Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《Effective Objective-C 2.0》读书总结">
<meta name="twitter:description" content="Objective-C了解 Objective-C 语言的起源Objective-C 语言使用”消息结构”而非”函数调用”.Objective-C 语言由 SmallTalk演化而来,后者是消息类型语言的鼻祖.编译器甚至不关心接收消息对象的何种类型.接收消息的对象问题也要在运行时处理,其过程叫做”动态绑定”. Objective-C为 C 语言添加了面向对象特性,是其超类. Objective-C">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/1840079-f235ec86a8734f5e.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bigporo.github.io/2019/04/23/《Effective Objective-C 2.0》读书总结/">





  <title>《Effective Objective-C 2.0》读书总结 | iDog的精神时光屋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/BigPoro" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">iDog的精神时光屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigporo.github.io/2019/04/23/《Effective Objective-C 2.0》读书总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iDog">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://ws2.sinaimg.cn/large/006tNc79ly1g2b8vkark5j304z050wel.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iDog的精神时光屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《Effective Objective-C 2.0》读书总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-23T17:17:43+08:00">
                2019-04-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书/" itemprop="url" rel="index">
                    <span itemprop="name">读书</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  25
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h2><h3 id="了解-Objective-C-语言的起源"><a href="#了解-Objective-C-语言的起源" class="headerlink" title="了解 Objective-C 语言的起源"></a>了解 Objective-C 语言的起源</h3><p>Objective-C 语言使用”消息结构”而非”函数调用”.Objective-C 语言由 SmallTalk演化而来,后者是消息类型语言的鼻祖.编译器甚至不关心接收消息对象的何种类型.接收消息的对象问题也要在运行时处理,其过程叫做”动态绑定”.</p>
<p>Objective-C为 C 语言添加了面向对象特性,是其超类. Objective-C 使用动态绑定的消息结构,也就是说,在运行时才会检查对象类型.接收一条消息后,究竟应执行何种代码,有运行期环境而非编译器决定.理解 C 语言的核心有助于写好 Objective-C 程序.尤其是掌握内存模型与指针.</p>
<a id="more"></a>
<h3 id="在类的头文件中尽量少引用其他头文件"><a href="#在类的头文件中尽量少引用其他头文件" class="headerlink" title="在类的头文件中尽量少引用其他头文件"></a>在类的头文件中尽量少引用其他头文件</h3><p>Objective-C 语言编写类的标准行为:以类名做文件名,分别闯将两个文件,有文件后缀用. h,实现文件后缀用. m.</p>
<p>在开发中有时候我们会在. h 文件中引入很多用不到的内容,这当然会增加编译时间.除非有必要,否则不要引入头文件,一般来说,某个类的头文件中使用向前声明来体积别的类,并在实现文件中引入哪些类的头文件,这样做可以尽量降低类之间的耦合.有时无法使用<strong>向前声明</strong>,比如要声明某个类遵循意向协议,这种情况下,尽量把 “该类遵循某协议”的这条声明移至 class=continuation 分类中,如果不行的话,就把协议单独存放在一个头文件中,然后将其引入.</p>
<h3 id="多用字面量语法-少用与之等价的方法"><a href="#多用字面量语法-少用与之等价的方法" class="headerlink" title="多用字面量语法,少用与之等价的方法"></a>多用字面量语法,少用与之等价的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *arr = [NSArray arrayWithObjects:@&quot;num1&quot;,@&quot;num2&quot;,@&quot;num3&quot;, nil];</span><br><span class="line">NSArray *arr = @[@&quot;num1&quot;,@&quot;num2&quot;,@&quot;num3”];</span><br></pre></td></tr></table></figure>
<p>字面量语法创建字符串,数组,数值,字典.与创建此类对象的常规方法相比,这么做更加简明扼要，并且更加安全。</p>
<blockquote>
<p> 注意事项:</p>
</blockquote>
<ul>
<li><p>除了字符串以外,所创建的类必须属于 Foundation 框架才行,如果自定义了这些类的子类,则无法用字面量语法创建其对象.</p>
</li>
<li><p>创建的数组或字典时,若值有 nil, 则会抛出异常.因此,务必确保值中不含 nil。</p>
</li>
</ul>
<h3 id="多用类型常量-少用-deine-预处理指令"><a href="#多用类型常量-少用-deine-预处理指令" class="headerlink" title="多用类型常量,少用# deine 预处理指令"></a>多用类型常量,少用# deine 预处理指令</h3><p>不要用预处理指令定义常量,这样定义出来的常量不含类型信息,编译器只会在编译前根据执行查找与替换操作,即使有人重新定义了常量值,编译器也不会产生井道信息,这将导致应用程序常量值不一致.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static NSString *const PersonConstant = @&quot;PersonConstantStr” ;</span><br></pre></td></tr></table></figure>
<p>但是我个人认为其实,还是#define用的多, 开发避免不了使用 pch文件, 同时#define还可以定义方法，这个是类型常量无法做到的。 如果有强迫症的同学,定义常量就想使用 staitc,extren,const 这些关键字.那我建议新建一个专门存放这些常量的类,然后在 pch 中导入这个类.</p>
<blockquote>
<ul>
<li>static 修饰符意味着该变量仅在定义此变量的单元中可见</li>
<li>extern 全局变量</li>
</ul>
</blockquote>
<h3 id="用枚举表示状态-选项-状态码"><a href="#用枚举表示状态-选项-状态码" class="headerlink" title="用枚举表示状态,选项,状态码"></a>用枚举表示状态,选项,状态码</h3><p>应该用枚举来表示状态机的状态,传递给方法的选项以及状态码等值,给这些值起个易懂的名字。</p>
<p>如果把传递的给某个方法的选项表示为枚举类型，而多个类型又可同时使用，那么就将各选项值定义为2的幂，通过按位或操作将其结合起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum PersonEnum&#123;</span><br><span class="line">PersonEnumNum1,</span><br><span class="line">PersonEnumNum2,</span><br><span class="line">PersonEnumNum3,</span><br><span class="line">&#125;;</span><br><span class="line">typedef enum PersonEnum PersonState;</span><br></pre></td></tr></table></figure>
<h2 id="对象、消息、运行时"><a href="#对象、消息、运行时" class="headerlink" title="对象、消息、运行时"></a>对象、消息、运行时</h2><h3 id="理解属性这一概念"><a href="#理解属性这一概念" class="headerlink" title="理解属性这一概念"></a>理解属性这一概念</h3><p>属性是 Objective-C 的一项特性,用于封存对象中的数据.<br>属性特质:原子性 读写权限</p>
<blockquote>
<p>内存管理语义:</p>
</blockquote>
<ul>
<li>assign 这是方法只会执行针对纯量类型(CGFloat,NSInteger)的简单赋值操作</li>
<li>strong 此特质表明该属性定义一种拥有关系,为这种属性设置新值时,这只方法会先保存新值,并释放旧值</li>
<li>weak 此特质表明属性定义了一种”非拥有关系”,为这种属性设置新值是,设置方法既不保留新值,也不释放旧值.此特质同 assign 类似,然而在属性所指对象遭到摧毁时,属性值会清空</li>
<li>unsafe_unretainde 此特质与 assign 相同,它适用于对象类型,该特质表达一种”非拥有关系”,当目标对象遭到摧毁时,属性不会自动清空,因为它是不安全的,这一点与 weak 的区别</li>
<li>copy 此特质所表达的所属关系与 strong 类似,然而设置方法并不保留新值,而是将其拷贝,多用于 NSString.</li>
</ul>
<h3 id="在对象内部尽量直接访问实例变量"><a href="#在对象内部尽量直接访问实例变量" class="headerlink" title="在对象内部尽量直接访问实例变量"></a>在对象内部尽量直接访问实例变量</h3><p>直接访问实例变量的速度比较快,因为不经过 Objective-C 方法派发,编译器所生成的代码会直接访问保存催下实例量的那块内存。<br>直接访问实例变量时,不会调用设置方法,这就绕过了相关属性所定义的内存管理语义。</p>
<p><strong>读取实例变量的时候采用直接访问的的形式，设置实例变量的时候通过属性来做。</strong></p>
<blockquote>
<p>注意：</p>
<ul>
<li>直接访问访问实例变量，不会触发KVO。</li>
<li>懒加载时，必须通过属性来读取数据。</li>
</ul>
</blockquote>
<h3 id="理解”对象等同性”这一概念"><a href="#理解”对象等同性”这一概念" class="headerlink" title="理解”对象等同性”这一概念"></a>理解”对象等同性”这一概念</h3><p>根据等同性来比较对象是一个非常有用的功能,不过,<strong>按照 == 操作符比较出来的结果未必是我们想要的,因为该操作比较的事两个指针本身,而不是其所指的对象</strong>，应该使用 NSObject 协议中的声明的”isEqual”方法来判断两个对象的等同性,一般来说两个类型不同的对象总是不相等的.直接比较字符串的时候 isEqual 比 isEqualToString慢,因为前者还要执行额外步骤.</p>
<p>NSObjec中有两个判断等同性的关键方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL) isEqual:(id)object;</span><br><span class="line">- (NSUInteger)hash;</span><br></pre></td></tr></table></figure></p>
<h3 id="以”类族模式”隐藏实现细节"><a href="#以”类族模式”隐藏实现细节" class="headerlink" title="以”类族模式”隐藏实现细节"></a>以”类族模式”隐藏实现细节</h3><p>“类族”是一种很有用的模式,可以隐藏抽象基类背后实现的细节. 这是一种”工厂模式”.比如iOS 用户界面框架 UIKit 中就有一个名为 UIButton 的类.想创建按钮,需要调用下面这个类方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (UIButton*)buttonWithType:(UIButtonType)type;</span><br></pre></td></tr></table></figure></p>
<h3 id="在既有类中使用关联对象存放自定义数据"><a href="#在既有类中使用关联对象存放自定义数据" class="headerlink" title="在既有类中使用关联对象存放自定义数据"></a>在既有类中使用关联对象存放自定义数据</h3><p>有时需要在对象中存放相关信息,这是我们通常会从对象所属的类中继承一个子类,然后改用这个子类对象.然而并非所有情况下都这么做,有时候类的实例可能是由某种机制所创建的,而开发者无法令这种机制创建出自己所写的实例. Objective-C 中有一项强大的特性可以解决问题,这就是关联对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//关联对象</span><br><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</span><br><span class="line">//获取关联的对象</span><br><span class="line">id objc_getAssociatedObject(id object, const void *key)</span><br><span class="line">//移除关联的对象</span><br><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure>
<h3 id="理解objc-msgSend的作用"><a href="#理解objc-msgSend的作用" class="headerlink" title="理解objc_msgSend的作用"></a>理解objc_msgSend的作用</h3><p>用Objetive-C的术语来说，这叫做“消息传递”。这里说的是运行时。</p>
<h3 id="理解消息转发机制"><a href="#理解消息转发机制" class="headerlink" title="理解消息转发机制"></a>理解消息转发机制</h3><p>当对象接收到无法解读的消息后，就会启动消息转发机制，程序员可经此过程告诉对象应该图和处理未知消息。这里说的是运行时。</p>
<ol>
<li><p>动态方法解析 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">/**</span><br><span class="line">动态消息转发</span><br><span class="line">if (sel == @selector(foo:)) &#123;</span><br><span class="line">class_addMethod([self class], sel, (IMP)fooMethod, &quot;v@:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return [super resolveInstanceMethod:sel];</span><br><span class="line">*/</span><br><span class="line">return YES; // 进入下一步转发</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>备用接收者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">/**</span><br><span class="line">备用接收者</span><br><span class="line"></span><br><span class="line">if (aSelector == @selector(foo)) &#123;</span><br><span class="line">return [Person new]; // 返回一个Person实例作为备用接收者</span><br><span class="line">&#125;</span><br><span class="line">return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">*/</span><br><span class="line">return nil; // 进入下一步转发</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完整的消息转发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">if (aSelector == @selector(foo)) &#123;</span><br><span class="line">return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];//签名，进入forwardInvocation</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">SEL sel = anInvocation.selector;</span><br><span class="line">Person *person = [Person new];</span><br><span class="line">if ([person respondsToSelector:sel]) &#123;</span><br><span class="line">[anInvocation invokeWithTarget:person]; // 直接调用 person 的 foo 方法</span><br><span class="line">&#125;else&#123;</span><br><span class="line">[self doesNotRecognizeSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="用方法调配技术调试黑盒方法"><a href="#用方法调配技术调试黑盒方法" class="headerlink" title="用方法调配技术调试黑盒方法"></a>用方法调配技术调试黑盒方法</h3><p>运行期间，可以向类中新增或替换选择子所对应的方法实现。<br>使用另一份实现来替换原有的方法实现，这道工序叫做方法调配，开发者常用此技术想原有实现中添加新功能。<br>一般来说，只有调试程序的时候才需要运行期修改方法实现，这种做法不易滥用。这里说的是<strong>方法交换</strong>。</p>
<h3 id="理解类对象的用意"><a href="#理解类对象的用意" class="headerlink" title="理解类对象的用意"></a>理解类对象的用意</h3><p>每个Objective-C对象实例都是指向某块内存数据的指针，如果把对象所需的内存分配到栈上编译器就会报错.</p>
<p>每个对象结构体的首个成员是Class类的变量，该变量定义了对象所属的类，通常称为isa指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *class</span><br><span class="line">struct objc_class&#123;</span><br><span class="line">Class isa;</span><br><span class="line">Class super_class;</span><br><span class="line">const char* name;</span><br><span class="line">long version;</span><br><span class="line">long info;</span><br><span class="line">long instance_size;</span><br><span class="line">struct objc_ivar_list *ivars;</span><br><span class="line">struct objc_method_list *ivars;</span><br><span class="line">struct objc_cache *cache;</span><br><span class="line">struct objc_protocol_list protocols;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此结构体存放类的元数据，例如类的实例实现了几个方法，具备多少个实例变量等信息。此结构体的首个变量也是isa指针，这说明Class本身亦为Objctive-C对象。结构体里还有个变量叫做super_class,它定义本类的超类，类对象所属的类型（isa指针所指向的类型）是另外一个类，叫做元类，用来标书类本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法，每个类仅有一个类对象，每个类对象仅有一个与之相关的元类。（元数据，就是这个类的数据）。</p>
<blockquote>
<ul>
<li>isKindOfClass：能够判断对象是否为某类或其派生类的实例</li>
<li>isMemberOfClass: 能够判断出对象是否为某个特定类的实例</li>
</ul>
</blockquote>
<h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><h3 id="用前缀避免命名空间冲突"><a href="#用前缀避免命名空间冲突" class="headerlink" title="用前缀避免命名空间冲突"></a>用前缀避免命名空间冲突</h3><p>Objective-C没有其他语言那种内置的命名空间，所以需要避免命名冲突，否则会直接报错。</p>
<h3 id="提供全能初始化方法"><a href="#提供全能初始化方法" class="headerlink" title="提供全能初始化方法"></a>提供全能初始化方法</h3><p>即可以为对象提供必要信息以便其完成能完成工作的初始化方法。</p>
<blockquote>
<p>注意：如果子类的全能初始化方法与父类的不一致，就应该覆写父类的全能初始化方法。有时我们不想覆写，这时我们可以覆写父类的全能初始化方法并在里面抛出异常。</p>
</blockquote>
<h3 id="实现description方法"><a href="#实现description方法" class="headerlink" title="实现description方法"></a>实现description方法</h3><p>调试程序时经常需要打印并查看对象信息。description 很实用。</p>
<p><strong>debugDescription</strong> 方法是开发者在调试器中以命令打印对象时候才调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Person.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property(nonatomic,assign)int age;</span><br><span class="line">@property(nonatomic ,copy)NSString* name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">Person.m</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">@implementation Person</span><br><span class="line">- (NSString *)description</span><br><span class="line">&#123;</span><br><span class="line">return [NSString stringWithFormat:@&quot;name %@ , age %d&quot;, self.name, self.age];</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)debugDescription</span><br><span class="line">&#123;</span><br><span class="line">return [NSString stringWithFormat:@&quot;name %@ , age %d&quot;, self.name, self.age];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<h3 id="尽量使用不可变对象"><a href="#尽量使用不可变对象" class="headerlink" title="尽量使用不可变对象"></a>尽量使用不可变对象</h3><p>通过<strong>readonly</strong>将属性修饰为不可变，如果想修改封装在对象内部的数据，可以在对象的内部将<strong>readonly</strong>属性重新声明为<strong>readwrite</strong>。</p>
<blockquote>
<p>注意:readonly修饰的属性，仍然可以使用KVC来修改。</p>
</blockquote>
<h3 id="使用清晰而协调的全名方式"><a href="#使用清晰而协调的全名方式" class="headerlink" title="使用清晰而协调的全名方式"></a>使用清晰而协调的全名方式</h3><p>没啥好说的</p>
<h3 id="为私有方法名加前缀"><a href="#为私有方法名加前缀" class="headerlink" title="为私有方法名加前缀"></a>为私有方法名加前缀</h3><p>不要单用一个下划线给私有方法做前缀，这个是苹果爸爸用的。</p>
<h3 id="理解Objective-C错误模型"><a href="#理解Objective-C错误模型" class="headerlink" title="理解Objective-C错误模型"></a>理解Objective-C错误模型</h3><p>NSError的用法更加灵活，因此经由此对象，我们可以把导致错误的原因汇报给调用者。</p>
<ul>
<li>NSError domain(错误范围，其类型为字符串)<br>错误发生的范围，也就是产生错误的根源，通常用一个特有的全局变量来定义，比方说 “处理URL子系统”从URL的解析获取数据时如果出错了，那么就会使用NSURLErrorDomain来表示错误范围</li>
<li>Error code(错误码，其类型为整数)<br>独有的错误代码，用以指明在某个范围内具体发生了何种错误。某个特性范围内可能会发生一系列相关错误，这些错误情况通常采用enum来定义。例如，当HTTP请求出错时，可能会把HTTP状态码设为错误码</li>
<li>User info(用户信息，其类型为字典)<br>有关错误的额外信息，其中或许包含一段“本地化的描述”或许还含有导致错误发生的另外一个错误，经由此种信息，可将相关错误串成一条“错误链”</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@try &#123;</span><br><span class="line">NSString *str = @&quot;wotaxiwa&quot;;</span><br><span class="line">NSString *strErr = [str substringFromIndex:100];</span><br><span class="line">NSLog(@&quot;%@&quot;,str);</span><br><span class="line">&#125; @catch (NSException *exception) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;ERROR:     %@&quot;,exception);</span><br><span class="line">&#125; @finally &#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果出现exception，异常后面的代码将不会继续执行</span><br></pre></td></tr></table></figure>
<h3 id="理解NSCopying协议"><a href="#理解NSCopying协议" class="headerlink" title="理解NSCopying协议"></a>理解NSCopying协议</h3><ul>
<li>copy方法实际上是调用 -(id)copyWithZone:(NSZone*)zone; 实现copy操作，  如果想对自己的类支持拷贝并且做额外操作，那就要实现NSCopying协议此的方法。<br>为何出现NSZone呢，以前开发程序时，会据此把内存分成不用的区，而对象会创建在某个区。 现在不用了，每个程序只有一个区：“默认区”，所以不用担心zone参数。<br>copy方法由NSObject实现，该方法只是以默认区为参数调用。</li>
<li>mutableCopy方法实际上是调用 -(id)mutableCopyWithZone:(NSZone*)zone; 实现mutableCopy操作</li>
</ul>
<h2 id="协议与分类"><a href="#协议与分类" class="headerlink" title="协议与分类"></a>协议与分类</h2><h3 id="通过委托与数据协议进行对象间通信"><a href="#通过委托与数据协议进行对象间通信" class="headerlink" title="通过委托与数据协议进行对象间通信"></a>通过委托与数据协议进行对象间通信</h3><p>这一条说的就是delegate(代理设计模式)。但是并没有说delegate的循环引用的问题,在使用代理声明一个 @property的时候，记得用weak。</p>
<h3 id="将类的实现代码分散到便于管理的数个分类之中"><a href="#将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="将类的实现代码分散到便于管理的数个分类之中"></a>将类的实现代码分散到便于管理的数个分类之中</h3><ul>
<li>使用分类机制把类的实现代码划分成易于管理的小块</li>
<li>将应该视为“私有”的方法归入名为Private的分类中，以隐藏细节。</li>
</ul>
<h3 id="勿在分类中声明属性"><a href="#勿在分类中声明属性" class="headerlink" title="勿在分类中声明属性"></a>勿在分类中声明属性</h3><p>正常的分类是不可以声明属性的，但是从技术上说，分类里可以用runtime声明属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc.runtime.h&gt;</span><br><span class="line">static const char *kFriendsPropertyKey = “kFriendsPropertyKey”;</span><br><span class="line">@implementation EOCPerson(Friendship)</span><br><span class="line">-(NSArray*)friends&#123;</span><br><span class="line">return objc_getAssociatedObject(self,kFriendsPropertyKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)setFriends:(NSArray*)friends&#123;</span><br><span class="line">objc_setAssociateObject(self.kFriendsPropertyKey,friends,OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这样做可行，但是不太理想，要把相似的代码写很多遍。而且容易出现Bug，可以使用class-continuation实现分类添加属性。</p>
<h3 id="使用class-continuation分类隐藏实现细节"><a href="#使用class-continuation分类隐藏实现细节" class="headerlink" title="使用class-continuation分类隐藏实现细节"></a>使用class-continuation分类隐藏实现细节</h3><p>class-continuation分类和普通的分类不同，它必须在其所接续的那个类的实现文件里。其重要之处在于，这是唯一能声明实例变量的分类，而且此分类没有特定的实现文件，其中的方法应该定义在类的主实现文件里。与其他分类不同，“class-continuation分类”没有名字，比如，有个类叫做EOCPerson，其“class-continuation分类”写法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@interface EOCPerson()</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">[super didReceiveMemoryWarning];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>没错它就是 class-continuation分类，在此代码之间可以添加属性，修改属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用class-continuation分类的好处</p>
</blockquote>
<ul>
<li>可以向类中新增实例变量。</li>
<li>如果类中的主接口声明为只读，可以再类内部修改此属性。</li>
<li>把私有方法的原型文件生命在”class-continuation分类”里面。</li>
<li>想使类遵循的协议不为人知，可以用“class-continuation分类”中声明。</li>
</ul>
<h3 id="通过协议提供匿名对象"><a href="#通过协议提供匿名对象" class="headerlink" title="通过协议提供匿名对象"></a>通过协议提供匿名对象</h3><p>就说下面这句话<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,weak)id&lt;PersonDelegate&gt; pd;</span><br></pre></td></tr></table></figure></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="理解引用计数"><a href="#理解引用计数" class="headerlink" title="理解引用计数"></a>理解引用计数</h3><p>理解引用计数，方便于了解iOS的内存管理。不过现在都是ARC的时代了。</p>
<p>引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当保存计数降为0，对象就被销毁了。</p>
<p>在对象生命期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。</p>
<h3 id="以ARC简化引用计数"><a href="#以ARC简化引用计数" class="headerlink" title="以ARC简化引用计数"></a>以ARC简化引用计数</h3><p>使用ARC要计数，引用计数实际上还是要执行的，只不过保留与释放操作现在由ARC自动为你添加。由于ARC会自动执行retain、release、autorelease等操作，所以直接在ARC下调用这些内存管理方法是非法的。</p>
<p>ARC管理对象生命周期的的办法基本就是：在合适的位置插入“保留”和“释放”操作。</p>
<p>ARC在调用这些方法时，并不用过普通的Objective-C消息派发机制，而是直接调用其底层C语言版本，这样做性能更好，直接调用底层函数节省很多CPU周期。</p>
<p>虽然有了ARC之后无需担心内存管理问题，但是<strong>CoreFoundation对象不归ARC管理，开发者必须适时调用CFRetain/CFRelease</strong>。</p>
<h3 id="在dealloc方法中只释放引用并解除监听"><a href="#在dealloc方法中只释放引用并解除监听" class="headerlink" title="在dealloc方法中只释放引用并解除监听"></a>在dealloc方法中只释放引用并解除监听</h3><ul>
<li><p>当一个对象销毁的时候会调用dealloc方法，但是当开销较大或系统内稀缺资源则不再此列，像是文件描述、套接字、大块内存等都属于这种资源，通常对于开销较大的资源实现一个方法，当程序用完资源对象后，就调用此方法。这样一来，资源对象的生命期就变得明确了。</p>
</li>
<li><p>执行异步任务的方法不应该在dealloc里面调用；只能在正常状态下调用的那些方法也不应该调用，因为此时对象已经处于正在回收的状态了。</p>
</li>
</ul>
<h3 id="编写“异常安全代码”时留意内存管理问题"><a href="#编写“异常安全代码”时留意内存管理问题" class="headerlink" title="编写“异常安全代码”时留意内存管理问题"></a>编写“异常安全代码”时留意内存管理问题</h3><ul>
<li>在使用@try 的时也要注意，在捕获到异常的时候@try{}中的语句执行到异常代码的那一行后不在执行，然后把异常抛给@catch。当然@finally是一定要执行的。</li>
<li>在默认情况下，ARC不生成安全处理异常所需的清理代码。开启编译器标志后，可以生成这种代码，不过会导致应用程序变大，而且会降低运行效率。</li>
</ul>
<h3 id="以弱引用避免保留环"><a href="#以弱引用避免保留环" class="headerlink" title="以弱引用避免保留环"></a>以弱引用避免保留环</h3><ul>
<li>unsafe_unretained 语义同assign等价。然而assign通常用于int、float、结构体等。unsafe_unretained多用于对象类型。</li>
<li>weak 与 unsafe_unretained 作用相同，然而只要系统把属性回收，属性值为nil。<br>推荐使用weak，毕竟是ARC时代的产物，而且用的人也很多。</li>
</ul>
<h3 id="以“自动释放池块”降低内存峰值"><a href="#以“自动释放池块”降低内存峰值" class="headerlink" title="以“自动释放池块”降低内存峰值"></a>以“自动释放池块”降低内存峰值</h3><p>自动释放池排布在栈中，对象收到autorelease消息后，系统将其放入最顶端的池里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">&lt;#statements#&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">NSNumber *num = [NSNumber numberWithInt:i];</span><br><span class="line">NSString *str = [NSString stringWithFormat:@&quot;%d &quot;, i];</span><br><span class="line">[NSString stringWithFormat:@&quot;%@%@&quot;, num, str];</span><br><span class="line"></span><br><span class="line">if(lagerNum-1 == i)</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="用“僵尸对象”调试内存管理问题"><a href="#用“僵尸对象”调试内存管理问题" class="headerlink" title="用“僵尸对象”调试内存管理问题"></a>用“僵尸对象”调试内存管理问题</h3><p>在左上角标题栏找到项目单击后选择 Edit scheme 勾选图中检测僵尸对象。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1840079-f235ec86a8734f5e.png" alt></p>
<ul>
<li>开启后，系统在回收对象的时候，可以不真的将其回收，而是转成僵尸对象。</li>
<li>系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使该对象变成僵尸对象。僵尸类能响应所有的方法，响应方式为：打印一条包含消息内容及其接受者的消息，然后终止应用程序。</li>
</ul>
<h3 id="不要使用retainCount"><a href="#不要使用retainCount" class="headerlink" title="不要使用retainCount"></a>不要使用retainCount</h3><ul>
<li>任何给定时间点上的“绝对保留计数”都无法反应对象生命周期的全貌。</li>
<li>ARC的时代，调用该方法会直接报错。</li>
</ul>
<h2 id="块与大中枢派发"><a href="#块与大中枢派发" class="headerlink" title="块与大中枢派发"></a>块与大中枢派发</h2><h3 id="理解”块“这一概念"><a href="#理解”块“这一概念" class="headerlink" title="理解”块“这一概念"></a>理解”块“这一概念</h3><p>这里其实就是在说block，复习一下block的语法：<br>返回值类型（block名称)(参数)</p>
<ul>
<li><p>需要注意的是<strong>定义block时候，其所占内存区域是分配在栈中的</strong>，块只在定义它的那个范围内有效。</p>
</li>
<li><p>block所使用的整个内存区域，在编译期已经完全确定，因此，全局block可以生命在全局内存里，而不需要在每次用到的时候于栈中创建，另外，全局block的拷贝是个空操作，因为全局block绝不可能为系统所回收，这种block实际上相当于单例。</p>
</li>
<li><p>可以调用 copy 方法将块从栈拷贝到堆，拷贝之后的块就可以在定义它的范围之外使用了。而且，拷贝到堆以后，块就变成带引用计数的对象了，后续的copy操作不会真的执行，只是递增引用计数。</p>
</li>
</ul>
<h3 id="为常用的块类型创建typedef"><a href="#为常用的块类型创建typedef" class="headerlink" title="为常用的块类型创建typedef"></a>为常用的块类型创建typedef</h3><p>就是给block起个别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef &lt;#returnType#&gt;(^&lt;#name#&gt;)(&lt;#arguments#&gt;);</span><br><span class="line">@property (nonatomic,copy)name nm_blk;</span><br></pre></td></tr></table></figure></p>
<h3 id="用handler块降低代码分散程度"><a href="#用handler块降低代码分散程度" class="headerlink" title="用handler块降低代码分散程度"></a>用handler块降低代码分散程度</h3><p>说的就是block的回调。只不过是把block放在方法中去使用,使代码更加紧致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//  Person.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">typedef void(^Blk)(NSString *name,int age);</span><br><span class="line">@interface Person : NSObject</span><br><span class="line">-(void)handler:(Blk)blk;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  Person.m</span><br><span class="line">#import &quot;Person.h</span><br><span class="line">@implementation Person</span><br><span class="line">-(void)handler:(Blk)blk&#123;</span><br><span class="line">if(blk)&#123;</span><br><span class="line">blk(@&quot;zhangsan&quot; ,28);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  使用</span><br><span class="line">Person *per =[Person new];</span><br><span class="line">[per handler:^(NSString *name, int age) &#123;</span><br><span class="line">NSLog(@&quot;%@ %d&quot;,name, age);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="用块引用其所属对象时不要出现保留环"><a href="#用块引用其所属对象时不要出现保留环" class="headerlink" title="用块引用其所属对象时不要出现保留环"></a>用块引用其所属对象时不要出现保留环</h3><p>注意用weak，不要出现循环引用。</p>
<h3 id="多用派发队列，少用同步锁"><a href="#多用派发队列，少用同步锁" class="headerlink" title="多用派发队列，少用同步锁"></a>多用派发队列，少用同步锁</h3><p>派发队列可用来表述同步语义，这种做法比使用@synchronize块或NSLock对象更简单<br>将同步与异步派发结合起来，可以实现与普通枷锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程。</p>
<p>使用同步队列及栅栏块，可以令同步行为更加高效（不常用）。</p>
<h3 id="多用GCD，少用performSelector系列方法"><a href="#多用GCD，少用performSelector系列方法" class="headerlink" title="多用GCD，少用performSelector系列方法"></a>多用GCD，少用performSelector系列方法</h3><p>这个没啥可说的</p>
<h3 id="掌握GCD及操作队列的适用时机"><a href="#掌握GCD及操作队列的适用时机" class="headerlink" title="掌握GCD及操作队列的适用时机"></a>掌握GCD及操作队列的适用时机</h3><p>这个没啥可说的</p>
<p>解决多线程与任务管理问题时，派发队列并非唯一方案</p>
<p>操作队列提供了一套高层的Objective-C API</p>
<p>能实现纯GCD所具备的绝大部分功能，而且还完成一些更为复杂的操作，那些操作弱改用GCD来实现，则需另外编写代码。</p>
<p>使用NSOperation对线程管理</p>
<h3 id="通过Dispatch-Group机制，根据系统资源状况来执行任务"><a href="#通过Dispatch-Group机制，根据系统资源状况来执行任务" class="headerlink" title="通过Dispatch Group机制，根据系统资源状况来执行任务"></a>通过Dispatch Group机制，根据系统资源状况来执行任务</h3><p>这个没啥可说的<br>一系列任务可归入一个dispatch group之中。开发者可以在这组任务执行完毕时获得通知<br>通过dispatch group，可以在并发式派发队列里同时执行多项任务。此时GCD会根据系统西苑状况来调度这些并发执行的任务。开发者若自己来实现此功能。则需要便携大量代码。</p>
<h3 id="使用dispatch-once来执行秩序运行一次的线程安全代码"><a href="#使用dispatch-once来执行秩序运行一次的线程安全代码" class="headerlink" title="使用dispatch_once来执行秩序运行一次的线程安全代码"></a>使用dispatch_once来执行秩序运行一次的线程安全代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">&lt;#code to be executed once#&gt;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="不用使用dispatch-get-current-queue"><a href="#不用使用dispatch-get-current-queue" class="headerlink" title="不用使用dispatch_get_current_queue"></a>不用使用dispatch_get_current_queue</h3><p>这个没啥可说的。<br>iOS系统6.0版本起，已经正式弃用此函数了。</p>
<h2 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h2><h3 id="熟悉系统框架"><a href="#熟悉系统框架" class="headerlink" title="熟悉系统框架"></a>熟悉系统框架</h3><p>打开Xcode command + shift + 0 选择性的了解一些 Foundation、UIKit<br>也可以看看这篇博客 <a href="http://www.jianshu.com/p/58bc11c800e4" target="_blank" rel="noopener">http://www.jianshu.com/p/58bc11c800e4</a></p>
<h3 id="多用块枚举，少用for循环"><a href="#多用块枚举，少用for循环" class="headerlink" title="多用块枚举，少用for循环"></a>多用块枚举，少用for循环</h3><p>因为枚举遍历的时候用的多线程（GCD并发执行），所以效率更快些。我觉得其实用什么都行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSArray *arr = @[@&quot;b&quot;,@&quot;c&quot;,@&quot;s&quot;];</span><br><span class="line">[arr enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="对自定义其内存管理语义的collection使用无缝桥接"><a href="#对自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="对自定义其内存管理语义的collection使用无缝桥接"></a>对自定义其内存管理语义的collection使用无缝桥接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSArray *anNSArray = @[@1,@3,@5,@8];</span><br><span class="line">CFArrayRef acFArray =  (__bridge CFArrayRef)anNSArray;</span><br><span class="line">NSLog(@&quot;%@&quot;,acFArray);</span><br></pre></td></tr></table></figure>
<p>通过无缝桥接技术，可以在Foundation框架中Objective-C对象与CoreFoundation框架中的C语言数据结构之间来回转换。</p>
<p>在CoreFoundation层面穿件collection时，可以指定许多回调函数，这些函数表示此collection应如何处理其元素，然后可运用无缝桥接技术，将其转换成具备特殊内存管理语义的Objective-C collection。</p>
<ul>
<li>__bridge:ARC仍然具备这个OC对象的所有权</li>
<li><strong>bridge</strong>retained:ARC将交出对象的所有权</li>
</ul>
<h3 id="构建缓存时选用NSCache而非NSDictionary"><a href="#构建缓存时选用NSCache而非NSDictionary" class="headerlink" title="构建缓存时选用NSCache而非NSDictionary"></a>构建缓存时选用NSCache而非NSDictionary</h3><ul>
<li>NSCache胜过NSDictionary之处在于，当系统资源耗尽时，它能自动删减缓存。</li>
<li>NSCache线程安全</li>
</ul>
<h3 id="精简Initialize与load的实现代码"><a href="#精简Initialize与load的实现代码" class="headerlink" title="精简Initialize与load的实现代码"></a>精简Initialize与load的实现代码</h3><p>类初始化的时候一定会调用两个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+(void)load&#123;&#125;</span><br><span class="line"></span><br><span class="line">+ (void)initialize</span><br><span class="line">&#123;</span><br><span class="line">if (self == [&lt;#ClassName#&gt; class]) &#123;</span><br><span class="line">&lt;#statements#&gt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>load方法只会调用一次，不管该类的头文件有没有被使用，该类都会被系统自动调用，而且只调用一次。 当然了，如果不重写这个方法的话，我们是不知道这个方法有没有被调用的。如果分类也重写了load方法，先调用类里的，在调用分类。</li>
<li>load方法执行时，运行期系统处于“脆弱状态”，在执行子类的load方法之前，必定会先执行所以超类的load方法，而如果代码还依赖了其他的库，那么其他库的相关类的load方法一定会先执行，但是执行的顺序不好判断，所以在load方法中使用其他类是不安全的。</li>
<li>整个程序在执行load方法时都会阻塞。</li>
<li>initialize 和load类似，不过在类被初始化的时候才会被调用（init之前）。需要注意的是，&lt;#ClassName#&gt;如果有子类继承的时候要判断类名。</li>
<li>两个方法的实现都应该精简些，这有助于保持应用程序的响应能力。</li>
</ul>
<h3 id="别忘了NSTimer会保留其目标对象"><a href="#别忘了NSTimer会保留其目标对象" class="headerlink" title="别忘了NSTimer会保留其目标对象"></a>别忘了NSTimer会保留其目标对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//  Person.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic,strong)NSTimer *timer;</span><br><span class="line">-(void)start;</span><br><span class="line">-(void)stop;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  Person.m</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">-(void)start&#123;</span><br><span class="line">self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(run) userInfo:nil repeats:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)run&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)dealloc&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)stop&#123;</span><br><span class="line">[self.timer invalidate];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">调用</span><br><span class="line">@property (nonatomic,strong)Person *person;</span><br><span class="line"></span><br><span class="line">self.person = [Person new];</span><br><span class="line">[self.person start];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">[self.person stop];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好，那么问题来了，是不是没有调用dealloc方法，没有调用dealloc方法就说明Person对象并没有被销毁，为什么没有被销毁<br>因为在控制器强引用了self.person，[self.person start]强引用了 self.timer; self.timer 的target指向了self（self.person）所以循环引用了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1840079-efc5d33752ba9003.png" alt></p>
<p>怎么解决。 NSTimer销毁的时候，把Person对象为nil即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">[self.person stop];</span><br><span class="line">self.person = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    iDog
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://bigporo.github.io/2019/04/23/《Effective Objective-C 2.0》读书总结/" title="《Effective Objective-C 2.0》读书总结">https://bigporo.github.io/2019/04/23/《Effective Objective-C 2.0》读书总结/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    
   
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"> <i class="fa fa-tag"></i> iOS</a>
          
            <a href="/tags/读书/" rel="tag"> <i class="fa fa-tag"></i> 读书</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/23/《计算机网络（第七版）》读书总结/" rel="next" title="《计算机网络（第七版）》读书总结">
                <i class="fa fa-chevron-left"></i> 《计算机网络（第七版）》读书总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/23/Runtime原理篇/" rel="prev" title="Runtime原理篇">
                Runtime原理篇 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://ws2.sinaimg.cn/large/006tNc79ly1g2b8vkark5j304z050wel.jpg" alt="iDog">
            
              <p class="site-author-name" itemprop="name">iDog</p>
              <p class="site-description motion-element" itemprop="description">一个记录工作和生活的小地方。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/BigPoro" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/liu-huan-34-85/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Objective-C"><span class="nav-number">1.</span> <span class="nav-text">Objective-C</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#了解-Objective-C-语言的起源"><span class="nav-number">1.1.</span> <span class="nav-text">了解 Objective-C 语言的起源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在类的头文件中尽量少引用其他头文件"><span class="nav-number">1.2.</span> <span class="nav-text">在类的头文件中尽量少引用其他头文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多用字面量语法-少用与之等价的方法"><span class="nav-number">1.3.</span> <span class="nav-text">多用字面量语法,少用与之等价的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多用类型常量-少用-deine-预处理指令"><span class="nav-number">1.4.</span> <span class="nav-text">多用类型常量,少用# deine 预处理指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用枚举表示状态-选项-状态码"><span class="nav-number">1.5.</span> <span class="nav-text">用枚举表示状态,选项,状态码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象、消息、运行时"><span class="nav-number">2.</span> <span class="nav-text">对象、消息、运行时</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解属性这一概念"><span class="nav-number">2.1.</span> <span class="nav-text">理解属性这一概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在对象内部尽量直接访问实例变量"><span class="nav-number">2.2.</span> <span class="nav-text">在对象内部尽量直接访问实例变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解”对象等同性”这一概念"><span class="nav-number">2.3.</span> <span class="nav-text">理解”对象等同性”这一概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#以”类族模式”隐藏实现细节"><span class="nav-number">2.4.</span> <span class="nav-text">以”类族模式”隐藏实现细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在既有类中使用关联对象存放自定义数据"><span class="nav-number">2.5.</span> <span class="nav-text">在既有类中使用关联对象存放自定义数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解objc-msgSend的作用"><span class="nav-number">2.6.</span> <span class="nav-text">理解objc_msgSend的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解消息转发机制"><span class="nav-number">2.7.</span> <span class="nav-text">理解消息转发机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用方法调配技术调试黑盒方法"><span class="nav-number">2.8.</span> <span class="nav-text">用方法调配技术调试黑盒方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解类对象的用意"><span class="nav-number">2.9.</span> <span class="nav-text">理解类对象的用意</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口设计"><span class="nav-number">3.</span> <span class="nav-text">接口设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用前缀避免命名空间冲突"><span class="nav-number">3.1.</span> <span class="nav-text">用前缀避免命名空间冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提供全能初始化方法"><span class="nav-number">3.2.</span> <span class="nav-text">提供全能初始化方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现description方法"><span class="nav-number">3.3.</span> <span class="nav-text">实现description方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#尽量使用不可变对象"><span class="nav-number">3.4.</span> <span class="nav-text">尽量使用不可变对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用清晰而协调的全名方式"><span class="nav-number">3.5.</span> <span class="nav-text">使用清晰而协调的全名方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为私有方法名加前缀"><span class="nav-number">3.6.</span> <span class="nav-text">为私有方法名加前缀</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解Objective-C错误模型"><span class="nav-number">3.7.</span> <span class="nav-text">理解Objective-C错误模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解NSCopying协议"><span class="nav-number">3.8.</span> <span class="nav-text">理解NSCopying协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协议与分类"><span class="nav-number">4.</span> <span class="nav-text">协议与分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通过委托与数据协议进行对象间通信"><span class="nav-number">4.1.</span> <span class="nav-text">通过委托与数据协议进行对象间通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将类的实现代码分散到便于管理的数个分类之中"><span class="nav-number">4.2.</span> <span class="nav-text">将类的实现代码分散到便于管理的数个分类之中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#勿在分类中声明属性"><span class="nav-number">4.3.</span> <span class="nav-text">勿在分类中声明属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用class-continuation分类隐藏实现细节"><span class="nav-number">4.4.</span> <span class="nav-text">使用class-continuation分类隐藏实现细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过协议提供匿名对象"><span class="nav-number">4.5.</span> <span class="nav-text">通过协议提供匿名对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理"><span class="nav-number">5.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解引用计数"><span class="nav-number">5.1.</span> <span class="nav-text">理解引用计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#以ARC简化引用计数"><span class="nav-number">5.2.</span> <span class="nav-text">以ARC简化引用计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在dealloc方法中只释放引用并解除监听"><span class="nav-number">5.3.</span> <span class="nav-text">在dealloc方法中只释放引用并解除监听</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编写“异常安全代码”时留意内存管理问题"><span class="nav-number">5.4.</span> <span class="nav-text">编写“异常安全代码”时留意内存管理问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#以弱引用避免保留环"><span class="nav-number">5.5.</span> <span class="nav-text">以弱引用避免保留环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#以“自动释放池块”降低内存峰值"><span class="nav-number">5.6.</span> <span class="nav-text">以“自动释放池块”降低内存峰值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用“僵尸对象”调试内存管理问题"><span class="nav-number">5.7.</span> <span class="nav-text">用“僵尸对象”调试内存管理问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不要使用retainCount"><span class="nav-number">5.8.</span> <span class="nav-text">不要使用retainCount</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#块与大中枢派发"><span class="nav-number">6.</span> <span class="nav-text">块与大中枢派发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解”块“这一概念"><span class="nav-number">6.1.</span> <span class="nav-text">理解”块“这一概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为常用的块类型创建typedef"><span class="nav-number">6.2.</span> <span class="nav-text">为常用的块类型创建typedef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用handler块降低代码分散程度"><span class="nav-number">6.3.</span> <span class="nav-text">用handler块降低代码分散程度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用块引用其所属对象时不要出现保留环"><span class="nav-number">6.4.</span> <span class="nav-text">用块引用其所属对象时不要出现保留环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多用派发队列，少用同步锁"><span class="nav-number">6.5.</span> <span class="nav-text">多用派发队列，少用同步锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多用GCD，少用performSelector系列方法"><span class="nav-number">6.6.</span> <span class="nav-text">多用GCD，少用performSelector系列方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#掌握GCD及操作队列的适用时机"><span class="nav-number">6.7.</span> <span class="nav-text">掌握GCD及操作队列的适用时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过Dispatch-Group机制，根据系统资源状况来执行任务"><span class="nav-number">6.8.</span> <span class="nav-text">通过Dispatch Group机制，根据系统资源状况来执行任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用dispatch-once来执行秩序运行一次的线程安全代码"><span class="nav-number">6.9.</span> <span class="nav-text">使用dispatch_once来执行秩序运行一次的线程安全代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不用使用dispatch-get-current-queue"><span class="nav-number">6.10.</span> <span class="nav-text">不用使用dispatch_get_current_queue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统框架"><span class="nav-number">7.</span> <span class="nav-text">系统框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#熟悉系统框架"><span class="nav-number">7.1.</span> <span class="nav-text">熟悉系统框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多用块枚举，少用for循环"><span class="nav-number">7.2.</span> <span class="nav-text">多用块枚举，少用for循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对自定义其内存管理语义的collection使用无缝桥接"><span class="nav-number">7.3.</span> <span class="nav-text">对自定义其内存管理语义的collection使用无缝桥接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构建缓存时选用NSCache而非NSDictionary"><span class="nav-number">7.4.</span> <span class="nav-text">构建缓存时选用NSCache而非NSDictionary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#精简Initialize与load的实现代码"><span class="nav-number">7.5.</span> <span class="nav-text">精简Initialize与load的实现代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#别忘了NSTimer会保留其目标对象"><span class="nav-number">7.6.</span> <span class="nav-text">别忘了NSTimer会保留其目标对象</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">iDog</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>
  <!-- <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div> -->



  <span class="post-meta-divider"> 欢迎来到精神时光屋~~</span>



  <!-- <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div> -->




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
