<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="一个记录工作和生活的小地方。">
<meta name="keywords" content="iOS开发 前端 JS">
<meta property="og:type" content="website">
<meta property="og:title" content="iDog的精神时光屋">
<meta property="og:url" content="https://bigporo.github.io/index.html">
<meta property="og:site_name" content="iDog的精神时光屋">
<meta property="og:description" content="一个记录工作和生活的小地方。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iDog的精神时光屋">
<meta name="twitter:description" content="一个记录工作和生活的小地方。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bigporo.github.io/">





  <title>iDog的精神时光屋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/BigPoro" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">iDog的精神时光屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigporo.github.io/2022/11/06/iOS常用设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iDog">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://raw.githubusercontent.com/BigPoro/PictureBed/master/head_portrait.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iDog的精神时光屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/11/06/iOS常用设计模式/" itemprop="url">iOS常用设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-11-06T09:26:25+08:00">
                2022-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书/" itemprop="url" rel="index">
                    <span itemprop="name">读书</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  35
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d51f50b9513d4860956a4d9ad4b9828e~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp" alt="image"></p>
<h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><ul>
<li>开闭原则（Open Close Principle）</li>
</ul>
<blockquote>
<p>对扩展打开，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p>
</blockquote>
<ul>
<li>里氏替换原则（Liskov Substitution Principle）</li>
</ul>
<blockquote>
<p>父子可以相互调用，父类必须提供足够多的抽象方法供子类重载使用。 任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2022/11/06/iOS常用设计模式/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></blockquote></div>
    
    
    

    

    

    
   
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigporo.github.io/2022/09/15/iOS核心动画高级技巧-读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iDog">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://raw.githubusercontent.com/BigPoro/PictureBed/master/head_portrait.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iDog的精神时光屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/09/15/iOS核心动画高级技巧-读书笔记/" itemprop="url">iOS核心动画高级技巧-读书笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-09-15T11:00:43+08:00">
                2022-09-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  21.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  78
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="图层树"><a href="#图层树" class="headerlink" title="图层树"></a>图层树</h1><h2 id="UIView和CALayer的关系"><a href="#UIView和CALayer的关系" class="headerlink" title="UIView和CALayer的关系"></a>UIView和CALayer的关系</h2><p><code>CALayer</code>类在概念上和<code>UIView</code>类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。</p>
<p>它们有一些方法和属性用来做动画和变换。和<code>UIView</code>最大的不同是<code>CALayer</code>不处理用户的交互。但是它提供了一些方法来判断是否一个触点在图层的范围之内。</p>
<p>每一个<code>UIView</code>都有一个<code>CALayer</code>实例的图层属性，也就是所谓的<code>backing layer</code>，视图的职责就是创建并管理这个图层。</p>
<p>这些背后关联的图层才是真正用来在屏幕上显示和做动画，<code>UIView</code>仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及<code>Core Animation</code>底层方法的高级接口。</p>
<h2 id="CALayer的能力"><a href="#CALayer的能力" class="headerlink" title="CALayer的能力"></a>CALayer的能力</h2><p>有一些<code>UIView</code>没有暴露出来的<code>CALayer</code>的功能：</p>
<ul>
<li>阴影，圆角，带颜色的边框</li>
<li>3D变换</li>
<li>非矩形范围</li>
<li>透明遮罩</li>
<li>多级非线性动画</li>
</ul>
<h1 id="寄宿图"><a href="#寄宿图" class="headerlink" title="寄宿图"></a>寄宿图</h1><h2 id="contents"><a href="#contents" class="headerlink" title="contents"></a>contents</h2><p><code>CALayer</code> 有一个属性叫做<code>contents</code>，虽然是id类型，但是如果赋值不止<code>CGImage</code>,图层就会是空白的。</p>
<blockquote>
<p>所以被定义为id类型，是因为在Mac OS系统上，这个属性对<code>CGImage</code>和<code>NSImage</code>类型的值都起作用。</p>
</blockquote>
<p>事实上，真正要赋值的类型应该是<code>CGImageRef</code>，它是一个指向<code>CGImage</code>结构的指针。<code>UIImage</code>有一个<code>CGImage</code>属性，它返回一个”<code>CGImageRef</code>“,如果你想把这个值直接赋值给<code>CALayer</code>的<code>contents</code>，那你将会得到一个编译错误。因为<code>CGImageRef</code>并不是一个真正的Cocoa对象，而是一个Core Foundation类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer.contents = (__bridge id)image.CGImage;</span><br></pre></td></tr></table></figure>
<p>其他属性：</p>
<ul>
<li><code>contentGravity</code>：设置拉伸方式，对应<code>UIView</code>的<code>contentMode</code></li>
<li><code>contentsScale</code>：定义寄宿图的像素尺寸和试图大小的比例，默认为<code>1.0</code>，一般设置为<code>[UIScreen mainScreen].scale;</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">layerView.layer.contentsGravity = .center</span><br><span class="line">layerView.layer.contentsScale = UIScreen.main.scale</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 相当于上面两行</span></span><br><span class="line">layerView.layer.contentsGravity = .resizeAspect</span><br></pre></td></tr></table></figure>
<ul>
<li><code>maskToBounds</code>：是否绘制超过边界的内容,对应<code>UIView</code>的<code>clipsToBounds</code>;</li>
<li><code>contentsRect</code>:在图层边框里面显示寄宿图的子区域，使用单位坐标,默认为<code>{0, 0, 1, 1}</code></li>
</ul>
<blockquote>
<p>该属性可用于图片拼合，可以打包真核一张大图一次性载入，相比多次载入不同的图片，在内存使用、载入时间、渲染性能能会有更好表现</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func addSpriteImage(img:UIImage, <span class="attr">rect</span>:CGRect, <span class="attr">superLayer</span>:CALayer) &#123;</span><br><span class="line">    superLayer.contents = img.cgImage</span><br><span class="line">    superLayer.contentsGravity = .resizeAspect</span><br><span class="line">    superLayer.contentsRect = rect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>contentsCenter</code>：定义了一个固定的边框和一个在图层上可拉伸的区域，默认为<code>{0, 0, 1, 1}</code>,类似<code>resizableImageWithCapInsets</code></li>
</ul>
<h2 id="Custom-Drawing"><a href="#Custom-Drawing" class="headerlink" title="Custom Drawing"></a>Custom Drawing</h2><p>可以直接用<code>Core Graphics</code>直接绘制寄宿图。能够通过继承UIView并实现<code>-drawRect:</code>方法来自定义绘制。</p>
<p><code>-drawRect:</code> 方法没有默认的实现，因为对<code>UIView</code>来说，寄宿图并不是必须的，。如果<code>UIView</code>检测到<code>-drawRect:</code> 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 <code>contentsScale</code>的值。</p>
<blockquote>
<p>如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费</p>
</blockquote>
<p>当视图在屏幕上出现的时候 <code>-drawRect:</code>方法就会被自动调用。<code>-drawRect:</code>方法里面的代码利用<code>Core Graphics</code>去绘制一个寄宿图，然后内容就会被缓存起来直到它需要被更新（通常是因为开发者调用了<code>-setNeedsDisplay</code>方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如<code>bounds</code>属性）。虽然<code>-drawRect:</code>方法是一个<code>UIView</code>方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。</p>
<p><code>CALayer</code>有一个可选的<code>delegate</code><strong>属性，实现</strong>了<code>CALayerDelegate</code>协议，当<code>CALayer</code>需要一个内容特定的信息时，就会从协议中请求。</p>
<p>当需要被重绘时，CALayer会请求它的代理给他一个寄宿图来显示。它通过调用下面这个方法做到的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open func display()</span><br></pre></td></tr></table></figure>
<p>代理想直接设置<code>contents</code>属性的话，它就可以这么做，不然没有别的方法可以调用了。如果代理不实现<code>-displayLayer:</code>方法，<code>CALayer</code>就会转而尝试调用下面这个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func draw(_ layer: CALayer, <span class="keyword">in</span> ctx: CGContext);</span><br></pre></td></tr></table></figure>
<p><code>CALayer</code>创建了一个合适尺寸的空寄宿图（尺寸由<code>bounds</code>和<code>contentsScale</code>决定）和一个<code>Core Graphics</code>的绘制上下文环境，为绘制寄宿图做准备，他作为<code>ctx</code>参数传入。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class CustomDrawingController: UIViewController, CALayerDelegate &#123;</span><br><span class="line"></span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        self.view.backgroundColor = .white</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> layerView = UIView.init(frame: CGRect(x: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">100</span>, <span class="attr">width</span>: <span class="number">200</span>, <span class="attr">height</span>: <span class="number">200</span>))</span><br><span class="line">        layerView.backgroundColor = .white</span><br><span class="line">        layerView.center = self.view.center</span><br><span class="line">        self.view.addSubview(layerView)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> blueLayer = CALayer.init()</span><br><span class="line">        blueLayer.frame = layerView.bounds</span><br><span class="line">        blueLayer.backgroundColor = UIColor.blue.cgColor</span><br><span class="line">        blueLayer.delegate = self</span><br><span class="line">        layerView.layer.addSublayer(blueLayer)</span><br><span class="line">        </span><br><span class="line">        blueLayer.display() <span class="comment">// 需要手动display</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func draw(_ layer: CALayer, <span class="keyword">in</span> ctx: CGContext) &#123;</span><br><span class="line">        ctx.setLineWidth(<span class="number">10.0</span>)</span><br><span class="line">        ctx.setStrokeColor(UIColor.red.cgColor)</span><br><span class="line">        ctx.strokeEllipse(<span class="keyword">in</span>: layer.bounds)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要在<code>blueLayer</code>上显式调用<code>-display</code>,当图层显示在屏幕上时，<code>CALayer</code>不会自动重绘它的内容</p>
</blockquote>
<blockquote>
<p>当使用<code>CALayerDelegate</code>绘制寄宿图的时候，并没有对超出边界外的内容提供绘制支持。</p>
</blockquote>
<h1 id="图层几何学"><a href="#图层几何学" class="headerlink" title="图层几何学"></a>图层几何学</h1><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p><code>UIView</code>有三个比较重要的布局属性：<code>frame</code>，<code>bounds</code>和<code>center</code>，CALayer对应地叫做<code>frame</code>，<code>bounds</code>和<code>position</code>。为了能清楚区分，图层用了“<code>position</code>”，视图用了“<code>center</code>”，但是他们都代表同样的值。</p>
<p>UIView的<code>frame</code>，<code>bounds</code>和<code>center</code>属性仅仅是存取方法，当操纵视图的<code>frame</code>，实际上是在改变位于视图下方CALayer的<code>frame</code>，不能够独立于图层之外改变视图的<code>frame</code>。</p>
<p><code>frame</code>代表了图层在父图层上占据的空间，<code>bounds是</code>内部坐标（<code>{0, 0}</code>通常是图层的左上角）<br><code>center</code>和<code>position</code>都代表了相对于父图层<code>anchorPoint</code>所在的位置。</p>
<blockquote>
<p>当对图层做变换的时候，比如旋转或者缩放，<code>frame</code>实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说<code>frame</code>的宽高可能和<code>bounds</code>的宽高不再一致了。</p>
</blockquote>
<h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p><code>anchorPoint</code>默认位于图层中点，所以图层的将会以这个点为中心放置。这也是视图的<code>position</code>属性被叫做“<code>center</code>”的原因。</p>
<p><code>anchorPoint</code>使用单位坐标，默认<code>{0.5,0.5}</code>。</p>
<p>但是图层的<code>anchorPoint</code>可以被移动，比如可以把它置于图层<code>frame</code>的左上角，于是图层的内容将会向右下角的<code>position</code>方向移动，而不是居中了。</p>
<h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>一个图层的<code>position</code>依赖于它父图层的<code>bounds</code>，如果父图层发生了移动，它的所有子图层也会跟着移动。</p>
<p>CALayer给不同坐标系之间的图层转换提供了一些工具类方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer;</span><br><span class="line">- (CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer;</span><br><span class="line">- (CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;</span><br><span class="line">- (CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer;</span><br></pre></td></tr></table></figure>
<h2 id="翻转的几何结构"><a href="#翻转的几何结构" class="headerlink" title="翻转的几何结构"></a>翻转的几何结构</h2><p>常规说来，在iOS上，一个图层的<code>position</code>位于父图层的左上角，但是在Mac OS上，通常是位于左下角。<code>Core Animation</code>可以通过<code>geometryFlipped</code>属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个<code>BOOL</code>类型。在iOS上通过设置它为YES意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部（它的所有子图层也同理，除非把它们的<code>geometryFlipped</code>属性也设为<code>YES</code>）。</p>
<h2 id="Z坐标轴"><a href="#Z坐标轴" class="headerlink" title="Z坐标轴"></a>Z坐标轴</h2><p><code>CALayer</code>有另外两个属性，<code>zPosition</code>和<code>anchorPointZ</code>，二者都是在Z轴上描述图层位置的浮点类型。</p>
<p>通常，图层是根据它们子图层的<code>sublayers</code>出现的顺序来类绘制的,后被绘制上的图层将会遮盖住之前的图层，但是通过增加图层的<code>zPosition</code>，就可以把图层前置，于是它就在所有其他图层的前面了（或者至少是小于它的<code>zPosition</code>值的图层的前面）。</p>
<h2 id="Hit-Testing"><a href="#Hit-Testing" class="headerlink" title="Hit Testing"></a>Hit Testing</h2><p><code>CALayer</code>并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法可以处理事件：<code>-containsPoint:</code>和<code>-hitTest:</code>。</p>
<ul>
<li><p><code>-containsPoint:</code>接受一个在本图层坐标系下的<code>CGPoint</code>，如果这个点在图层<code>frame</code>范围内就返回YES。</p>
</li>
<li><p><code>-hitTest:</code>方法同样接受一个<code>CGPoint</code>类型参数，而不是<code>BOOL</code>类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。</p>
</li>
</ul>
<blockquote>
<p>注意当调用图层的<code>-hitTest:</code>方法时，返回的顺序严格依赖于图层树当中的图层顺序（和<code>UIView</code>处理事件类似）。之前提到的<code>zPosition</code>属性可以明显改变屏幕上图层的顺序，但不能改变事件传递的顺序。</p>
</blockquote>
<h2 id="自动布局"><a href="#自动布局" class="headerlink" title="自动布局"></a>自动布局</h2><p>如果想随意控制<code>CALayer</code>的布局，就需要手工操作。最简单的方法就是使用<code>CALayerDelegate</code>如下函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)layoutSublayersOfLayer:(CALayer *)layer;</span><br></pre></td></tr></table></figure>
<p>当图层的<code>bounds</code>发生改变，或者图层的<code>-setNeedsLayout</code>方法被调用的时候，这个函数将会被执行。可以手动地重新摆放或者重新调整子图层的大小，但是不能像<code>UIView</code>的<code>autoresizingMask</code>和<code>constraints</code>属性做到自适应屏幕旋转。</p>
<h1 id="视觉效果"><a href="#视觉效果" class="headerlink" title="视觉效果"></a>视觉效果</h1><h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><ul>
<li><p><code>shadowOpacity</code>：是一个必须在0.0（不可见）和1.0（完全不透明）之间的浮点数。如果设置为1.0，将会显示一个有轻微模糊的黑色阴影稍微在图层之上。</p>
</li>
<li><p><code>shadowOffset</code>：控制着阴影的方向和距离。它是一个<code>CGSize</code>的值，宽度控制这阴影横向的位移，高度控制着纵向的位移。<code>shadowOffset</code>的默认值是 {0, -3}，意即阴影相对于Y轴有3个点的向上位移。</p>
</li>
<li><p><code>shadowRadius</code>：控制着阴影的模糊度，当它的值是0的时候，阴影就和视图一样有一个非常确定的边界线。当值越来越大的时候，边界线看上去就会越来越模糊和自然。</p>
</li>
<li><p><code>shadowPath</code>：实时计算阴影也是一个非常消耗资源的，指定一个<code>shadowPath</code>来提高性能</p>
</li>
</ul>
<blockquote>
<p>阴影裁剪：阴影是根据寄宿图的轮廓来确定的，而不是根据边界和角半径来确定。</p>
</blockquote>
<ul>
<li><code>shouldRasterize</code>：如果它被设置为<code>YES</code>，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了。</li>
</ul>
<h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><h3 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h3><p>主要是2D变换，主要API：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGAffineTransformMakeRotation(CGFloat angle) <span class="comment">//旋转</span></span><br><span class="line">CGAffineTransformMakeScale(CGFloat sx, CGFloat sy) <span class="comment">// 缩放</span></span><br><span class="line">CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty) <span class="comment">// 位移</span></span><br><span class="line">CGAffineTransformIdentity <span class="comment">// 空值</span></span><br><span class="line">CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2); <span class="comment">// 混合两个变换</span></span><br></pre></td></tr></table></figure>
<h3 id="3D变换"><a href="#3D变换" class="headerlink" title="3D变换"></a>3D变换</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z)</span><br><span class="line">CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz) </span><br><span class="line">CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz)</span><br></pre></td></tr></table></figure>
<p>X轴和Y轴分别以右和下为正方向（这是iOS上的标准结构，在Mac OS，Y轴朝上为正方向），Z轴和这两个轴分别垂直，指向视角外为正方向。</p>
<blockquote>
<p>旋转方向确定：左手点赞，大拇指朝向箭头方向，握手指的方向即为旋转方向</p>
</blockquote>
<h3 id="透视投影-lt-重点-gt"><a href="#透视投影-lt-重点-gt" class="headerlink" title="透视投影&lt;重点&gt;"></a>透视投影&lt;重点&gt;</h3><p><code>CATransform3D</code>的透视效果通过一个矩阵中一个很简单的元素来控制：<code>m34</code>。<code>m34</code>用于按比例缩放X和Y的值来计算到底要离视角多远。</p>
<p><code>m34</code>的默认值是0，可以通过设置<code>m34为-1.0 /d</code>来应用透视效果，d代表了想象中视角相机和屏幕之间的距离，以像素为单位，不需要精细计算，通常<strong>500-1000</strong>就已经很好了，但对于特定的图层有时候更小后者更大的值会看起来更舒服，减少距离的值会增强透视效果，所以一个非常微小的值会让它看起来更加失真，然而一个非常大的值会让它基本失去透视效果。</p>
<blockquote>
<p>解决了图层看起来并没有被旋转，而是仅仅在水平方向上的一个压缩。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create a new transform</span></span><br><span class="line">CATransform3D  transform = CATransform3DIdentity;</span><br><span class="line"><span class="comment">//apply perspective</span></span><br><span class="line">transform.m34 = - <span class="number">1.0</span> / <span class="number">500.0</span>;</span><br><span class="line"><span class="comment">//rotate by 45 degrees along the Y axis</span></span><br><span class="line">transform = CATransform3DRotate(transform, M_PI_4, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//apply to layer</span></span><br><span class="line">self.layerView.layer.transform = transform;</span><br></pre></td></tr></table></figure>
<h3 id="灭点-lt-重点-gt"><a href="#灭点-lt-重点-gt" class="headerlink" title="灭点&lt;重点&gt;"></a>灭点&lt;重点&gt;</h3><p>当在透视角度绘图的时候，远离相机视角的物体将会变小变远，当远离到一个极限距离，它们可能就缩成了一个点，于是所有的物体最后都汇聚消失在同一个点。</p>
<p>为了在应用中创建拟真效果的透视，这个点应该聚在屏幕中点，或者至少是包含所有3D对象的视图中点。</p>
<p><code>Core Animation</code>定义了这个点位于变换图层的<code>anchorPoint</code>（通常位于图层中心，但也有例外）。这就是说，当图层发生变换时，这个点永远位于图层变换之前<code>anchorPoint</code>的位置。</p>
<p>当改变一个图层的<code>position</code>，也改变了它的灭点，做3D变换的时候要时刻记住这一点，当视图通过调整<code>m34</code>来让它更加有3D效果，应该首先把它放置于屏幕中央，然后通过平移来把它移动到指定位置（而不是直接改变它的<code>position</code>），这样所有的3D图层都共享一个灭点。</p>
<h3 id="sublayerTransform-属性-lt-重点-gt"><a href="#sublayerTransform-属性-lt-重点-gt" class="headerlink" title="sublayerTransform 属性&lt;重点&gt;"></a>sublayerTransform 属性&lt;重点&gt;</h3><p><code>sublayerTransform</code>是<code>CATransform3D</code>类型，但和对一个图层的变换不同，它影响到所有的子图层。这意味着可以一次性对包含这些图层的容器做变换，于是所有的子图层都自动继承了这个变换方法。</p>
<blockquote>
<p>用于解决有多个视图或者图层，每个都做3D变换，那就需要分别设置相同的m34值，并且确保在变换之前都在屏幕中央共享同一个<code>position</code>。</p>
</blockquote>
<blockquote>
<p>灭点被设置在容器图层的中点，从而不需要再对子图层分别设置了。这意味着你可以随意使用<code>position</code>和<code>frame</code>来放置子图层，而不需要把它们放置在屏幕中点，然后为了保证统一的灭点用变换来做平移。</p>
</blockquote>
<h3 id="背面"><a href="#背面" class="headerlink" title="背面"></a>背面</h3><p>图层是双面绘制的，反面显示的是正面的一个镜像图片。</p>
<p>但这并不是一个很好的特性，因为如果图层包含文本或者其他控件，那用户看到这些内容的镜像图片当然会感到困惑。另外也有可能造成资源的浪费：想象用这些图层形成一个不透明的固态立方体，既然永远都看不见这些图层的背面，那为什么浪费GPU来绘制它们呢？</p>
<p><code>CALayer</code>有一个叫做<code>doubleSided</code>的属性来控制图层的背面是否要被绘制。这是一个BOOL类型，默认为YES，如果设置为NO，那么当图层正面从相机视角消失的时候，它将不会被绘制。</p>
<h3 id="扁平化图层"><a href="#扁平化图层" class="headerlink" title="扁平化图层"></a>扁平化图层</h3><p>由于尽管<code>Core Animation</code>图层存在于3D空间之内，但它们并不都存在同一个3D空间。每个图层的3D场景其实是扁平化的，从正面观察一个图层，看到的实际上由子图层创建的想象出来的3D场景，但当倾斜这个图层，实际上这个3D场景仅仅是被绘制在图层的表面。</p>
<blockquote>
<p>当在玩一个3D游戏，实际上仅仅是把屏幕做了一次倾斜，或许在游戏中可以看见有一面墙在你面前，但是倾斜屏幕并不能够看见墙里面的东西。所有场景里面绘制的东西并不会随着观察它的角度改变而发生变化；图层也是同样的道理。</p>
</blockquote>
<h3 id="固体对象"><a href="#固体对象" class="headerlink" title="固体对象"></a>固体对象</h3><p>用六个独立的视图来构建一个立方体的各个面，不需要不关心在这个容器中如何摆放它们的位置，因为后续将会用图层的<code>transform</code>对它们进行重新布局。</p>
<p>如果需要动态地创建光线效果，可以根据每个视图的方向应用不同的<code>alpha</code>值做出半透明的阴影图层，但为了计算阴影图层的不透明度，需要得到每个面的正太向量（垂直于表面的向量），然后根据一个想象的光源计算出两个向量叉乘结果。叉乘代表了光源和图层之间的角度，从而决定了它有多大程度上的光亮。</p>
<h1 id="专用图层"><a href="#专用图层" class="headerlink" title="专用图层"></a>专用图层</h1><h2 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h2><p><code>CAShapeLayer</code>是一个通过矢量图形而不是<code>bitmap</code>来绘制的图层子类。指定诸如颜色和线宽等属性，用<code>CGPath</code>来定义想要绘制的图形，最后<code>CAShapeLayer</code>就自动渲染出来了。也可以用<code>Core Graphics</code>直接向原始的CALyer的内容中绘制一个路径，使用<code>CAShapeLayer</code>有以下一些优点：</p>
<ul>
<li>渲染快速。<code>CAShapeLayer</code>使用了硬件加速，绘制同一图形会比用<code>Core Graphics</code>快很多。</li>
<li>高效使用内存。一个<code>CAShapeLayer</code>不需要像普通<code>CALayer</code>一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。</li>
<li>不会被图层边界剪裁掉。一个<code>CAShapeLayer</code>可以在边界之外绘制。你的图层路径不会像在使用<code>Core Graphics</code>的普通<code>CALayer</code>一样被剪裁掉。</li>
<li>不会出现像素化。当你给<code>CAShapeLayer</code>做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化。</li>
</ul>
<h2 id="CATextLayer"><a href="#CATextLayer" class="headerlink" title="CATextLayer"></a>CATextLayer</h2><p><code>CATextLayer</code>它以图层的形式包含了<code>UILabel</code>几乎所有的绘制特性，并且额外提供了一些新的特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> containerView = UIView()</span><br><span class="line">containerView.frame = CGRect(x: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>, <span class="attr">width</span>: </span><br><span class="line">height: <span class="number">300</span>)</span><br><span class="line">containerView.center = self.view.center</span><br><span class="line">containerView.backgroundColor = .white</span><br><span class="line">self.view.addSubview(containerView)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textLayer = CATextLayer()</span><br><span class="line">textLayer.frame = containerView.bounds</span><br><span class="line">containerView.layer.addSublayer(textLayer)</span><br><span class="line"></span><br><span class="line">textLayer.foregroundColor = UIColor.orange.cgColor</span><br><span class="line">textLayer.alignmentMo</span><br><span class="line">CATextLayerAlignmentMode.justified</span><br><span class="line">textLayer.isWrapped = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 设置字体</span></span><br><span class="line"><span class="keyword">let</span> font = UIFont.systemFont(ofSize: <span class="number">15</span>)</span><br><span class="line"><span class="keyword">let</span> cgFont = CGFont(font.fontName <span class="keyword">as</span> CFString)!</span><br><span class="line">textLayer.font = cgFont</span><br><span class="line">textLayer.fontSize = font.pointSize</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">"Lorem ipsum dolor sit amet, consect</span></span><br><span class="line"><span class="string">adipiscing elit. Quisque massa arcu, eleifend vel va</span></span><br><span class="line"><span class="string">in, facilisis pulvinar leo. Nunc quis nunc at ma</span></span><br><span class="line"><span class="string">pharetra condimentum ut ac neque. Nunc elementum, li</span></span><br><span class="line"><span class="string">ut porttitor dictum, diam odio congue lacus, </span></span><br><span class="line"><span class="string">fringilla sapien diam at purus. Etiam suscipit pre</span></span><br><span class="line"><span class="string">nunc sit amet  lobortis"</span></span><br><span class="line">textLayer.string = text</span><br><span class="line">textLayer.contentsScale = UIScreen.main.scale;</span><br></pre></td></tr></table></figure>
<h2 id="CATransformLayer"><a href="#CATransformLayer" class="headerlink" title="CATransformLayer"></a>CATransformLayer</h2><p><code>Core Animation</code>图层可以在2D环境下做出这样的层级体系下的变换，但是3D情况下就不太可能，因为所有的图层都把他的子图层都平面化到一个场景中。</p>
<p><code>CATransformLayer</code>解决了这个问题，<code>CATransformLayer</code>不同于普通的CALayer，因为它不能显示它自己的内容。只有当存在了一个能作用域子图层的变换它才真正存在。<code>CATransformLayer</code>并不平面化它的子图层，所以它能够用于构造一个层级的3D结构，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cube = CATransformLayer()</span><br><span class="line">        </span><br><span class="line"><span class="comment">// face 1</span></span><br><span class="line"><span class="keyword">var</span> ct = CATransform3DIdentity</span><br><span class="line">cube.addSublayer(self.faceWithTransform(transform: ct))</span><br><span class="line"><span class="comment">// face 2</span></span><br><span class="line">ct = CATransform3DMakeTranslation(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">ct = CATransform3DRotate(ct, Double.pi/<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)  </span><br><span class="line">cube.addSublayer(self.faceWithTransform(transform: ct))</span><br><span class="line"><span class="comment">// face 3</span></span><br><span class="line">ct = CATransform3DMakeTranslation(<span class="number">0</span>, <span class="number">-50</span>, <span class="number">0</span>)</span><br><span class="line">ct = CATransform3DRotate(ct, Double.pi/<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">cube.addSublayer(self.faceWithTransform(transform: ct))</span><br><span class="line"><span class="comment">// face 4</span></span><br><span class="line">ct = CATransform3DMakeTranslation(<span class="number">0</span>, <span class="number">50</span>, <span class="number">0</span>)</span><br><span class="line">ct = CATransform3DRotate(ct, -Double.pi/<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">cube.addSublayer(self.faceWithTransform(transform: ct))</span><br><span class="line"><span class="comment">// face 5</span></span><br><span class="line">ct = CATransform3DMakeTranslation(<span class="number">-50</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">ct = CATransform3DRotate(ct, -Double.pi/<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">cube.addSublayer(self.faceWithTransform(transform: ct))</span><br><span class="line"><span class="comment">// face 6</span></span><br><span class="line">ct = CATransform3DMakeTranslation(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-50</span>)</span><br><span class="line">ct = CATransform3DRotate(ct, Double.pi, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">cube.addSublayer(self.faceWithTransform(transform: ct))</span><br><span class="line"><span class="keyword">let</span> containerSize = containerView.bounds</span><br><span class="line">cube.position = CGPoint(x: containerSize.width/<span class="number">2.0</span>, <span class="attr">y</span>: containerSize.height/<span class="number">2.0</span>)</span><br><span class="line">cube.transform = transform</span><br></pre></td></tr></table></figure>
<h2 id="CAGradientLayer"><a href="#CAGradientLayer" class="headerlink" title="CAGradientLayer"></a>CAGradientLayer</h2><p><code>CAGradientLayer</code>是用来生成两种或更多颜色平滑渐变的,<code>真正好处在于绘制使用了硬件加速</code>。</p>
<ul>
<li><code>startPoint</code>和<code>endPoint</code>：决定了渐变的方向。这两个参数是以单位坐标系进行的定义，所以左上角坐标是{0, 0}，右下角坐标是{1, 1}。</li>
<li><code>locations</code>：调整颜色空间，需要和<code>colors</code>长度相同</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gradientLayer = CAGradientLayer()</span><br><span class="line">gradientLayer.frame = containerView.bounds</span><br><span class="line">gradientLayer.colorUIColor.random().cgColor,UIColor.random().cgColor,UICrandom().cgColor]</span><br><span class="line">gradientLayer.startPoint = CGPoint(x: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>)</span><br><span class="line">gradientLayer.endPoint = CGPoint(x: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>)</span><br><span class="line">gradientLayer.locations = [NSNumber(val<span class="number">.1</span>),NSNumber(value: <span class="number">0.3</span>),NSNumber(value: <span class="number">0.8</span>)]</span><br><span class="line">containerView.layer.addSublayer(gradientLayer)</span><br></pre></td></tr></table></figure>
<h2 id="CAReplicatorLayer"><a href="#CAReplicatorLayer" class="headerlink" title="CAReplicatorLayer"></a>CAReplicatorLayer</h2><p><code>CAReplicatorLayer</code>的目的是为了高效生成许多相似的图层。它会绘制一个或多个图层的子图层，并在每个复制体上应用不同的变换。</p>
<p><code>CAReplicatorlayer</code>真正应用到实际程序上的场景比如：一个游戏中导弹的轨迹云，或者粒子爆炸。还有一个实际的用处反射。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> replicator = CAReplicatorLayer()</span><br><span class="line">replicator.frame = containerView.bounds</span><br><span class="line">containerView.layer.addSublayer(replicator)</span><br><span class="line"><span class="comment">// 重复次数</span></span><br><span class="line">replicator.instanceCount = <span class="number">15</span></span><br><span class="line"><span class="keyword">var</span> transform = CATransform3DIdentity</span><br><span class="line">transform = CATransform3DTranslate(transform, <span class="number">0</span>, <span class="number">200</span>, <span class="number">0</span>)</span><br><span class="line">transform = CATransform3DRotate(transform, Double.pi/<span class="number">5</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">transform = CATransform3DTranslate(transform, <span class="number">0</span>, <span class="number">-200</span>, <span class="number">0</span>)</span><br><span class="line">replicator.instanceTransform = transform</span><br><span class="line"><span class="comment">// 改变颜色通道实现变换颜色</span></span><br><span class="line">replicator.instanceBlueOffset = <span class="number">-0.1</span></span><br><span class="line">replicator.instanceGreenOffset = <span class="number">-0.1</span></span><br><span class="line"><span class="comment">// 添加子图层 作为内容</span></span><br><span class="line"><span class="keyword">let</span> subLayer = CALayer()</span><br><span class="line">subLayer.frame = CGRect(x: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">100</span>, <span class="attr">width</span>: </span><br><span class="line">height: <span class="number">100</span>)</span><br><span class="line">subLayer.backgroundColor = UIColor.white.cgColor</span><br><span class="line">replicator.addSublayer(subLayer)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">反射：需要添加自视图作为内容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">class ReflectionView: UIView &#123;</span><br><span class="line">    override class var layerClass: AnyClass &#123;</span><br><span class="line">        <span class="keyword">return</span> CAReplicatorLayer.self</span><br><span class="line">    &#125;</span><br><span class="line">    override init(frame: CGRect) &#123;</span><br><span class="line">        <span class="keyword">super</span>.init(frame: frame)</span><br><span class="line">        setup()</span><br><span class="line">    &#125;</span><br><span class="line">    required init?(coder: NSCoder) &#123;</span><br><span class="line">        fatalError(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    func setup() &#123;</span><br><span class="line">        guard <span class="keyword">let</span> layer = self.layer <span class="keyword">as</span>? CAReplicatorLayer elseeturn &#125;</span><br><span class="line">        layer.instanceCount = <span class="number">2</span> <span class="comment">// 重复两次</span></span><br><span class="line">        <span class="keyword">var</span> transform = CATransform3DIdentity</span><br><span class="line">        <span class="keyword">let</span> offset = self.bounds.size.width</span><br><span class="line">        transform = CATransform3DTranslate(transform, offset, <span class="number">0</span>)</span><br><span class="line">        transform = CATransform3DScale(transform, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        layer.instanceTransform = transform</span><br><span class="line">        layer.instanceAlphaOffset = <span class="number">-0.5</span> <span class="comment">// 透明度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CAScrollLayer"><a href="#CAScrollLayer" class="headerlink" title="CAScrollLayer"></a>CAScrollLayer</h2><p><code>CAScrollLayer</code>可以显示一个大图层里面的一小部分，通过<code>-scrollToPoint:</code>可以实现支持滑动。</p>
<p><code>Core Animation</code>并不处理用户输入，所以<code>CAScrollLayer</code>并不负责将触摸事件转换为滑动事件，既不渲染滚动条，也不实现任何iOS指定行为例如滑动反弹。</p>
<p>主要是下面两个方法：</p>
<ul>
<li><p><code>-scrollToPoint:</code>从图层树中查找并找到第一个可用的<code>CAScrollLayer</code>，然后滑动它使得指定点成为可视的。</p>
</li>
<li><p><code>-scrollRectToVisible:</code>：实现了同样的事情只不过是作用在一个矩形上的。<code>visibleRect</code>属性决定图层（如果存在的话）的哪部分是当前的可视区域。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用CAScrollLayer作为视图的宿主图层，并创建一个自定义的UIView，然后用UIPanGestureRecognizer实现触摸事件响应</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">class ScrollView: UIView &#123;</span><br><span class="line">    override class var layerClass: AnyClass &#123;</span><br><span class="line">        <span class="keyword">return</span> CAScrollLayer.self</span><br><span class="line">    &#125;</span><br><span class="line">    override init(frame: CGRect) &#123;</span><br><span class="line">        <span class="keyword">super</span>.init(frame: frame)</span><br><span class="line">        setup()</span><br><span class="line">    &#125;</span><br><span class="line">    required init?(coder: NSCoder) &#123;</span><br><span class="line">        fatalError(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    func setup() &#123;</span><br><span class="line">        self.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        let pan = UIPanGestureRecognizer(target: self, action: #selector(pan))</span><br><span class="line">        self.addGestureRecognizer(pan)</span><br><span class="line">    &#125;</span><br><span class="line">    @objc func pan(recognizer:UIPanGestureRecognizer) &#123;</span><br><span class="line">        <span class="keyword">var</span> offset = self.bounds.origin</span><br><span class="line">        offset.x -= recognizer.translation(<span class="keyword">in</span>: self).x</span><br><span class="line">        offset.y -= recognizer.translation(<span class="keyword">in</span>: self).y</span><br><span class="line">        </span><br><span class="line">        self.layer.scroll(offset)</span><br><span class="line">        recognizer.setTranslation(CGPoint.zero, <span class="attr">in</span>: self)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>滑动视图类并没有实现任何形式的边界检查（<code>bounds checking</code>）。图层内容极有可能滑出视图的边界并无限滑下去。</p>
</blockquote>
<blockquote>
<p><code>CAScrollLayer</code>并没有等同于<code>UIScrollView</code>中<code>contentSize</code>的属性，所以当<code>CAScrollLayer</code>滑动的时候完全没有一个全局的可滑动区域的概念，也无法自适应它的边界原点至你指定的值。它之所以不能自适应边界大小是因为它不需要，内容完全可以超过边界。</p>
</blockquote>
<h2 id="CATiledLayer"><a href="#CATiledLayer" class="headerlink" title="CATiledLayer"></a>CATiledLayer</h2><p>在渲染大内存图片会遇到以下问题：</p>
<ul>
<li><code>UIImage</code>的<code>-imageNamed:</code>方法或者<code>-imageWithContentsOfFile:</code>方法）将会阻塞用户界面，至少会引起动画卡顿现象。</li>
<li><code>OpenGL</code>有一个最大的纹理尺寸（通常是2048x<em>2048，或4096x</em>4096，这个取决于设备型号）。如果在单个纹理中显示一个比这大的图，即便图片已经存在于内存中了，仍然会遇到很大的性能问题，因为<code>Core Animation</code>强制用CPU处理图片而不是更快的GPU。</li>
</ul>
<p><code>CATiledLayer</code>为载入大图造成的性能问题提供了一个解决方案：<code>将大图分解成小片然后将他们单独按需载入</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tileLayer = CATiledLayer()</span><br><span class="line">tileLayer.frame = CGRect(x: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>, <span class="attr">width</span>: <span class="number">2048</span>, <span class="attr">height</span>: <span class="number">2048</span>)</span><br><span class="line">tileLayer.delegate = self</span><br><span class="line">tileLayer.contentsScale = UIScreen.main.scale</span><br><span class="line">scrollView.layer.addSublayer(tileLayer)</span><br><span class="line">scrollView.contentSize = tileLayer.frame.size</span><br><span class="line">tileLayer.display()</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> layer = layer <span class="keyword">as</span>! CATiledLayer</span><br><span class="line"><span class="keyword">let</span> bounds = ctx.boundingBoxOfClipPath</span><br><span class="line"><span class="keyword">let</span> x = Int(bounds.origin.x / layer.tileSize.width)</span><br><span class="line"><span class="keyword">let</span> y = Int(bounds.origin.y / layer.tileSize.height)</span><br><span class="line"><span class="keyword">let</span> index = x * (y + <span class="number">1</span>)</span><br><span class="line">print(<span class="string">"x:\(x)--y:\(y)"</span>)</span><br><span class="line">guard <span class="keyword">let</span> imgPath = Bundle.main.path(forResource: <span class="string">"202287155129659img_snowman_2048x2048_\(index)"</span>, <span class="attr">ofType</span>: <span class="string">"jpeg"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">guard <span class="keyword">let</span> img = UIImage(contentsOfFile: imgPath) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">UIGraphicsPushContext(ctx)</span><br><span class="line">img.draw(<span class="keyword">in</span>: bounds)</span><br><span class="line">UIGraphicsPopContext()</span><br></pre></td></tr></table></figure>
<h2 id="CAEmitterLayer"><a href="#CAEmitterLayer" class="headerlink" title="CAEmitterLayer"></a>CAEmitterLayer</h2><p><code>CAEmitterLayer</code>是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果。</p>
<p><code>CAEmitterLayer</code>看上去像是许多<code>CAEmitterCell</code>的容器，这些<code>CAEmitierCell</code>定义了一个粒子效果。你将会为不同的例子效果定义一个或多个<code>CAEmitterCell</code>作为模版，同时<code>CAEmitterLayer</code>负责基于这些模版实例化一个粒子流。一个<code>CAEmitterCell</code>类似于一个<code>CALayer</code>：它有一个<code>contents</code>属性可以定义为一个<code>CGImage</code>，另外还有一些可设置属性控制着表现和行为。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emitter = CAEmitterLayer()</span><br><span class="line">emitter.frame = containerView.bounds</span><br><span class="line">containerView.layer.addSublayer(emitter)</span><br><span class="line">emitter.renderMode = CAEmitterLayerRenderMode.unordered <span class="comment">// 粒子混合方式</span></span><br><span class="line">emitter.emitterPosition = CGPoint(xemitter.frame.size.width/<span class="number">2</span>, yemitter.frame.size.height/<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 添加 Cell</span></span><br><span class="line"><span class="keyword">let</span> cell = CAEmitterCell()</span><br><span class="line">cell.contents = UIImage.init(named:<span class="string">"icon_start"</span>)?.cgImage</span><br><span class="line">cell.birthRate = <span class="number">100</span> <span class="comment">// 生成速度</span></span><br><span class="line">cell.lifetime = <span class="number">5.0</span></span><br><span class="line">cell.color = UIColor.random().cgColor</span><br><span class="line">cell.alphaSpeed = <span class="number">-0.4</span> <span class="comment">// 透明度衰减速度</span></span><br><span class="line">cell.velocity = <span class="number">50</span></span><br><span class="line">cell.velocityRange = <span class="number">50</span></span><br><span class="line">cell.emissionRange = Double.pi * <span class="number">2.0</span> <span class="comment">// 粒子发射角度</span></span><br><span class="line">emitter.emitterCells = [cell]</span><br></pre></td></tr></table></figure>
<h2 id="CAEAGLLayer"><a href="#CAEAGLLayer" class="headerlink" title="CAEAGLLayer"></a>CAEAGLLayer</h2><p><code>OpenGL</code>提供了<code>Core Animation</code>的基础，它是底层的C接口，直接和iPhone，iPad的硬件通信，极少地抽象出来的方法。<code>OpenGL</code>没有对象或是图层的继承概念。它只是简单地处理三角形。<code>OpenGL</code>中所有东西都是3D空间中有颜色和纹理的三角形。</p>
<p>为了能够以高性能使用<code>Core Animation</code>，需要判断你需要绘制哪种内容（矢量图形，例子，文本，等等），但后选择合适的图层去呈现这些内容，<code>Core Animation</code>中只有一些类型的内容是被高度优化的；所以如果绘制的东西并不能找到标准的图层类，高性能就很难实现。</p>
<p>因为<code>OpenGL</code>根本不会对内容进行假设，所以很多游戏都喜欢用<code>OpenGL</code>（这些情况下，<code>Core Animation</code>的限制就明显了：它优化过的内容类型并不一定能满足需求），但是这样依赖，方便的高度抽象接口就没了。</p>
<p>在iOS 5中，苹果引入了一个新的框架叫做<code>GLKit</code>，它去掉了一些设置<code>OpenGL</code>的复杂性，提供了一个叫做<code>CLKView</code>的<code>UIView</code>的子类，帮助处理大部分的设置和绘制工作。前提是各种各样的<code>OpenGL</code>绘图缓冲的底层可配置项仍然需要用<code>CAEAGLLayer</code>完成，它是<code>CALayer</code>的一个子类，用来显示任意的<code>OpenGL</code>图形。</p>
<h2 id="AVPlayerLayer"><a href="#AVPlayerLayer" class="headerlink" title="AVPlayerLayer"></a>AVPlayerLayer</h2><p><code>AVPlayerLayer</code>的使用相当简单：你可以用<code>+playerLayerWithPlayer:</code>方法创建一个已经绑定了视频播放器的图层，或者你可以先创建一个图层，然后用<code>player</code>属性绑定一个<code>AVPlayer</code>实例。<br>因为<code>AVPlayerLayer</code>是<code>CALayer</code>的子类，它继承了父类的所有特性。并不会受限于要在一个矩形中播放视频,可以增加圆角、边框甚至3D变换。</p>
<h1 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a>隐式动画</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><code>Core Animation</code>基于一个假设，说屏幕上的任何东西都可以（或者可能）做动画。动画并不需要在<code>Core Animation</code>中手动打开，相反需要明确地关闭，否则他会一直存在。</p>
<p>所谓的隐式动画指并没有指定任何动画的类型。仅仅改变了一个属性，然后<code>Core Animation</code>来决定如何并且何时去做动画。</p>
<p>但当改变一个属性，<code>Core Animation</code>是如何判断动画类型和持续时间的呢？实际上动画执行的时间取决于当前事务的设置，动画类型取决于图层行为。</p>
<p>事务实际上是<code>Core Animation</code>用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦提交的时候开始用一个动画过渡到新值。</p>
<p>事务是通过<code>CATransaction</code>类来做管理，这个类的设计有些奇怪，不像你从它的命名预期的那样去管理一个简单的事务，而是管理了一叠你不能访问的事务。<code>CATransaction</code>没有属性或者实例方法，并且也不能用<code>+alloc</code>和<code>-init</code>方法创建它。但是可以用<code>+begin</code>和<code>+commit</code>分别来入栈或者出栈。</p>
<p>任何可以做动画的图层属性都会被添加到栈顶的事务，可以通过<code>+setAnimationDuration:</code>方法设置当前事务的动画时间，或者通过<code>+animationDuration</code>方法来获取值（默认0.25秒）。</p>
<p><code>Core Animation</code>在每个<code>run loop</code>周期中自动开始一次新的事务，即使不显式的用<code>[CATransaction begin]</code>开始一次事务，任何在一次<code>run loop</code>循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。</p>
<p><code>CATransaction</code>的<code>+begin</code>和<code>+commit</code>方法在<code>+animateWithDuration:animations:</code>内部自动调用，这样block中所有属性的改变都会被事务所包含。这样也可以避免开发者由于对<code>+begin</code>和<code>+commit</code>匹配的失误造成的风险。</p>
<h2 id="完成回调"><a href="#完成回调" class="headerlink" title="完成回调"></a>完成回调</h2><p>基于<code>UIView</code>的<code>block</code>的动画允许你在动画结束的时候提供一个完成的动作。<code>CATranscation</code>接口提供的<code>+setCompletionBlock:</code>方法也有同样的功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CATransaction.begin()</span><br><span class="line">CATransaction.setAnimationDuration(<span class="number">1.2</span>)</span><br><span class="line">CATransaction.setCompletionBlock &#123;</span><br><span class="line">    <span class="keyword">let</span> transform = CGAffineTransform(rotationAngle: Double.pi)</span><br><span class="line">    self.colorLayer.setAffineTransform(transform)</span><br><span class="line">&#125;</span><br><span class="line">colorLayer.backgroundColor = UIColor.random().cgColor</span><br><span class="line">CATransaction.commit()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意旋转动画要比颜色渐变快得多，这是因为完成块是在颜色渐变的事务提交并出栈之后才被执行，于是，用默认的事务做变换，默认的时间也就变成了0.25秒。</p>
</blockquote>
<h2 id="隐式动画实现-lt-重要-gt"><a href="#隐式动画实现-lt-重要-gt" class="headerlink" title="隐式动画实现&lt;重要&gt;"></a>隐式动画实现&lt;重要&gt;</h2><blockquote>
<p><code>Core Animation</code>通常对<code>CALayer</code>的所有属性（可动画的属性）做动画，但是<code>UIView</code>把它关联的图层的这个特性关闭了。</p>
</blockquote>
<p>把改变属性时<code>CALayer</code>自动应用的动画称作<em>行为</em>，当<code>CALayer</code>的属性被修改时候，它会调用<code>-actionForKey:</code>方法，传递属性的名称。剩下的操作都在<code>CALayer</code>的头文件中有详细的说明，实质上是如下几步：</p>
<ul>
<li>图层首先检测它是否有委托，并且是否实现<code>CALayerDelegate</code>协议指定的<code>-actionForLayer:forKey</code>方法。如果有，直接调用并返回结果。</li>
<li>如果没有委托，或者委托没有实现<code>-actionForLayer:forKey</code>方法，图层接着检查包含属性名称对应行为映射的<code>actions</code>字典。</li>
<li>如果<code>actions字典</code>没有包含对应的属性，那么图层接着在它的<code>style</code>字典接着搜索属性名。</li>
<li>最后，如果在<code>style</code>里面也找不到对应的行为，那么图层将会直接调用定义了每个属性的标准行为的<code>-defaultActionForKey:</code>方法。</li>
</ul>
<p>所以一轮完整的搜索结束之后，<code>-actionForKey:</code>要么返回空（这种情况下将不会有动画发生），要么是<code>CAAction</code>协议对应的对象，最后<code>CALayer</code>拿这个结果去对先前和当前的值做动画。</p>
<p>于是这就解释了UIKit是如何禁用隐式动画的：每个<code>UIView</code>对它关联的图层都扮演了一个委托，并且提供了<code>-actionForLayer:forKey</code>的实现方法。当不在一个动画块的实现中，<code>UIView</code>对所有图层行为返回<code>nil</code>，但是在动画block范围之内，它就返回了一个非空值。</p>
<p>当属性在动画块之外发生改变，<code>UIView</code>直接通过返回<code>nil</code>来禁用隐式动画。但如果在动画块范围之内，根据动画具体类型返回相应的属性。</p>
<p>返回<code>nil</code>并不是禁用隐式动画唯一的办法，<code>CATransacition</code>有个方法叫做<code>+setDisableActions:</code>，可以用来对所有属性打开或者关闭隐式动画。如果在<code>[CATransaction begin]</code>之后添加下面的代码，同样也会阻止动画的发生：</p>
<p><code>CATransaction.setDisableActions(true)</code></p>
<ul>
<li><code>UIView</code>关联的图层禁用了隐式动画，对这种图层做动画的唯一办法就是使用<code>UIView</code>的动画函数（而不是依赖<code>CATransaction</code>），或者继承<code>UIView</code>，并覆盖<code>-actionForLayer:forKey:</code>方法，或者直接创建一个显式动画。</li>
<li>对于单独存在的图层，可以通过实现图层的<code>-actionForLayer:forKey:</code>委托方法，或者提供一个<code>actions</code>字典来控制隐式动画。</li>
</ul>
<p>自定义隐式动画：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> transition = CATransition.init()</span><br><span class="line">transition.type = CATransitionType.push</span><br><span class="line">transition.subtype = CATransitionSubtype.fromRight</span><br><span class="line">colorLayer.actions = [<span class="string">"backgroundColor"</span>:transition]</span><br></pre></td></tr></table></figure>
<h2 id="呈现与模型"><a href="#呈现与模型" class="headerlink" title="呈现与模型"></a>呈现与模型</h2><p><code>CALayer</code>的属性行为其实很不正常，因为改变一个图层的属性并没有立刻生效，而是通过一段时间渐变更新。</p>
<p>当设置<code>CALayer</code>的属性，实际上是在定义当前事务结束之后图层如何显示的<em>模型</em>。Core Animation扮演了一个<em>控制器</em>的角色，并且负责根据图层行为和事务设置去不断更新<em>视图</em>的这些属性在屏幕上的状态。</p>
<p><code>CALayer</code>是一个连接用户界面（就是MVC中的<em>view</em>）虚构的类，但是在界面本身这个场景下，<code>CALayer</code>的行为更像是存储了视图如何显示和动画的数据模型。</p>
<p>在iOS中，屏幕每秒钟重绘60次。如果动画时长比60分之一秒要长，Core Animation就需要在设置一次新值和新值生效之间，对屏幕上的图层进行重新组织。这意味着<code>CALayer</code>除了“真实”值（就是你设置的值）之外，必须要知道当前<em>显示</em>在屏幕上的属性值的记录。</p>
<p>每个图层属性的显示值都被存储在一个叫做<em>呈现图层</em>的独立图层当中，他可以通过<code>-presentationLayer</code>方法来访问。这个呈现图层实际上是模型图层的复制，但是它的属性值代表了在任何指定时刻当前外观效果。</p>
<p>呈现树通过图层树中所有图层的呈现图层所形成。注意呈现图层仅仅当图层首次被<em>提交</em>（就是首次第一次在屏幕上显示）的时候创建，所以在那之前调用<code>-presentationLayer</code>将会返回<code>nil</code>。</p>
<p>有一个叫做<code>–modelLayer</code>的方法。在呈现图层上调用<code>–modelLayer</code>将会返回它正在呈现所依赖的<code>CALayer</code>。通常在一个图层上调用<code>-modelLayer</code>会返回<code>–self</code>（实际上已经创建的原始图层就是一种数据模型）。</p>
<p><img src="https://zsisme.gitbooks.io/ios-/content/chapter7/7.4.jpeg" alt></p>
<p>大多数情况下，不需要直接访问呈现图层，你可以通过和模型图层的交互，来让Core Animation更新显示。两种情况下呈现图层会变得很有用，一个是同步动画，一个是处理用户交互。</p>
<ul>
<li>如果实现一个基于定时器的动画，而不仅仅是基于事务的动画，这个时候准确地知道在某一时刻图层显示在什么位置就会对正确摆放图层很有用了。</li>
<li>如果想让做动画的图层响应用户输入，你可以使用<code>-hitTest:</code>方法来判断指定图层是否被触摸，这时候对<em>呈现</em>图层而不是<em>模型</em>图层调用<code>-hitTest:</code>会显得更有意义，因为呈现图层代表了用户当前看到的图层位置，而不是当前动画结束之后的位置。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">override func touchesBegan(_ touches: <span class="built_in">Set</span>&lt;UITouch&gt;, <span class="keyword">with</span> event: UIEvent?) &#123;</span><br><span class="line">    guard <span class="keyword">let</span> point = touches.first?.location(<span class="keyword">in</span>: self.view) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> ((colorLayer.presentation()?.hitTest(point)) != nil) &#123;</span><br><span class="line">        colorLayer.backgroundColor = UIColor.random().cgColor</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CATransaction.begin()</span><br><span class="line">        CATransaction.setAnimationDuration(<span class="number">2.0</span>)</span><br><span class="line">        colorLayer.position = point</span><br><span class="line">        CATransaction.commit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="显式动画"><a href="#显式动画" class="headerlink" title="显式动画"></a>显式动画</h1><h2 id="x20-属性动画"><a href="#x20-属性动画" class="headerlink" title="&#x20;属性动画"></a>&#x20;属性动画</h2><p>当更新属性的时候，我们需要设置一个新的事务，并且禁用图层行为。否则动画会发生两次，一个是因为显式的<code>CABasicAnimation</code>，另一次是因为隐式动画。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@objc func basicAnimation() &#123;</span><br><span class="line">    <span class="keyword">let</span> animation = CABasicAnimation()</span><br><span class="line">    animation.keyPath = <span class="string">"backgroundColor"</span></span><br><span class="line">    animation.toValue = UIColor.random().cgColor</span><br><span class="line">    animation.delegate = self</span><br><span class="line">    colorLayer.add(animation, <span class="attr">forKey</span>: nibName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private func animationDidStop(_ anim: CABasicAnimation, finished flag: Bool) &#123;</span><br><span class="line">    CATransaction.begin()</span><br><span class="line">    CATransaction.setDisableActions(<span class="literal">true</span>) <span class="comment">// 关闭隐式动画 防止多次动画</span></span><br><span class="line">    colorLayer.backgroundColor = anim.toValue <span class="keyword">as</span>! CGColor?</span><br><span class="line">    CATransaction.commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对<code>CAAnimation</code>而言，使用委托模式而不是一个完成块会带来一个问题，就是当有多个动画的时候，无法在在回调方法中区分。</p>
<p>动画本身会作为一个参数传入委托的方法，也许可以控制器中把动画存储为一个属性，然后在回调用比较，但实际上并不起作用，因为委托传入的动画参数是原始值的一个深拷贝，从而不是同一个值。</p>
<p>像所有的<code>NSObject</code>子类一样，<code>CAAnimation</code>实现了KVC（键-值-编码）协议，可以用<code>-setValue:forKey:</code>和<code>-valueForKey:</code>方法来存取属性。但是<code>CAAnimation</code>有一个不同的性能：它更像一个<code>NSDictionary</code>，可以随意设置键值对，即使使用的动画类所声明的属性并不匹配。这意味着你可以对动画用任意类型打标签。</p>
<blockquote>
<p>在<code>-animationDidStop:finished:</code>委托方法调用之前，指针会迅速返回到原始值,可以用一个<code>fillMode</code>属性来解决这个问题。</p>
</blockquote>
<h3 id="关键帧动画"><a href="#关键帧动画" class="headerlink" title="关键帧动画"></a>关键帧动画</h3><p><code>CAKeyframeAnimation</code>同样是<code>CAPropertyAnimation</code>的一个子类，它依然作用于单一的一个属性，但是和<code>CABasicAnimation</code>不一样的是，它不限制于设置一个起始和结束的值，而是可以根据一连串随意的值来做动画。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@objc func keyframeAnimation() &#123;</span><br><span class="line">    <span class="keyword">let</span> animation = CAKeyframeAnimation()</span><br><span class="line">    animation.keyPath = <span class="string">"backgroundColor"</span></span><br><span class="line">    animation.duration = <span class="number">2</span></span><br><span class="line">    animation.values = [UIColor.random().cgColor,UIColor.random().cgColor,UIColor.random().cgColor,UIColor.blue.cgColor]</span><br><span class="line">    colorLayer.add(animation, <span class="attr">forKey</span>: nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到序列中开始和结束的颜色都是蓝色，这是因为<code>CAKeyframeAnimation</code>并不能自动把当前值作为第一帧（就像<code>CABasicAnimation</code>那样把<code>fromValue</code>设为<code>nil</code>）。动画会在开始的时候突然跳转到第一帧的值，然后在动画结束的时候突然恢复到原始的值。所以为了动画的平滑特性，需要开始和结束的关键帧来匹配当前属性的值。</p>
<p>当然可以创建一个结束和开始值不同的动画，那样的话就需要在动画启动之前手动更新属性和最后一帧的值保持一致，就和之前讨论的一样。</p>
<p>通过贝塞尔曲线对图层做动画：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贝塞尔曲线动画</span></span><br><span class="line">func configAnimationPath() &#123;</span><br><span class="line">    <span class="keyword">let</span> bezierPath = UIBezierPath()</span><br><span class="line">    bezierPath.move(to: CGPoint(x: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">150</span>))</span><br><span class="line">    bezierPath.addCurve(to: CGPoint(x: <span class="number">300</span>, <span class="attr">y</span>: <span class="number">150</span>), <span class="attr">controlPoint1</span>: CGPoint(x: <span class="number">75</span>, <span class="attr">y</span>: <span class="number">0</span>), <span class="attr">controlPoint2</span>: CGPoint(x: <span class="number">225</span>, <span class="attr">y</span>: <span class="number">300</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> pathLayer = CAShapeLayer()</span><br><span class="line">    pathLayer.path = bezierPath.cgPath</span><br><span class="line">    pathLayer.fillColor = UIColor.clear.cgColor</span><br><span class="line">    pathLayer.strokeColor = UIColor.random().cgColor</span><br><span class="line">    pathLayer.lineWidth = <span class="number">3.0</span></span><br><span class="line">    self.view.layer.addSublayer(pathLayer)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> snowmanLayer = CALayer()</span><br><span class="line">    snowmanLayer.frame = CGRect(x: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>, <span class="attr">width</span>: <span class="number">50</span>, <span class="attr">height</span>: <span class="number">50</span>)</span><br><span class="line">    guard <span class="keyword">let</span> imgPath = Bundle.main.path(forResource: <span class="string">"img_snow_man"</span>, <span class="attr">ofType</span>: <span class="string">"jpeg"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> img = UIImage(contentsOfFile: imgPath)</span><br><span class="line">    snowmanLayer.contents = img!.cgImage;</span><br><span class="line">    self.view.layer.addSublayer(snowmanLayer)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> animation = CAKeyframeAnimation()</span><br><span class="line">    animation.keyPath = <span class="string">"position"</span></span><br><span class="line">    animation.duration = <span class="number">4.0</span></span><br><span class="line">    animation.path = bezierPath.cgPath</span><br><span class="line">    animation.rotationMode = CAAnimationRotationMode.rotateAuto; <span class="comment">// 调整旋转方向</span></span><br><span class="line">    snowmanLayer.add(animation, <span class="attr">forKey</span>: nibName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="虚拟属性"><a href="#虚拟属性" class="headerlink" title="虚拟属性"></a>虚拟属性</h3><p>属性动画实际上是针对于关键<em>路径</em>而不是一个键，这就意味着可以对子属性甚至是<em>虚拟属性</em>做动画。</p>
<p>考虑一个旋转的动画：如果想要对一个物体做旋转的动画，那就需要作用于<code>transform</code>属性，因为<code>CALayer</code>没有显式提供角度或者方向之类的属性。</p>
<p>为了旋转图层，我们可以对<code>transform.rotation</code>关键路径应用动画，而不是<code>transform</code>本身。</p>
<p>用<code>transform.rotation</code>而不是<code>transform</code>做动画的好处如下：</p>
<ul>
<li>可以不通过关键帧一步旋转多于180度的动画。</li>
<li>可以用相对值而不是绝对值旋转（设置<code>byValue</code>而不是<code>toValue</code>）。</li>
<li>可以不用创建<code>CATransform3D</code>，而是使用一个简单的数值来指定角度。</li>
<li>不会和<code>transform.position</code>或者<code>transform.scale</code>冲突（同样是使用关键路径来做独立的动画属性）。</li>
</ul>
<blockquote>
<p><code>transform.rotation</code>属性有一个奇怪的问题是它其实<em>并不存在</em>。这是因为<code>CATransform3D</code>并不是一个对象，它实际上是一个结构体，也没有符合KVC相关属性，<code>transform.rotation</code>实际上是一个<code>CALayer</code>用于处理动画变换的<em>虚拟</em>属性。</p>
</blockquote>
<p>不可以直接设置<code>transform.rotation</code>或者<code>transform.scale</code>，他们不能被直接使用。当你对他们做动画时，Core Animation自动地根据通过<code>CAValueFunction</code>来计算的值来更新<code>transform</code>属性。</p>
<h2 id="动画组"><a href="#动画组" class="headerlink" title="动画组"></a>动画组</h2><p><code>CAAnimationGroup</code>是另一个继承于<code>CAAnimation</code>的子类，它添加了一个<code>animations</code>数组的属性，用来组合别的动画。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> groupAnimation = CAAnimationGroup()</span><br><span class="line">groupAnimation.animations = [animation,animation]</span><br><span class="line">groupAnimation.duration = <span class="number">4.0</span></span><br><span class="line">colorLayer.add(groupAnimation, <span class="attr">forKey</span>: nibName)</span><br></pre></td></tr></table></figure>
<h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><p>属性动画只对图层的可动画属性起作用，所以如果要改变一个不能动画的属性（比如图片），或者从层级关系中添加或者移除图层，属性动画将不起作用。</p>
<p>过渡并不像属性动画那样平滑地在两个值之间做动画，而是影响到整个图层的变化。过渡动画首先展示之前的图层外观，然后通过一个交换过渡到新的外观。</p>
<p>为了创建一个过渡动画，我们将使用<code>CATransition</code>，同样是另一个<code>CAAnimation</code>的子类，和别的子类不同，<code>CATransition</code>有一个<code>type</code>和<code>subtype</code>来标识变换效果。<code>type</code>属性是一个<code>NSString</code>类型，可以被设置成如下类型：</p>
<pre><code>kCATransitionFade 
kCATransitionMoveIn 
kCATransitionPush 
kCATransitionReveal
</code></pre><p>后面三种过渡类型都有一个默认的动画方向，它们都从左侧滑入，但是你可以通过<code>subtype</code>来控制它们的方向，提供了如下四种类型：</p>
<pre><code>kCATransitionFromRight 
kCATransitionFromLeft 
kCATransitionFromTop 
kCATransitionFromBottom
</code></pre><h3 id="对图层树的动画"><a href="#对图层树的动画" class="headerlink" title="对图层树的动画"></a>对图层树的动画</h3><p><code>CATransition</code>并不作用于指定的图层属性，就是可以在即使不能准确得知改变了什么的情况下对图层做动画，例如，在不知道<code>UITableView</code>哪一行被添加或者删除的情况下，直接就可以平滑地刷新它，或者在不知道<code>UIViewController</code>内部的视图层级的情况下对两个不同的实例做过渡动画。</p>
<p>它们不仅涉及到图层的属性，而且是整个<em>图层树</em>的改变–我们在这种动画的过程中手动在层级关系中添加或者移除图层。</p>
<p>一般来说，你只需要将动画添加到被影响图层的<code>superlayer</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item &#123;</span><br><span class="line">    CATransition *tran = [CATransition animation];</span><br><span class="line">    tran.type = kCATransitionFade;</span><br><span class="line">    [self.view.layer addAnimation:tran forKey:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在动画过程中取消动画"><a href="#在动画过程中取消动画" class="headerlink" title="在动画过程中取消动画"></a>在动画过程中取消动画</h2><p>用<code>-addAnimation:forKey:</code>方法中的<code>key</code>参数来在添加动画之后检索一个动画。</p>
<p>但并不支持在动画运行过程中修改动画，所以这个方法主要用来检测动画的属性，或者判断它是否被添加到当前图层中。</p>
<p>为了终止一个指定的动画，你可以用如下方法把它从图层移除掉：</p>
<pre><code>- (void)removeAnimationForKey:(NSString *)key;
</code></pre><p>或者移除所有动画：</p>
<pre><code>- (void)removeAllAnimations;
</code></pre><p>动画一旦被移除，图层的外观就立刻更新到当前的模型图层的值。一般说来，动画在结束之后被自动移除，除非设置<code>removedOnCompletion</code>为<code>NO</code>，如果你设置动画在结束之后不被自动移除，那么当它不需要的时候你要手动移除它；否则它会一直存在于内存中，直到图层被销毁。</p>
<p>通过代理判断是动画结束还是手动移除：</p>
<pre><code>- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag
{
    //log that the animation stopped
    NSLog(@&quot;The animation stopped (finished: %@)&quot;, flag? @&quot;YES&quot;: @&quot;NO&quot;);
}
</code></pre><h1 id="图层时间"><a href="#图层时间" class="headerlink" title="图层时间"></a>图层时间</h1><h2 id="CAMediaTiming协议"><a href="#CAMediaTiming协议" class="headerlink" title="CAMediaTiming协议"></a><code>CAMediaTiming</code>协议</h2><p><code>CAMediaTiming</code>协议定义了在一段动画内用来控制逝去时间的属性的集合，<code>CALayer</code>和<code>CAAnimation</code>都实现了这个协议，所以时间可以被任意基于一个图层或者一段动画的类控制。</p>
<h3 id="持续和重复"><a href="#持续和重复" class="headerlink" title="持续和重复"></a>持续和重复</h3><p><code>duration</code>是一个<code>CFTimeInterval</code>的类型（类似于<code>NSTimeInterval</code>的一种双精度浮点类型），对将要进行的动画的一次迭代指定了时间。</p>
<p><code>CAMediaTiming</code>另外还有一个属性叫做<code>repeatCount</code>，代表动画重复的迭代次数。如果<code>duration</code>是2，<code>repeatCount</code>设为3.5（三个半迭代），那么完整的动画时长将是7秒。</p>
<p><code>duration</code>和<code>repeatCount</code>默认都是0。但这不意味着动画时长为0秒，或者0次，这里的0仅仅代表了“默认”，也就是0.25秒和1次。</p>
<p>创建重复动画的另一种方式是使用<code>repeatDuration</code>属性，它让动画重复一个指定的时间，而不是指定次数，<code>INFINITY</code>代表无限循环。设置<code>autoreverses</code>的属性（BOOL类型）在每次间隔交替循环过程中自动回放。这对于播放一段连续非循环的动画很有用，例如打开一扇门，然后关上。</p>
<h3 id="相对时间"><a href="#相对时间" class="headerlink" title="相对时间"></a>相对时间</h3><p>每个动画都有它自己描述的时间，可以独立地加速，延时或者偏移。</p>
<p><code>beginTime</code>指定了动画开始之前的的延迟时间。这里的延迟从动画添加到可见图层的那一刻开始测量，默认是0（就是说动画会立刻执行）。</p>
<p><code>speed</code>是一个时间的倍数，默认1.0，减少它会减慢图层/动画的时间，增加它会加快速度。如果2.0的速度，那么对于一个<code>duration</code>为1的动画，实际上在0.5秒的时候就已经完成了。</p>
<p><code>timeOffset</code>和<code>beginTime</code>类似，但是和增加<code>beginTime</code>导致的延迟动画不同，增加<code>timeOffset</code>只是让动画快进到某一点，例如，对于一个持续1秒的动画来说，设置<code>timeOffset</code>为0.5意味着动画将从一半的地方开始。</p>
<p>和<code>beginTime</code>不同的是，<code>timeOffset</code>并不受<code>speed</code>的影响。所以如果你把<code>speed</code>设为2.0，把<code>timeOffset</code>设置为0.5，那么动画将从动画最后结束的地方开始，因为1秒的动画实际上被缩短到了0.5秒。然而即使使用了<code>timeOffset</code>让动画从结束的地方开始，它仍然播放了一个完整的时长，这个动画仅仅是循环了一圈，然后从头开始播放。</p>
<h3 id="fillMode"><a href="#fillMode" class="headerlink" title="fillMode"></a><code>fillMode</code></h3><p><code>removeOnCompletion</code>被设置为<code>NO</code>的动画将会在动画结束的时候仍然保持之前的状态。</p>
<p>一种可能是属性和动画没被添加之前保持一致，也就是在模型图层定义的值。</p>
<p>另一种可能是保持动画开始之前那一帧，或者动画结束之后的那一帧。这就是所谓的<em>填充</em>，因为动画开始和结束的值用来填充开始之前和结束之后的时间。</p>
<p>它可以被<code>CAMediaTiming</code>的<code>fillMode</code>来控制。<code>fillMode</code>是一个<code>NSString</code>类型，可以接受如下四种常量：</p>
<pre><code>kCAFillModeForwards 
kCAFillModeBackwards 
kCAFillModeBoth 
kCAFillModeRemoved
</code></pre><p>默认是<code>kCAFillModeRemoved</code>，当动画不再播放的时候就显示图层模型指定的值剩下的三种类型向前，向后或者即向前又向后去填充动画状态，使得动画在开始前或者结束后仍然保持开始和结束那一刻的值。</p>
<blockquote>
<p>需要把<code>removeOnCompletion</code>设置为<code>NO</code>，另外需要给动画添加一个非空的键，于是可以在不需要动画的时候把它从图层上移除。</p>
</blockquote>
<pre><code>animation.fillMode = CAMediaTimingFillMode.both
animation.isRemovedOnCompletion = false
</code></pre><h2 id="层级关系时间"><a href="#层级关系时间" class="headerlink" title="层级关系时间"></a>层级关系时间</h2><p>每个动画和图层在时间上都有它自己的层级概念，相对于它的父亲来测量。对图层调整时间将会影响到它本身和子图层的动画，但不会影响到父图层。另一个相似点是所有的动画都被按照层级组合（使用<code>CAAnimationGroup</code>实例）。</p>
<p>对<code>CALayer</code>或者<code>CAGroupAnimation</code>调整<code>duration</code>和<code>repeatCount</code>/<code>repeatDuration</code>属性并不会影响到子动画。但是<code>beginTime</code>，<code>timeOffset</code>和<code>speed</code>属性将会影响到子动画。然而在层级关系中，<code>beginTime</code>指定了父图层开始动画（或者组合关系中的父动画）和对象将要开始自己动画之间的偏移。类似的，调整<code>CALayer</code>和<code>CAGroupAnimation</code>的<code>speed</code>属性将会对动画以及子动画速度应用一个缩放的因子。</p>
<h3 id="全局时间和本地时间"><a href="#全局时间和本地时间" class="headerlink" title="全局时间和本地时间"></a>全局时间和本地时间</h3><p>CoreAnimation有一个<em>全局时间</em>的概念，也就是所谓的<em>马赫时间</em>（“马赫”实际上是iOS和Mac OS系统内核的命名）。马赫时间在设备上所有进程都是全局的–但是在不同设备上并不是全局的–不过这已经足够对动画的参考点提供便利了，使用<code>CACurrentMediaTime</code>函数来访问马赫时间：</p>
<pre><code>CFTimeInterval time = CACurrentMediaTime();
</code></pre><p>这个函数返回的值其实无关紧要（它返回了设备自从上次启动后的秒数，并不是你所关心的），它真实的作用在于对动画的时间测量提供了一个相对值。注意当设备休眠的时候马赫时间会暂停，也就是所有的<code>CAAnimations</code>（基于马赫时间）同样也会暂停。</p>
<p>因此马赫时间对长时间测量并不有用。比如用<code>CACurrentMediaTime</code>去更新一个实时闹钟并不明智。（可以用<code>[NSDate date]</code>代替）。</p>
<p>每个<code>CALayer</code>和<code>CAAnimation</code>实例都有自己<em>本地</em>时间的概念，是根据父图层/动画层级关系中的<code>beginTime</code>，<code>timeOffset</code>和<code>speed</code>属性计算。就和转换不同图层之间坐标关系一样，<code>CALayer</code>同样也提供了方法来转换不同图层之间的<em>本地时间</em>。如下：</p>
<pre><code>- (CFTimeInterval)convertTime:(CFTimeInterval)t fromLayer:(CALayer *)l; 
- (CFTimeInterval)convertTime:(CFTimeInterval)t toLayer:(CALayer *)l;
</code></pre><p>当用来同步不同图层之间有不同的<code>speed</code>，<code>timeOffset</code>和<code>beginTime</code>的动画，这些方法会很有用。</p>
<h3 id="暂停，倒回和快进"><a href="#暂停，倒回和快进" class="headerlink" title="暂停，倒回和快进"></a>暂停，倒回和快进</h3><p>设置动画的<code>speed</code>属性为0可以暂停动画，但在动画被添加到图层之后不太可能再修改它了，所以不能对正在进行的动画使用这个属性。</p>
<p>给图层添加一个<code>CAAnimation</code>实际上是给动画对象做了一个不可改变的拷贝，所以对原始动画对象属性的改变对真实的动画并没有作用。相反，直接用<code>-animationForKey:</code>来检索图层正在进行的动画可以返回正确的动画对象，但是修改它的属性将会抛出异常。</p>
<p>如果移除图层正在进行的动画，图层将会急速返回动画之前的状态。但如果在动画移除之前拷贝呈现图层到模型图层，动画将会看起来暂停在那里。但是不好的地方在于之后就不能再恢复动画了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)pauseLayer:(CALayer*)layer &#123;</span><br><span class="line">   CFTimeInterval pausedTime = [layer convertTime:CACurrentMediaTime() fromLayer:nil];</span><br><span class="line">   layer.speed = <span class="number">0.0</span>;</span><br><span class="line">   layer.timeOffset = pausedTime;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)resumeLayer:(CALayer*)layer &#123;</span><br><span class="line">   CFTimeInterval pausedTime = [layer timeOffset];</span><br><span class="line">   layer.speed = <span class="number">1.0</span>;</span><br><span class="line">   layer.timeOffset = <span class="number">0.0</span>;</span><br><span class="line">   layer.beginTime = <span class="number">0.0</span>;</span><br><span class="line">   CFTimeInterval timeSincePause = [layer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime;</span><br><span class="line">   layer.beginTime = timeSincePause;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的方法是可以利用<code>CAMediaTiming</code>来暂停<em>图层</em>本身。如果把图层的<code>speed</code>设置成0，它会暂停任何添加到图层上的动画。类似的，设置<code>speed</code>大于1.0将会快进，设置成一个负值将会倒回动画。</p>
<p>通过增加主窗口图层的<code>speed</code>，可以暂停整个应用程序的动画。</p>
<pre><code>self.window.layer.speed = 100;
</code></pre><p>也可以通过这种方式来<em>减速</em>，但其实也可以在模拟器通过切换慢速动画来实现。</p>
<h1 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h1><h2 id="动画速度"><a href="#动画速度" class="headerlink" title="动画速度"></a>动画速度</h2><p>动画实际上就是一段时间内的变化，这就暗示了变化一定是随着某个特定的速率进行。速率由以下公式计算而来：</p>
<pre><code>velocity = change / time
</code></pre><p>对于这种恒定速度的动画我们称之为“线性步调”，而且从技术的角度而言这也是实现动画最简单的方式，但也是<em>完全不真实</em>的一种效果。</p>
<h3 id="CAMediaTimingFunction"><a href="#CAMediaTimingFunction" class="headerlink" title="CAMediaTimingFunction"></a><code>CAMediaTimingFunction</code></h3><p>首先需要设置<code>CAAnimation</code>的<code>timingFunction</code>属性，是<code>CAMediaTimingFunction</code>类的一个对象。如果想改变隐式动画的计时函数，同样也可以使用<code>CATransaction</code>的<code>+setAnimationTimingFunction:</code>方法。</p>
<p>这里有一些方式来创建<code>CAMediaTimingFunction</code>，最简单的方式是调用<code>+timingFunctionWithName:</code>的构造方法。这里传入如下几个常量之一：</p>
<pre><code>kCAMediaTimingFunctionLinear 
kCAMediaTimingFunctionEaseIn // 慢慢加速然后突然停止
kCAMediaTimingFunctionEaseOut  // 一个全速开始，然后慢慢减速停止
kCAMediaTimingFunctionEaseInEaseOut // 慢慢加速然后再慢慢减速
kCAMediaTimingFunctionDefault // 同上 但加速和减速的过程都稍微有些慢



CATransaction.begin()
CATransaction.setDisableActions(true)
CATransaction.setAnimationDuration(1.2)
CATransaction.setAnimationTimingFunction(CAMediaTimingFunction(name:.easeOut))
colorLayer.backgroundColor = UIColor.random().cgColor
CATransaction.commit()
</code></pre><h3 id="UIView的动画缓冲"><a href="#UIView的动画缓冲" class="headerlink" title="UIView的动画缓冲"></a><code>UIView</code>的动画缓冲</h3><p>UIKit的动画也同样支持这些缓冲方法的使用，尽管语法和常量有些不同，为了改变<code>UIView</code>动画的缓冲选项，给<code>options</code>参数添加如下常量之一：</p>
<pre><code>UIViewAnimationOptionCurveEaseInOut 
UIViewAnimationOptionCurveEaseIn 
UIViewAnimationOptionCurveEaseOut 
UIViewAnimationOptionCurveLinear
</code></pre><p>它们和<code>CAMediaTimingFunction</code>紧密关联，<code>UIViewAnimationOptionCurveEaseInOut</code>是默认值（这里没有<code>kCAMediaTimingFunctionDefault</code>相对应的值了）。</p>
<h3 id="缓冲和关键帧动画"><a href="#缓冲和关键帧动画" class="headerlink" title="缓冲和关键帧动画"></a>缓冲和关键帧动画</h3><p><code>CAKeyframeAnimation</code>有一个<code>NSArray</code>类型的<code>timingFunctions</code>属性，我们可以用它来对每次动画的步骤指定不同的计时函数。但是指定函数的个数一定要等于<code>keyframes</code>数组的元素个数<em>减一</em>，因为它是描述每一帧之间动画速度的函数。</p>
<pre><code>let animation = CAKeyframeAnimation()
animation.keyPath = &quot;backgroundColor&quot;
animation.duration = 2
animation.values = [UIColor.random().cgColor,UIColor.random().cgColor,UIColor.random().cgColor,UIColor.blue.cgColor]
let fn = CAMediaTimingFunction(name:.easeOut)
animation.timingFunctions = [fn,fn,fn,fn]
colorLayer.add(animation, forKey: nil)
</code></pre><h2 id="自定义缓冲函数"><a href="#自定义缓冲函数" class="headerlink" title="自定义缓冲函数"></a>自定义缓冲函数</h2><p>除了<code>+functionWithName:</code>之外，<code>CAMediaTimingFunction</code>同样有另一个构造函数，一个有四个浮点参数的<code>+functionWithControlPoints::::</code>（注意这里奇怪的语法，并没有包含具体每个参数的名称，这在objective-C中是合法的，但是却违反了苹果对方法命名的指导方针，而且看起来是一个奇怪的设计）。</p>
<p><code>CAMediaTimingFunction</code>函数的主要原则在于它把输入的时间转换成起点和终点之间成比例的改变。</p>
<p><code>CAMediaTimingFunction</code>使用了一个叫做<em>三次贝塞尔曲线</em>的函数，它只可以产出指定缓冲函数的子集。</p>
<p><img src="https://zsisme.gitbooks.io/ios-/content/chapter10/10.2.jpeg" alt="图10.2" title="图10.2"></p>
<p>曲线的斜率代表了速度，斜率的改变代表了加速度。先加速，然后减速，最后快到达终点的时候又加速。</p>
<p><code>CAMediaTimingFunction</code>有一个叫做<code>-getControlPointAtIndex:values:</code>的方法，可以用来检索曲线的点，但是使用它我们可以找到标准缓冲函数的点，然后用<code>UIBezierPath</code>和<code>CAShapeLayer</code>来把它画出来。</p>
<h3 id="基于关键帧的缓冲"><a href="#基于关键帧的缓冲" class="headerlink" title="基于关键帧的缓冲"></a>基于关键帧的缓冲</h3><p>为了使用关键帧实现反弹动画，需要在缓冲曲线中对每一个显著的点创建一个关键帧（在这个情况下，关键点也就是每次反弹的峰值），然后应用缓冲函数把每段曲线连接起来。同时，我们也需要通过<code>keyTimes</code>来指定每个关键帧的时间偏移，由于每次反弹的时间都会减少，于是关键帧并不会均匀分布。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func animate() &#123;</span><br><span class="line">    snowmanView.center = CGPoint(x: <span class="number">150</span>,<span class="attr">y</span>: <span class="number">50</span>);</span><br><span class="line">    <span class="keyword">let</span> animation = CAKeyframeAnimation()</span><br><span class="line">    animation.keyPath = <span class="string">"position"</span></span><br><span class="line">    animation.duration = <span class="number">1.0</span></span><br><span class="line">    animation.delegate = self</span><br><span class="line">    animation.values = [NSValue(cgPoint: CGPoint(x: <span class="number">150</span>, <span class="attr">y</span>: <span class="number">50</span>)),</span><br><span class="line">                        NSValue(cgPoint: CGPoint(x: <span class="number">150</span>, <span class="attr">y</span>: <span class="number">300</span>)),</span><br><span class="line">                        NSValue(cgPoint: CGPoint(x: <span class="number">150</span>, <span class="attr">y</span>: <span class="number">200</span>)),</span><br><span class="line">                        NSValue(cgPoint: CGPoint(x: <span class="number">150</span>, <span class="attr">y</span>: <span class="number">250</span>)),</span><br><span class="line">                        NSValue(cgPoint: CGPoint(x: <span class="number">150</span>, <span class="attr">y</span>: <span class="number">150</span>)),</span><br><span class="line">                        NSValue(cgPoint: CGPoint(x: <span class="number">150</span>, <span class="attr">y</span>: <span class="number">100</span>)),</span><br><span class="line">                        NSValue(cgPoint: CGPoint(x: <span class="number">150</span>, <span class="attr">y</span>: <span class="number">300</span>))]</span><br><span class="line">    animation.timingFunctions = [</span><br><span class="line">        CAMediaTimingFunction(name: .easeIn),</span><br><span class="line">        CAMediaTimingFunction(name: .easeIn),</span><br><span class="line">        CAMediaTimingFunction(name: .easeOut),</span><br><span class="line">        CAMediaTimingFunction(name: .easeOut),</span><br><span class="line">        CAMediaTimingFunction(name: .easeIn),</span><br><span class="line">        CAMediaTimingFunction(name: .easeOut),</span><br><span class="line">        CAMediaTimingFunction(name: .easeIn)</span><br><span class="line">    ];</span><br><span class="line">    animation.keyTimes = [NSNumber(value: <span class="number">0.0</span>),</span><br><span class="line">                          NSNumber(value: <span class="number">0.3</span>),</span><br><span class="line">                          NSNumber(value: <span class="number">0.5</span>),</span><br><span class="line">                          NSNumber(value: <span class="number">0.7</span>),</span><br><span class="line">                          NSNumber(value: <span class="number">0.8</span>),</span><br><span class="line">                          NSNumber(value: <span class="number">0.9</span>),</span><br><span class="line">                          NSNumber(value: <span class="number">0.95</span>),</span><br><span class="line">                          NSNumber(value: <span class="number">1.0</span>)]</span><br><span class="line">    snowmanView.layer.position = CGPoint(x: <span class="number">150</span>, <span class="attr">y</span>: <span class="number">300</span>)</span><br><span class="line">    snowmanView.layer.add(animation, <span class="attr">forKey</span>: nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="流程自动化"><a href="#流程自动化" class="headerlink" title="流程自动化"></a>流程自动化</h3><p>用代码获取属性动画的起始值之间的任意插值，我们就可以把动画分割成许多独立的关键帧，然后产出一个线性的关键帧动画。</p>
<p>需要做以下两点：</p>
<ul>
<li>自动把任意属性动画分割成多个关键帧。</li>
<li>用一个数学函数表示弹性动画，使得可以对帧做偏移。</li>
</ul>
<p>公式如下：</p>
<pre><code>value = (endValue – startValue) × time + startValue;
</code></pre><p>使用60 x 动画时间（秒做单位）作为关键帧的个数，这时因为Core Animation按照每秒60帧去渲染屏幕更新，所以如果我们每秒生成60个关键帧，就可以保证动画足够的平滑（尽管实际上很可能用更少的帧率就可以达到很好的效果）。</p>
<h1 id="基于定时器的动画"><a href="#基于定时器的动画" class="headerlink" title="基于定时器的动画"></a>基于定时器的动画</h1><h3 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a><code>NSTimer</code></h3><p>iOS上的每个线程都管理了一个<code>NSRunloop</code>，字面上看就是通过一个循环来完成一些任务列表。但是对主线程，这些任务包含如下几项：</p>
<ul>
<li>处理触摸事件</li>
<li>发送和接受网络数据包</li>
<li>执行使用gcd的代码</li>
<li>处理计时器行为</li>
<li>屏幕重绘</li>
</ul>
<p>当设置一个<code>NSTimer</code>，他会被插入到当前任务列表中，然后直到指定时间过去之后才会被执行。但是何时启动定时器并没有一个时间上限，而且它只会在列表中上一个任务完成之后开始执行。这通常会导致有几毫秒的延迟，但是如果上一个任务过了很久才完成就会导致延迟很长一段时间。</p>
<p>屏幕重绘的频率是一秒钟六十次，但是和定时器行为一样，如果列表中上一个执行了很长时间，它也会延迟。这些延迟都是一个随机值，于是就不能保证定时器精准地一秒钟执行六十次。有时候发生在屏幕重绘之后，这就会使得更新屏幕会有个延迟，看起来就是动画卡壳了。有时候定时器会在屏幕更新的时候执行两次，于是动画看起来就跳动了。</p>
<p>可以通过一些途径来优化：</p>
<ul>
<li>可以用<code>CADisplayLink</code>让更新频率严格控制在每次屏幕刷新之后。</li>
<li>基于真实帧的持续时间而不是假设的更新频率来做动画。</li>
<li>调整动画计时器的<code>run loop</code>模式，这样就不会被别的事件干扰。</li>
</ul>
<h3 id="CADisplayLink"><a href="#CADisplayLink" class="headerlink" title="CADisplayLink"></a><code>CADisplayLink</code></h3><p><code>CADisplayLink</code>是CoreAnimation提供的另一个类似于<code>NSTimer</code>的类，<code>它总是在屏幕完成一次更新之前启动</code>，它的接口设计的和<code>NSTimer</code>很类似，所以它实际上就是一个内置实现的替代，但是和<code>timeInterval</code>以秒为单位不同，<code>CADisplayLink</code>有一个整型的<code>frameInterval</code>属性，指定了间隔多少帧之后才执行。默认值是1，意味着每次屏幕更新之前都会执行一次。但是如果动画的代码执行起来超过了六十分之一秒，可以指定<code>frameInterval</code>为2，就是说动画每隔一帧执行一次（一秒钟30帧）或者3，也就是一秒钟20次，等等。</p>
<p>用<code>CADisplayLink</code>而不是<code>NSTimer</code>，会保证帧率足够连续，使得动画看起来更加平滑，但即使<code>CADisplayLink</code>也不能<em>保证</em>每一帧都按计划执行，一些失去控制的离散的任务或者事件（例如资源紧张的后台程序）可能会导致动画偶尔地丢帧。</p>
<blockquote>
<p>当使用<code>NSTimer</code>的时候，一旦有机会计时器就会开启，但是<code>CADisplayLink</code>却不一样：如果它丢失了帧，就会直接忽略它们，然后在下一次更新的时候接着运行。</p>
</blockquote>
<h3 id="x20-Run-Loop-模式"><a href="#x20-Run-Loop-模式" class="headerlink" title="&#x20;Run Loop 模式"></a>&#x20;Run Loop 模式</h3><p>当创建<code>CADisplayLink</code>的时候，需要指定一个<code>run loop</code>和<code>run loop mode</code>，对于run loop来说，就使用了主线程的run loop，因为任何用户界面的更新都需要在主线程执行，但是模式的选择就并不那么清楚了，每个添加到run loop的任务都有一个指定了优先级的模式，为了保证用户界面保持平滑，iOS会提供和用户界面相关任务的优先级，而且当UI很活跃的时候的确会暂停一些别的任务。</p>
<p>一个典型的例子就是当是用<code>UIScrollview</code>滑动的时候，重绘滚动视图的内容会比别的任务优先级更高，所以标准的<code>NSTimer</code>和网络请求就不会启动，一些常见的run loop模式如下：</p>
<ul>
<li><code>NSDefaultRunLoopMode</code> - 标准优先级</li>
<li><code>NSRunLoopCommonModes</code> - 高优先级</li>
<li><code>UITrackingRunLoopMode</code> - 用于<code>UIScrollView</code>和别的控件的动画</li>
</ul>
<p>用了<code>NSDefaultRunLoopMode</code>，但是不能保证动画平滑的运行，所以就可以用<code>NSRunLoopCommonModes</code>来替代。但是要小心，因为如果动画在一个高帧率情况下运行，会发现一些别的类似于定时器的任务或者类似于滑动的其他iOS动画会暂停，直到动画结束。</p>
<p>同样可以同时对<code>CADisplayLink</code>指定多个run loop模式，于是可以同时加入<code>NSDefaultRunLoopMode</code>和<code>UITrackingRunLoopMode</code>来保证它不会被滑动打断，也不会被其他UIKit控件动画影响性能，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.timer = [CADisplayLink displayLinkWithTarget:self selector:@selector(step:)];</span><br><span class="line">[self.timer addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line">[self.timer addToRunLoop:[NSRunLoop mainRunLoop] forMode:UITrackingRunLoopMode];</span><br></pre></td></tr></table></figure>
<h2 id="物理模拟"><a href="#物理模拟" class="headerlink" title="物理模拟"></a>物理模拟</h2><p>略</p>
<h1 id="性能调优-lt-重点-gt"><a href="#性能调优-lt-重点-gt" class="headerlink" title="性能调优&lt;重点&gt;"></a>性能调优&lt;重点&gt;</h1><h2 id="动画的舞台"><a href="#动画的舞台" class="headerlink" title="动画的舞台"></a>动画的舞台</h2><p>动画和屏幕上组合的图层实际上被一个单独的进程管理，而不是你的应用程序。这个进程就是所谓的<em>渲染服务</em>。在iOS5和之前的版本是<em>SpringBoard</em>进程（同时管理着iOS的主屏）。在iOS6之后的版本中叫做<code>BackBoard</code>。</p>
<pre><code>当运行一段动画时候，这个过程会被四个分离的阶段被打破：
</code></pre><ul>
<li><strong>布局</strong> - 这是准备你的视图/图层的层级关系，以及设置图层属性（位置，背景色，边框等等）的阶段。</li>
<li><strong>显示</strong> - 这是图层的寄宿图片被绘制的阶段。绘制有可能涉及你的<code>-drawRect:</code>和<code>-drawLayer:inContext:</code>方法的调用路径。</li>
<li><strong>准备</strong> - 这是Core Animation准备发送动画数据到渲染服务的阶段。这同时也是Core Animation将要执行一些别的事务例如解码动画过程中将要显示的图片的时间点。</li>
<li><strong>提交</strong> - 这是最后的阶段，Core Animation打包所有图层和动画属性，然后通过IPC（内部处理通信）发送到渲染服务进行显示。</li>
</ul>
<p>一旦打包的图层和动画到达渲染服务进程，他们会被反序列化来形成另一个叫做<em>渲染树</em>的图层树（在第一章“图层树”中提到过）。使用这个树状结构，渲染服务对动画的每一帧做出如下工作：</p>
<ul>
<li>对所有的图层属性计算中间值，设置OpenGL几何形状（纹理化的三角形）来执行渲染</li>
<li><p>在屏幕上渲染可见的三角形</p>
<p>所以一共有六个阶段；最后两个阶段在动画过程中不停地重复。前五个阶段都在软件层面处理（通过CPU），只有最后一个被GPU执行。而且，你真正只能控制前两个阶段：布局和显示。Core Animation框架在内部处理剩下的事务，你也控制不了它。</p>
</li>
</ul>
<h3 id="GPU相关的操作"><a href="#GPU相关的操作" class="headerlink" title="GPU相关的操作"></a>GPU相关的操作</h3><p>GPU为一个具体的任务做了优化：它用来采集图片和形状（三角形），运行变换，应用纹理和混合然后把它们输送到屏幕上。现代iOS设备上可编程的GPU在这些操作的执行上又很大的灵活性，但是Core Animation并没有暴露出直接的接口。除非想绕开Core Animation并编写你自己的OpenGL着色器，从根本上解决硬件加速的问题，那么剩下的所有都还是需要在CPU的软件层面上完成。</p>
<p>宽泛的说，大多数<code>CALayer</code>的属性都是用GPU来绘制。比如设置图层背景或者边框的颜色，那么这些可以通过着色的三角板实时绘制出来。如果对一个<code>contents</code>属性设置一张图片，然后裁剪它 - 它就会被纹理的三角形绘制出来，而不需要软件层面做任何绘制。</p>
<pre><code>但是有一些事情会降低（基于GPU）图层绘制，比如：
</code></pre><ul>
<li>太多的几何结构 - 这发生在需要太多的三角板来做变换，以应对处理器的栅格化的时候。现代iOS设备的图形芯片可以处理几百万个三角板，所以在Core Animation中几何结构并不是GPU的瓶颈所在。但由于图层在显示之前通过IPC发送到渲染服务器的时候（图层实际上是由很多小物体组成的特别重量级的对象），太多的图层就会引起CPU的瓶颈。这就限制了一次展示的图层个数。</li>
<li>重绘 - 主要由重叠的半透明图层引起。GPU的<em>填充比率</em>（用颜色填充像素的比率）是有限的，所以需要避免<em>重绘</em>（每一帧用相同的像素填充多次）的发生。在现代iOS设备上，GPU都会应对重绘；即使是iPhone 3GS都可以处理高达2.5的重绘比率，并任然保持60帧率的渲染（这意味着你可以绘制一个半的整屏的冗余信息，而不影响性能），并且新设备可以处理更多。</li>
<li>离屏绘制 - 这发生在当不能直接在屏幕上绘制，并且必须绘制到离屏图片的上下文中的时候。离屏绘制发生在基于CPU或者是GPU的渲染，或者是为离屏图片分配额外内存，以及切换绘制上下文，这些都会降低GPU性能。对于特定图层效果的使用，比如圆角，图层遮罩，阴影或者是图层光栅化都会强制Core Animation提前渲染图层的离屏绘制。但这不意味着你需要避免使用这些效果，只是要明白这会带来性能的负面影响。</li>
<li>过大的图片 - 如果视图绘制超出GPU支持的2048x2048或者4096x4096尺寸的纹理，就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性能。</li>
</ul>
<h3 id="CPU相关的操作"><a href="#CPU相关的操作" class="headerlink" title="CPU相关的操作"></a>CPU相关的操作</h3><p>大多数工作在Core Animation的CPU都发生在动画开始之前。这意味着它不会影响到帧率，所以很好，但是他会<code>延迟动画开始的时间</code>，让界面看起来会比较迟钝。</p>
<pre><code>以下CPU的操作都会延迟动画的开始时间：
</code></pre><ul>
<li>布局计算 - 如果你的视图层级过于复杂，当视图呈现或者修改的时候，计算图层帧率就会消耗一部分时间。特别是使用iOS6的自动布局机制尤为明显，它应该是比老版的自动调整逻辑加强了CPU的工作。</li>
<li>视图懒加载 - iOS只会当视图控制器的视图显示到屏幕上时才会加载它。这对内存使用和程序启动时间很有好处，但是当呈现到屏幕上之前，按下按钮导致的许多工作都会不能被及时响应。比如控制器从数据库中获取数据，或者视图从一个nib文件中加载，或者涉及IO的图片显示，都会比CPU正常操作慢得多。</li>
<li>Core Graphics绘制 - 如果对视图实现了<code>-drawRect:</code>方法，或者<code>CALayerDelegate</code>的<code>-drawLayer:inContext:</code>方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢，所以在一个对性能十分挑剔的场景下这样做十分不好。</li>
<li>解压图片 - PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（通常等同于图片宽 x 长 x 4个字节）。为了节省内存，iOS通常直到真正绘制的时候才去解码图片。根据你加载图片的方式，第一次对图层内容赋值的时候（直接或者间接使用<code>UIImageView</code>）或者把它绘制到Core Graphics中，都需要对它解压，这样的话，对于一个较大的图片，都会占用一定的时间。</li>
</ul>
<p>当图层被成功打包，发送到渲染服务器之后，CPU仍然要做如下工作：为了显示屏幕上的图层，Core Animation必须对渲染树种的每个可见图层通过OpenGL循环转换成纹理三角板。由于GPU并不知晓Core Animation图层的任何结构，所以必须要由CPU做这些事情。这里CPU涉及的工作和图层个数成正比，所以如果在你的层级关系中有太多的图层，就会导致CPU没一帧的渲染，即使这些事情不是你的应用程序可控的。</p>
<h3 id="IO相关操作"><a href="#IO相关操作" class="headerlink" title="IO相关操作"></a>IO相关操作</h3><p>上下文中的IO（输入/输出）指的是例如闪存或者网络接口的硬件访问。一些动画可能需要从闪存（甚至是远程URL）来加载。一个典型的例子就是两个视图控制器之间的过渡效果，这就需要从一个nib文件或者是它的内容中懒加载，或者一个旋转的图片，可能在内存中尺寸太大，需要动态滚动来加载。</p>
<p>IO比内存访问更慢，所以如果动画涉及到IO，就是一个大问题。总的来说，这就需要使用聪敏但尴尬的技术，也就是多线程，缓存和预加载（提前加载当前不需要的资源，但是之后可能需要用到）。</p>
<h1 id="高效绘图"><a href="#高效绘图" class="headerlink" title="高效绘图"></a>高效绘图</h1><p>术语<em>绘图</em>通常在Core Animation的上下文中指代软件绘图（意即：不由GPU协助的绘图）。在iOS中，软件绘图通常是由Core Graphics框架完成来完成。但是，在一些必要的情况下，相比Core Animation和OpenGL，Core Graphics要慢了不少。</p>
<p>软件绘图不仅效率低，还会消耗可观的内存。<code>CALayer</code>只需要一些与自己相关的内存：只有它的寄宿图会消耗一定的内存空间。即使直接赋给<code>contents</code>属性一张图片，也不需要增加额外的照片存储大小。如果相同的一张图片被多个图层作为<code>contents</code>属性，那么他们将会共用同一块内存，而不是复制内存块。</p>
<p>但是一旦你实现了<code>CALayerDelegate</code>协议中的<code>-drawLayer:inContext:</code>方法或者<code>UIView</code>中的<code>-drawRect:</code>方法（其实就是前者的包装方法），图层就创建了一个绘制上下文，这个上下文需要的大小的内存可从这个算式得出：图层宽*图层高*4字节，宽高的单位均为像素。对于一个在Retina iPad上的全屏图层来说，这个内存量就是 2048*1526*4字节，相当于12MB内存，图层每次重绘的时候都需要重新抹掉内存然后重新分配。</p>
<p>软件绘图的代价昂贵，除非绝对必要，应该避免重绘视图。提高绘制性能的秘诀就在于尽量避免去绘制。</p>
<h2 id="矢量图形"><a href="#矢量图形" class="headerlink" title="矢量图形"></a>矢量图形</h2><pre><code>用Core Graphics来绘图的一个通常原因就是只是用图片或是图层效果不能轻易地绘制出矢量图形。矢量绘图包含一下这些：
</code></pre><ul>
<li>任意多边形（不仅仅是一个矩形）</li>
<li>斜线或曲线</li>
<li>文本</li>
<li>渐变</li>
</ul>
<p>用Core Graphics做一个简单的『画板』。这样实现的问题在于，画得越多，程序就会越慢。因为每次移动手指的时候都会重绘整个贝塞尔路径（<code>UIBezierPath</code>），随着路径越来越复杂，每次重绘的工作就会增加，直接导致了帧数的下降。</p>
<p><code>CAShapeLayer</code>可以绘制多边形，直线和曲线。<code>CATextLayer</code>可以绘制文本。<code>CAGradientLayer</code>用来绘制渐变。这些总体上都比Core Graphics更快，同时他们也避免了创造一个寄宿图。</p>
<p>用<code>CAShapeLayer</code>替代Core Graphics，性能就会得到提高。虽然随着路径复杂性的增加，绘制性能依然会下降，但是只有当非常非常浮躁的绘制时才会感到明显的帧率差异。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class DrawingView: UIView &#123;</span><br><span class="line">    class override var layerClass: AnyClass &#123;</span><br><span class="line">        <span class="keyword">return</span> CAShapeLayer.self</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> path = UIBezierPath()</span><br><span class="line">    override init(frame: CGRect) &#123;</span><br><span class="line">        <span class="keyword">super</span>.init(frame: frame)</span><br><span class="line">        self.backgroundColor = .lightGray</span><br><span class="line">        <span class="keyword">let</span> shapeLayer = self.layer <span class="keyword">as</span>! CAShapeLayer</span><br><span class="line">        shapeLayer.strokeColor = UIColor.orange.cgColor</span><br><span class="line">        shapeLayer.fillColor = UIColor.clear.cgColor</span><br><span class="line">        shapeLayer.lineJoin = CAShapeLayerLineJoin.miter</span><br><span class="line">        shapeLayer.lineCap = CAShapeLayerLineCap.round</span><br><span class="line">        shapeLayer.lineWidth = <span class="number">5.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    required init?(coder: NSCoder) &#123;</span><br><span class="line">        fatalError(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func touchesBegan(_ touches: <span class="built_in">Set</span>&lt;UITouch&gt;, <span class="keyword">with</span> event: UIEvent?) &#123;</span><br><span class="line">        <span class="keyword">super</span>.touchesBegan(touches, <span class="attr">with</span>: event)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> point = touches.first?.location(<span class="keyword">in</span>: self) &#123;</span><br><span class="line">            path.move(to: point)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    override func touchesMoved(_ touches: <span class="built_in">Set</span>&lt;UITouch&gt;, <span class="keyword">with</span> event: UIEvent?) &#123;</span><br><span class="line">        <span class="keyword">super</span>.touchesMoved(touches, <span class="attr">with</span>: event)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> point = touches.first?.location(<span class="keyword">in</span>: self) &#123;</span><br><span class="line">            path.addLine(to: point)</span><br><span class="line">            self.setNeedsDisplay()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> shapeLayer = self.layer <span class="keyword">as</span>! CAShapeLayer</span><br><span class="line">        shapeLayer.path = self.path.cgPath</span><br><span class="line">    &#125;</span><br><span class="line">    override func draw(_ rect: CGRect) &#123;</span><br><span class="line">        UIColor.clear.setFill()</span><br><span class="line">        UIColor.orange.setStroke()</span><br><span class="line">        path.stroke()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="脏矩形"><a href="#脏矩形" class="headerlink" title="脏矩形"></a>脏矩形</h2><p>为了减少不必要的绘制，Mac OS和iOS设备将会把屏幕区分为需要重绘的区域和不需要重绘的区域。那些需要重绘的部分被称作『脏区域』。在实际应用中，鉴于非矩形区域边界裁剪和混合的复杂性，通常会区分出包含指定视图的矩形位置，而这个位置就是『脏矩形』。</p>
<p>当一个视图被改动过了，TA可能需要重绘。但是很多情况下，只是这个视图的一部分被改变了，所以重绘整个寄宿图就太浪费了。但是Core Animation通常并不了解你的自定义绘图代码，它也不能自己计算出脏区域的位置。然而，你的确可以提供这些信息。</p>
<pre><code>当你检测到指定视图或图层的指定部分需要被重绘，你直接调用`-setNeedsDisplayInRect:`来标记它，然后将影响到的矩形作为参数传入。这样就会在一次视图刷新时调用视图的`-drawRect:`（或图层代理的`-drawLayer:inContext:`方法）。
</code></pre><p>  传入<code>-drawLayer:inContext:</code>的<code>CGContext</code>参数会自动被裁切以适应对应的矩形。为了确定矩形的尺寸大小，你可以用<code>CGContextGetClipBoundingBox()</code>方法来从上下文获得大小。调用<code>-drawRect()</code>会更简单，因为<code>CGRect</code>会作为参数直接传入。</p>
<h2 id="异步绘制"><a href="#异步绘制" class="headerlink" title="异步绘制"></a>异步绘制</h2><p>UIKit的单线程天性意味着寄宿图通畅要在主线程上更新，这意味着绘制会打断用户交互，甚至让整个app看起来处于无响应状态。</p>
<p>针对这个问题，有一些方法可以用到：一些情况下，可以推测性地提前在另外一个线程上绘制内容，然后将由此绘出的图片直接设置为图层的内容。这实现起来可能不是很方便，但是在特定情况下是可行的。Core Animation提供了一些选择：<code>CATiledLayer</code>和<code>drawsAsynchronously</code>属性。</p>
<h3 id="CATiledLayer-1"><a href="#CATiledLayer-1" class="headerlink" title="CATiledLayer"></a>CATiledLayer</h3><p><code>CATiledLayer</code>还有一个有趣的特性：在多个线程中为每个小块同时调用<code>-drawLayer:inContext:</code>方法。这就避免了阻塞用户交互而且能够利用多核心新片来更快地绘制。只有一个小块的<code>CATiledLayer</code>是实现异步更新图片视图的简单方法。</p>
<h3 id="drawsAsynchronously"><a href="#drawsAsynchronously" class="headerlink" title="drawsAsynchronously"></a>drawsAsynchronously</h3><p><code>drawsAsynchronously</code>属性对传入<code>-drawLayer:inContext:</code>的CGContext进行改动，允许CGContext延缓绘制命令的执行以至于不阻塞用户交互。</p>
<p>  它与<code>CATiledLayer</code>使用的异步绘制并不相同。它自己的<code>-drawLayer:inContext:</code>方法只会在主线程调用，但是CGContext并不等待每个绘制命令的结束。相反地，它会将命令加入队列，当方法返回时，在后台线程逐个执行真正的绘制。</p>
<pre><code>根据苹果的说法。这个特性在需要频繁重绘的视图上效果最好（比如我们的绘图应用，或者诸如`UITableViewCell`之类的），对那些只绘制一次或很少重绘的图层内容来说没什么太大的帮助。
</code></pre><h1 id="图像IO"><a href="#图像IO" class="headerlink" title="图像IO"></a>图像IO</h1><ul>
<li>大图需要异步加载</li>
<li>PNG图片加载会比JPEG更长，因为文件可能更大，但是解码会相对较快，而且Xcode会把PNG图片进行解码优化之后引入工程。JPEG图片更小，加载更快，但是解压的步骤要消耗更长的时间，因为JPEG解压算法比基于zip的PNG算法更加复杂。</li>
</ul>
<p>当加载图片的时候，iOS通常会延迟解压图片的时间，直到加载到内存之后。这就会在准备绘制图片的时候影响性能，因为需要在绘制之前进行解压（通常是消耗时间的问题所在）。</p>
<p> 最简单的方法就是使用<code>UIImage</code>的<code>+imageNamed:</code>方法避免延时加载。不像<code>+imageWithContentsOfFile:</code>（和其他别的<code>UIImage</code>加载方法），这个方法会在加载图片之后立刻进行解压（就和本章之前我们谈到的好处一样）。</p>
<p><code>[UIImage imageNamed:]</code>方法有另一个非常显著的好处：它在内存中自动缓存了解压后的图片，即使你自己没有保留对它的任何引用。</p>
<p>但是并不是对应用程序需要显示的所有类型的图片都适用：</p>
<ul>
<li><code>[UIImage imageNamed:]</code>方法仅仅适用于在应用程序资源束目录下的图片，但是大多数应用的许多图片都要从网络或者是用户的相机中获取，所以<code>[UIImage imageNamed:]</code>就没法用了。</li>
<li><code>[UIImage imageNamed:]</code>缓存用来存储应用界面的图片（按钮，背景等等）。如果对照片这种大图也用这种缓存，那么iOS系统就很可能会移除这些图片来节省内存。那么在切换页面时性能就会下降，因为这些图片都需要重新加载。对传送器的图片使用一个单独的缓存机制就可以把它和应用图片的生命周期解耦。</li>
<li><code>[UIImage imageNamed:]</code>缓存机制并不是公开的，不能很好地控制它。例如，没法做到检测图片是否在加载之前就做了缓存，不能够设置缓存大小，当图片没用的时候也不能把它从缓存中移除。</li>
</ul>
<p>使用NSCache做预加载代替<code>[UIImage imageNamed:</code>可以实现自定义缓存机制。</p>
<h1 id="图层性能"><a href="#图层性能" class="headerlink" title="图层性能"></a>图层性能</h1><h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p><code>CALayer</code>的<code>shouldRasterize</code>属性，它可以解决重叠透明图层的混合失灵问题。它也是作为绘制复杂图层树结构的优化方法。</p>
<p> 启用<code>shouldRasterize</code>属性会将图层绘制到一个屏幕之外的图像。然后这个图像将会被缓存起来并绘制到实际图层的<code>contents</code>和子图层。如果有很多的子图层或者有复杂的效果应用，这样做就会比重绘所有事务的所有帧划得来得多。但是光栅化原始图像需要时间，而且还会消耗额外的内存。</p>
<p>当使用得当时，光栅化可以提供很大的性能优势，但是一定要避免作用在内容不断变动的图层上，否则它缓存方面的好处就会消失，而且会让性能变的更糟。</p>
<p>为了检测是否正确地使用了光栅化方式，用Instrument查看一下Color Hits Green和Misses Red项目，是否已光栅化图像被频繁地刷新（这样就说明图层并不是光栅化的好选择，或则无意间触发了不必要的改变导致了重绘行为）。</p>
<h2 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h2><p>图层的以下属性将会触发屏幕外绘制：</p>
<ul>
<li>圆角（当和<code>maskToBounds</code>一起使用时）</li>
<li>图层蒙板</li>
<li>阴影</li>
</ul>
<p>屏幕外渲染和我们启用光栅化时相似，除了它并没有像光栅化图层那么消耗大，子图层并没有被影响到，而且结果也没有被缓存，所以不会有长期的内存占用。但是，如果太多图层在屏幕外渲染依然会影响到性能。</p>
<p>对于那些需要动画而且要在屏幕外渲染的图层来说，可以用<code>CAShapeLayer</code>，<code>contentsCenter</code>或者<code>shadowPath</code>来获得同样的表现而且较少地影响到性能。</p>
<h2 id="CAShapeLayer-1"><a href="#CAShapeLayer-1" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h2><p><code>cornerRadius</code>和<code>maskToBounds</code>独立作用的时候都不会有太大的性能问题，但是当他俩结合在一起，就触发了屏幕外渲染。有时候想显示圆角并沿着图层裁切子图层的时候，会发现你并不需要沿着圆角裁切，这个情况下用<code>CAShapeLayer</code>就可以避免这个问题了。</p>
<h2 id="shadowPath"><a href="#shadowPath" class="headerlink" title="shadowPath"></a>shadowPath</h2><p>如果图层是一个简单几何图形如矩形或者圆角矩形（假设不包含任何透明部分或者子图层），创建出一个对应形状的阴影路径就比较容易，而且Core Animation绘制这个阴影也相当简单，避免了屏幕外的图层部分的预排版需求。这对性能来说很有帮助。</p>
<p>如果图层是一个更复杂的图形，生成正确的阴影路径可能就比较难了，这样子的话可以用绘图软件预先生成一个阴影背景图。</p>
<h2 id="混合和过度绘制"><a href="#混合和过度绘制" class="headerlink" title="混合和过度绘制"></a>混合和过度绘制</h2><p>GPU每一帧可以绘制的像素有一个最大限制（就是所谓的fill rate），这个情况下可以轻易地绘制整个屏幕的所有像素。但是如果由于重叠图层的关系需要不停地重绘同一区域的话，掉帧就可能发生了。</p>
<p>GPU会放弃绘制那些完全被其他图层遮挡的像素，但是要计算出一个图层是否被遮挡也是相当复杂并且会消耗处理器资源。同样，合并不同图层的透明重叠像素（即混合）消耗的资源也是相当客观的。所以为了加速处理进程，不到必须时刻不要使用透明图层。任何情况下，应该这样做：</p>
<ul>
<li>给视图的<code>backgroundColor</code>属性设置一个固定的，不透明的颜色</li>
<li>设置<code>opaque</code>属性为YES</li>
</ul>
<blockquote>
<p>该属性为BOOL值，UIView的默认值是YES，但UIButton等子类的默认值都是NO。\<br>opaque表示当前UIView是否不透明，不过搞笑的是事实上它却决定不了当前UIView是不是不透明，比如你将opaque设为NO，该UIView照样是可见的。其作用在于：给绘图系统提供一个性能优化开关。如果该值为YES，那么绘图在绘制该视图的时候把整个视图当做不透明对待。这样，绘图系统在执行绘图过程中会优化一些操作并提供系统性能；如果是设置为NO，绘图系统将其和其他内容平等对待，不去做优化操作。为了性能方面的考量，默认被置为YES（意味着优化）。</p>
<ol>
<li>UIView当有背景颜色时：并且背景颜色有透明度（透明度不为1时），将opaque设置为YES性能较高。</li>
<li>UIVIew有背景颜色时：并且背景颜色的透明度为1，opaque的值不影响性能。</li>
<li>UIVIew没有背景颜色时：opaque的值不影响性能。</li>
</ol>
</blockquote>
<p>这样做减少了混合行为（因为编译器知道在图层之后的东西都不会对最终的像素颜色产生影响）并且计算得到了加速，避免了过度绘制行为因为Core Animation可以舍弃所有被完全遮盖住的图层，而不用每个像素都去计算一遍。</p>
<p>如果用到了图像，尽量避免透明除非非常必要。如果图像要显示在一个固定的背景颜色或是固定的背景图之前，你没必要相对前景移动，你只需要预填充背景图片就可以避免运行时混色了。</p>
<p>如果是文本的话，一个白色背景的<code>UILabel</code>（或者其他颜色）会比透明背景要更高效。</p>
<p>最后，明智地使用<code>shouldRasterize</code>属性，可以将一个固定的图层体系折叠成单张图片，这样就不需要每一帧重新合成了，也就不会有因为子图层之间的混合和过度绘制的性能问题了。</p>
<h2 id="减少图层数量"><a href="#减少图层数量" class="headerlink" title="减少图层数量"></a>减少图层数量</h2><p>初始化图层，处理图层，打包通过IPC发给渲染引擎，转化成OpenGL几何图形，这些是一个图层的大致资源开销。事实上，一次性能够在屏幕上显示的最大图层数量也是有限的。</p>
<p>在对图层做任何优化之前，需要确定你不是在创建一些不可见的图层，图层在以下几种情况下回事不可见的：</p>
<ul>
<li>图层在屏幕边界之外，或是在父图层边界之外。</li>
<li>完全在一个不透明图层之后。</li>
<li>完全透明</li>
</ul>
<p>Core Animation非常擅长处理对视觉效果无意义的图层。但是经常性地，代码会比Core Animation更早地想知道一个图层是否是有用的。理想状况下，在图层对象在创建之前就想知道，以避免创建和配置不必要图层的额外工作。</p>
<h2 id="对象回收"><a href="#对象回收" class="headerlink" title="对象回收"></a>对象回收</h2><p>对象回收的基础原则就是你需要创建一个相似对象池。当一个对象的指定实例（本例子中指的是图层）结束了使命，你把它添加到对象池中。每次当你需要一个实例时，你就从池中取出一个。当且仅当池中为空时再创建一个新的。</p>
<p>这样做的好处在于避免了不断创建和释放对象（相当消耗资源，因为涉及到内存的分配和销毁）而且也不必给相似实例重复赋值。</p>

          
        
      
    </div>
    
    
    

    

    

    
   
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigporo.github.io/2020/08/27/关于App-Extension/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iDog">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://raw.githubusercontent.com/BigPoro/PictureBed/master/head_portrait.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iDog的精神时光屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/27/关于App-Extension/" itemprop="url">关于App Extension</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-27T09:48:28+08:00">
                2020-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  933
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="https://visualhunt.com/photos/1/street-vehicle-motor-scooter-vespa-1.jpg?s=s" alt></p>
<h2 id="App-Extension"><a href="#App-Extension" class="headerlink" title="App Extension"></a>App Extension</h2><p>　App Extension可以让你扩展你APP的自定义功能和内容，使用户可以在与其他应用或者系统进行互动的时候去使用它。</p>
<ul>
<li>extension并不是一个独立的app，它有一个包含在app bundle中的独立bundle；</li>
<li>extension不能单独存在，必须有一个包含它的containing app；</li>
<li>不同的extension激活方式不同；</li>
<li>常见的种类包括Today Widget、Share Extension、Action Extension、Document Provider、Custom Keyboard
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/08/27/关于App-Extension/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </li></ul></div>
    
    
    

    

    

    
   
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigporo.github.io/2020/08/23/组件化方案的对比和分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iDog">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://raw.githubusercontent.com/BigPoro/PictureBed/master/head_portrait.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iDog的精神时光屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/23/组件化方案的对比和分析/" itemprop="url">组件化方案的对比和分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-23T22:37:08+08:00">
                2020-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  684
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="https://visualhunt.com/photos/1/underwater-blue-ocean-sea.jpg?s=s" alt></p>
<p>本文将介绍下主流的三种组件化方案，并对比分析各自的优缺点。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/08/23/组件化方案的对比和分析/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    
   
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigporo.github.io/2019/08/20/Cocoapods私有库搭建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iDog">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://raw.githubusercontent.com/BigPoro/PictureBed/master/head_portrait.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iDog的精神时光屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/20/Cocoapods私有库搭建/" itemprop="url">Cocoapods私有库搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-20T22:02:19+08:00">
                2019-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具集/" itemprop="url" rel="index">
                    <span itemprop="name">工具集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  17
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSRYwBhU67p7i0G49VmSp-F2gyOlaxm8ocKmSN8mWse6p7605W4pQ" alt></p>
<p><code>Cocoapods</code>是非常好用的一个iOS依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，以及将自己的项目中的公共组件交由它去管理。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/08/20/Cocoapods私有库搭建/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    
   
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigporo.github.io/2019/05/17/从App启动开始/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iDog">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://raw.githubusercontent.com/BigPoro/PictureBed/master/head_portrait.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iDog的精神时光屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/17/从App启动开始/" itemprop="url">从App启动开始</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-17T11:34:23+08:00">
                2019-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  965
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="https://visualhunt.com/photos/1/sunrise-in-a-forest-1.jpg?s=s" alt></p>
<h2 id="App启动时都干了哪些事？"><a href="#App启动时都干了哪些事？" class="headerlink" title="App启动时都干了哪些事？"></a>App启动时都干了哪些事？</h2><p>一般情况下，App的启动分为冷启动和热启动。</p>
<h3 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h3><p>App点击启动前，它的进程不在系统里，需要系统新创建一个进程给它启动的情况，这是一次完成的启动过程。</p>
<h3 id="热启动"><a href="#热启动" class="headerlink" title="热启动"></a>热启动</h3><p>APP在冷启动后被用户退到后台，在App的进程还在系统里的情况下，用户重新启动进入App的过程，这个过程所做的事情非常少。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/05/17/从App启动开始/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    
   
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigporo.github.io/2019/05/17/怎么应对各种富文本表现需求？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iDog">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://raw.githubusercontent.com/BigPoro/PictureBed/master/head_portrait.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iDog的精神时光屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/17/怎么应对各种富文本表现需求？/" itemprop="url">怎么应对各种富文本表现需求？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-17T10:23:12+08:00">
                2019-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  460
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="https://visualhunt.com/photos/1/nature-sunny-man-person-1.jpg?s=s" alt></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在iOS的日常开发中，会经常使用到富文本。</p>
<p>简单来说，富文本就是一段有属性的字符串，可以包含不同字体、不同字号、不同背景、不同颜色、不同字间距的文字，还可以设置段落、图文混排等属性。</p>
<p>正常在使用富文本的时候，有如下方式：HTML、TextKit、YYKit。一般在长列表的场景下，我们使用性能更高、内存占用更少的TextKit、YYKit。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/05/17/怎么应对各种富文本表现需求？/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    
   
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigporo.github.io/2019/04/23/ImageOptim - 图片压缩/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iDog">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://raw.githubusercontent.com/BigPoro/PictureBed/master/head_portrait.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iDog的精神时光屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/23/ImageOptim - 图片压缩/" itemprop="url">ImageOptim - 图片压缩</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-23T17:17:43+08:00">
                2019-04-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具集/" itemprop="url" rel="index">
                    <span itemprop="name">工具集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  114
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="https://link.jianshu.com/?t=https://imageoptim.com/ImageOptim.tbz2" target="_blank" rel="noopener">下载地址</a></p>
<p>ImageOptim是一款基于Mac的图像“瘦身”软件，内置有6种压缩算法，通过删除图片部分无用的EXIF等信息来减小PNG、JPEG和GIF图片的大小。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/04/23/ImageOptim - 图片压缩/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    
   
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigporo.github.io/2019/04/23/Injection：iOS热重载-所见即所得/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iDog">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://raw.githubusercontent.com/BigPoro/PictureBed/master/head_portrait.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iDog的精神时光屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/23/Injection：iOS热重载-所见即所得/" itemprop="url">Injection：iOS热重载-所见即所得</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-23T17:17:43+08:00">
                2019-04-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具集/" itemprop="url" rel="index">
                    <span itemprop="name">工具集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.jianshu.com/p/17fddfaabb1f" target="_blank" rel="noopener">参考博客</a></p>
<p><a href="http://www.cocoachina.com/ios/20180613/23780.html" target="_blank" rel="noopener">参考博客</a></p>

          
        
      
    </div>
    
    
    

    

    

    
   
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bigporo.github.io/2019/04/23/Fastlane-自动打包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iDog">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://raw.githubusercontent.com/BigPoro/PictureBed/master/head_portrait.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iDog的精神时光屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/23/Fastlane-自动打包/" itemprop="url">Fastlane--自动打包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-23T17:17:43+08:00">
                2019-04-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具集/" itemprop="url" rel="index">
                    <span itemprop="name">工具集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  907
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="https://raw.githubusercontent.com/BigPoro/PictureBed/master/fastlane_01.png" alt></p>
<blockquote>
<p>Fastlane是一套使用Ruby写的自动化工具集，旨在简化Android和iOS的部署过程，自动化你的工作流。它可以简化一些乏味、单调、重复的工作，像截图、代码签名以及发布App</p>
</blockquote>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/04/23/Fastlane-自动打包/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    
   
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://raw.githubusercontent.com/BigPoro/PictureBed/master/head_portrait.jpg" alt="iDog">
            
              <p class="site-author-name" itemprop="name">iDog</p>
              <p class="site-description motion-element" itemprop="description">一个记录工作和生活的小地方。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/BigPoro" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/liu-huan-34-85/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">iDog</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>
  <!-- <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div> -->



  <span class="post-meta-divider"> 欢迎来到精神时光屋~~</span>



  <!-- <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div> -->




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
